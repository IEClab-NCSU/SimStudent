/**
 * @fileoverview Unit tests for CTAT.Math.Fraction functions using qUnit.
 * @requires unit_test_util.js
 * @requires //code.jquery.com/qunit/qunit-1.17.1.js
 * @requires third-party/google/closure-library/closure/goog/base.js
 *
 * @author $Author$
 * @version $Revision$
 */
goog.require('CTAT.Math.Fraction');

QUnit.module("CTAT.Math.Fraction");
QUnit.test("new timing", function(assert) {
	var frac = new CTAT.Math.Fraction();
	assert.deepEqual(frac.numerator,0);
	assert.deepEqual(frac.denominator,1);
	var i;
	var a,b,f;
	for (i=1; i<=100000; i++) {
		f = new CTAT.Math.Fraction();
	}
});
QUnit.test("new", function(assert) {
	var frac = new CTAT.Math.Fraction();
	assert.deepEqual(frac.numerator,0);
	assert.deepEqual(frac.denominator,1);
	var i;
	var a,b,f;
	for (i=1; i<=1000; i++) {
		a = unit_test_util.gen100();
		b = unit_test_util.gen100();
		f = new CTAT.Math.Fraction(a, b);
		assert.deepEqual(f.numerator, a, "Numerator "+a+"/"+b);
		assert.deepEqual(f.denominator, b, "Base denominator "+a+"/"+b);

		f = new CTAT.Math.Fraction(null, b);
		assert.deepEqual(f.numerator, 0, "Null numerator null/"+b);
		assert.deepEqual(f.denominator, b, "Null numerator null/"+b);

		f = new CTAT.Math.Fraction(a);
		assert.deepEqual(f.numerator, a, "Just numerator "+a);
		assert.deepEqual(f.denominator, 1, "Just numerator "+a);

		f = new CTAT.Math.Fraction(a,null);
		assert.deepEqual(f.numerator, a, "Null denominator "+a+"/null");
		assert.deepEqual(f.denominator, 1, "Null denominator "+a+"/null");
	}
});
QUnit.test("toString", function(assert) {
	var i,a,b,f;
	for (i=0; i<100; i++) {
		a = unit_test_util.gen100();
		b = unit_test_util.gen100()+1;
		f = new CTAT.Math.Fraction(a,b);
		assert.equal(f.toString(), a+"/"+b);
	}
	for (i=0; i<100; i++) {
		a = unit_test_util.gen100();
		//b = unit_test_util.gen100();
		f = new CTAT.Math.Fraction(a);
		assert.equal(f.toString(), String(a), "String of single integer "+a);
	}
	for (i=0; i<100; i++) {
		a = unit_test_util.gen100();
		b = unit_test_util.gen100();
		f = new CTAT.Math.Fraction(a/b);
		assert.equal(f.toString(), String(a/b), "String of a single number "+(a/b));
	}
});
QUnit.test("valueOf", function(assert) {
	var i,a,b,f;
	for (i=0; i<1000; i++) {
		a=unit_test_util.gen100();
		b=unit_test_util.gen100();
		f= new CTAT.Math.Fraction(a,b);
		assert.equal(CTAT.Math.round(f.valueOf()),CTAT.Math.round(a/b));
	}
});
QUnit.test("equals", function(assert) {
	var i,a,b,f,c;
	for (i=0;i<100;i++) {
		a=unit_test_util.gen100();
		b=unit_test_util.gen100();
		f=new CTAT.Math.Fraction(a,b);
		c=new CTAT.Math.Fraction(a,b);
		assert.propEqual(f,c);
		assert.ok(f.equals(c));
		assert.ok(c.equals(f));
		assert.ok(f.equals(f));
		assert.equal(f.valueOf(),c.valueOf());
		//assert.equal(f,f);
		//assert.notEqual(f,c);
		c.numerator+=1;
		assert.notPropEqual(f,c);
		assert.ok(!f.equals(c));
		assert.ok(!c.equals(f));
		assert.notEqual(f.valueOf(),c.valueOf());
		//assert.notEqual(f,c);
		c.set(f.numerator*2,f.denominator*2);
		assert.ok(f.equals(c));
	}
});
QUnit.test("deepEqual", function(assert) {
	var i,a,b,f,c;
	for (i=0;i<100;i++) {
		a=unit_test_util.gen100();
		b=unit_test_util.gen100();
		f=new CTAT.Math.Fraction(a,b);
		c=new CTAT.Math.Fraction(a,b);
		assert.propEqual(f,c);
		assert.ok(f.deepEquals(c));
		assert.ok(c.deepEquals(f));
		assert.ok(f.deepEquals(f));
		assert.equal(f.numerator,c.numerator);
		assert.equal(f.denominator,c.denominator);
		c.numerator+=1;
		assert.notPropEqual(f,c);
		assert.ok(!f.deepEquals(c));
		assert.notEqual(f.valueOf(),c.valueOf());
		c.set(f.numerator*2,f.denominator*2);
		assert.ok(f.equals(c));
		assert.ok(!f.deepEquals(c));
		assert.ok(c.equals(f));
		assert.ok(!c.deepEquals(f));
	}
});
QUnit.test("fromString", function(assert) {
	var i,a,b,f;
	f=new CTAT.Math.Fraction();
	var g = new CTAT.Math.Fraction();
	for (i=0; i<1000; i++) {
		a=unit_test_util.gen100();
		b=unit_test_util.gen100()+1;
		s=String(a)+"/"+String(b);
		f.fromString(s);
		assert.equal(f.toString(),s, "Test parsing of "+s);
		g.fromString(f.toString());
		assert.ok(f.deepEquals(g));
		f.fromString(String(a));
		assert.equal(f.valueOf(),a, "Test parsing of "+a);
	}
	f.fromString("1/2/3");
	assert.equal(f.valueOf(),1/2);
	f.fromString("foo");
	assert.ok(isNaN(f.numerator));
	assert.equal(f.denominator,1);
});
QUnit.test("fromValue", function(assert) {
	var i,a,b,f;
	f = new CTAT.Math.Fraction();
	for (i=0;i<100;i++) {
		a = unit_test_util.gen100();
		b = unit_test_util.gen100();
		f.fromValue(a);
		assert.deepEqual(f.valueOf(),a);
		assert.deepEqual(f.denominator,1);
		f.fromValue(a/b);
		assert.deepEqual(CTAT.Math.round(f.valueOf()),CTAT.Math.round(a/b));
		assert.deepEqual(f.denominator,1);
	}
	f.fromValue("foo");
	assert.ok(isNaN(f.numerator));
	assert.equal(f.denominator,1);
});
QUnit.test("toMathML", function(assert) {
	// This should be updated to use qunit-fixture to test generation
	//var fixture = document.getElementById("qunit-fixture");
	var a,b,f;
	a = unit_test_util.gen100();
	b = unit_test_util.gen100()+1;
	f = new CTAT.Math.Fraction(a,b);
	if (f.toMathML().hasOwnProperty('outerHTML')) {
		// PhantomJS's elements do not have outerHTML
		var ml = "<math><mfrac><mrow><mn>"+a+"</mn></mrow><mrow><mn>"+b+"</mn></mrow></mfrac></math>";
		assert.equal(f.toMathML().outerHTML,ml);
		f.denominator = 1;
		ml = "<math><mn>"+a+"</mn></math>";
		assert.equal(f.toMathML().outerHTML,ml);
	} else {
		// PhantomJS, the engine used in grunt-contrib-qunit, doesn't seem to
		// support outerHTML on Element objects created by createElementNS.
		//var ml = "<mfrac><mrow><mn>"+a+"</mn></mrow><mrow><mn>"+b+"</mn></mrow></mfrac>";
		assert.equal(f.toMathML().nodeName,'math');
		f.denominator = 1;
		//ml = "<mn>"+a+"</mn>";
		assert.equal(f.toMathML().nodeName,'math');

	}
});
QUnit.test("is_proper", function(assert) {
	var i,a,b,f;
	for (i=0;i<100;i++) {
		a = unit_test_util.gen100();
		b = unit_test_util.gen100()+110; // make sure b > a
		f = new CTAT.Math.Fraction(a,b);
		assert.equal(f.is_proper,true);
		f = new CTAT.Math.Fraction(b,a);
		assert.equal(f.is_proper,false);
		f = new CTAT.Math.Fraction(a,a);
		assert.equal(f.is_proper,false);
	}
});
QUnit.test("whole_part", function(assert) {
	var i,a,b,f;
	for (i=0;i<100;i++) {
		a = unit_test_util.gen100();
		b = unit_test_util.gen100()+110; // make sure b > a
		f = new CTAT.Math.Fraction(a,b);
		assert.equal(f.whole_part,0);
		f = new CTAT.Math.Fraction(b,a);
		assert.equal(f.whole_part,Math.floor(b/a));
		f = new CTAT.Math.Fraction(a,a);
		assert.equal(f.whole_part,1);
	}
});
QUnit.test("remainder_part", function(assert) {
	var i,a,b,f,r;
	for (i=0;i<100;i++) {
		a = unit_test_util.gen100();
		b = unit_test_util.gen100()+110; // make sure b > a
		f = new CTAT.Math.Fraction(a,b);
		r = f.remainder_part;
		assert.equal(r.numerator,f.numerator);
		assert.equal(r.denominator,f.denominator);
		f = new CTAT.Math.Fraction(b,a);
		assert.equal(f.remainder_part.deepEquals(new CTAT.Math.Fraction(b%a,a)),true);
		f = new CTAT.Math.Fraction(a,a);
		assert.equal(f.remainder_part.deepEquals(new CTAT.Math.Fraction(0,a)),true);
	}
});
QUnit.test("set_denominator", function(assert) {
	var i,a,b,c,f,g;
	for (i=0;i<100;i++) {
		a=unit_test_util.gen100();
		b=unit_test_util.gen100();
		do { c=unit_test_util.gen100(); } while (c==b);
		f=new CTAT.Math.Fraction(a,b);
		g=new CTAT.Math.Fraction(a,b);
		f.set_denominator(b);
		assert.ok(f.deepEquals(g), f.toString()+"==="+g.toString()+" for identity");

		f.set_denominator(c);
		assert.equal(f.denominator,c, "Denominator set to "+c);
		assert.equal(CTAT.Math.round(f.numerator),CTAT.Math.round((a/b)*c), "Numerator set to ("+a+"/"+b+")*"+c);
		assert.equal(CTAT.Math.round(f.valueOf()),CTAT.Math.round(a/b), "Testing value vs "+a+"/"+b);
		assert.ok(f.equals(g), "if "+f.toString()+" equals "+g.toString());
		assert.ok(!f.deepEquals(g), "if "+f.toString()+" not deepEquals "+g.toString());

		f.set_denominator(b);
		assert.ok(f.deepEquals(g), f.toString()+"==="+g.toString()+" for reset");
	}
	a=76;
	b=33;
	c=59;
	f=new CTAT.Math.Fraction(a,b);
	g=new CTAT.Math.Fraction(a,b);
	f.set_denominator(b);
	assert.ok(f.deepEquals(g), f.toString()+"==="+g.toString()+" for identity");
	f.set_denominator(b);
	assert.ok(f.deepEquals(g), f.toString()+"==="+g.toString()+" for reset");
	a=10;
	b=77;
	c=4;
	f=new CTAT.Math.Fraction(a,b);
	g=new CTAT.Math.Fraction(a,b);
	f.set_denominator(b);
	assert.ok(f.deepEquals(g), f.toString()+"==="+g.toString()+" for identity");
	f.set_denominator(b);
	assert.ok(f.deepEquals(g), f.toString()+"==="+g.toString()+" for reset");
	a=42;
	b=63;
	c=23;
	f=new CTAT.Math.Fraction(a,b);
	g=new CTAT.Math.Fraction(a,b);
	f.set_denominator(b);
	assert.ok(f.deepEquals(g), f.toString()+"==="+g.toString()+" for identity");
	f.set_denominator(b);
	assert.ok(f.deepEquals(g), f.toString()+"==="+g.toString()+" for reset");
});
QUnit.test("scale", function(assert) {
	var i,a,b,c,f,g;
	for (i=0;i<100;i++) {
		a=unit_test_util.gen100();
		b=unit_test_util.gen100();
		c=unit_test_util.gen100()+1;
		f=new CTAT.Math.Fraction(a,b);
		g=new CTAT.Math.Fraction(a,b);
		f.scale(c);
		assert.equal(f.numerator,a*c, "Numerator set to "+a+"*"+c);
		assert.equal(f.denominator,b*c, "Denominator set to "+b+"*"+c);
		assert.equal(CTAT.Math.round(f.valueOf()),CTAT.Math.round(a/b), "Testing value vs "+a+"/"+b);
		assert.ok(f.equals(g), "if "+f.toString()+" equals "+g.toString());
		assert.ok(!f.deepEquals(g), "if "+f.toString()+" not deepEquals "+g.toString());
		f=new CTAT.Math.Fraction(a,b);
		f.scale(1);
		assert.ok(f.equals(g), "if "+f.toString()+" equals "+g.toString());
		assert.ok(f.deepEquals(g), "if "+f.toString()+" deepEquals "+g.toString());
	}
	f.scale(0);
	assert.equal(f.valueOf(),0);
	assert.equal(f.numerator,0);
	assert.equal(f.denominator,1);
});
QUnit.test("set", function(assert) {
	var a,b,f;
	a=unit_test_util.gen100(); b=unit_test_util.gen100();
	f = new CTAT.Math.Fraction();
	f.set(a,b);
	assert.equal(f.numerator,a, "Number,Number numerator");
	assert.equal(f.denominator,b, "Number,Number denominator");

	a=unit_test_util.gen100(); b=unit_test_util.gen100();
	f.set(String(a),String(b));
	assert.equal(f.numerator,a, "String,String numerator");
	assert.equal(f.denominator,b, "String,String denominator");
	a=unit_test_util.gen100(); b=unit_test_util.gen100();
	f.set(a,String(b));
	assert.equal(f.numerator,a, "Number,String numerator");
	assert.equal(f.denominator,b, "Number,String denominator");
	a=unit_test_util.gen100(); b=unit_test_util.gen100();
	f.set(String(a),b);
	assert.equal(f.numerator,a, "String,Number numerator");
	assert.equal(f.denominator,b, "String,Number denominator");
	f.set("foo","bar");
	assert.equal(f.numerator,0, "'foo','bar' numerator");
	assert.equal(f.denominator,1, "'foo','bar' denominator");
	f.set("","");
	assert.equal(f.numerator,0, "'','' numerator");
	assert.equal(f.denominator,1, "'','' denominator");
	a=unit_test_util.gen100(); b=unit_test_util.gen100();
	f.set(new CTAT.Math.Fraction(a,b).toString(),new CTAT.Math.Fraction(b,a).toString());
	assert.equal(f.numerator,0, "'a/b','b/a' (non-number strings) numerator");
	assert.equal(f.denominator,1, "'a/b','b/a' (non-number strings) denominator");
	a=unit_test_util.gen100(); b=unit_test_util.gen100();
	f.set(new CTAT.Math.Fraction(a),new CTAT.Math.Fraction(b));
	assert.equal(f.numerator,a, "Fraction/Fraction (valueOf() test) numerator");
	assert.equal(f.denominator,b, "Fraction/Fraction (valueOf() test) denominator");
	b=unit_test_util.gen100();
	f.set(null,b);
	assert.equal(f.numerator,0, "null/Number numerator");
	assert.equal(f.denominator,b, "null/Number denominator");
	b=unit_test_util.gen100();
	f.set("",b);
	assert.equal(f.numerator,0, "''/Number numerator");
	assert.equal(f.denominator,b, "''/Number denominator");
	a=unit_test_util.gen100();
	f.set(a,"");
	assert.equal(f.numerator,a, "Number/'' numerator");
	assert.equal(f.denominator,1, "Number/'' denominator");

	a=unit_test_util.gen100();
	f.set(a);
	assert.equal(f.numerator,a, "Number numerator");
	assert.equal(f.denominator,1, "Number denominator");
	a=unit_test_util.gen100();
	f.set(a,null);
	assert.equal(f.numerator,a, "Number,null numerator");
	assert.equal(f.denominator,1, "Number,null denominator");
	a=unit_test_util.gen100();
	f.set(String(a));
	assert.equal(f.numerator,a, "String numerator");
	assert.equal(f.denominator,1, "String denominator");
	a=unit_test_util.gen100(); b=unit_test_util.gen100();
	f.set(String(a)+"/"+String(b));
	assert.equal(f.numerator,a, "'a/b' numerator");
	assert.equal(f.denominator,b, "'a/b' denominator");

	f.set();
	assert.equal(f.numerator,0, "() numerator");
	assert.equal(f.denominator,1, "() denominator");

	f.set();
	a=unit_test_util.gen100(); b=unit_test_util.gen100();
	f.set(new CTAT.Math.Fraction(a,b));
	assert.equal(f.numerator,a, "CTAT.Math.Fraction(a,b) numerator");
	assert.equal(f.denominator,b, "CTAT.Math.Fraction(a,b) denominator");

	f.set(function(){});
	assert.equal(f.numerator,0, "function numerator");
	assert.equal(f.denominator,1, "function denominator");
});
QUnit.test("reduce", function(assert) {
	var i,a,b,c,f;
	for (i=0;i<100;i++) {
		a=unit_test_util.gen_prime();
		do {
			b=unit_test_util.gen_prime();
		} while (b==a);
		do {
			c=unit_test_util.gen_prime();
		} while (c==a || c==b);
		f = new CTAT.Math.Fraction(a,b);
		f.reduce();
		assert.equal(f.numerator,a);
		assert.equal(f.denominator,b);
		f.set(a,a);
		f.reduce();
		assert.equal(f.numerator,1);
		assert.equal(f.denominator,1);
		f.set(a*c,b*c);
		f.reduce();
		assert.equal(f.numerator,a);
		assert.equal(f.denominator,b);
	}
	f.set(0.5,2);
	f.reduce();
	assert.equal(f.numerator,1);
	assert.equal(f.denominator,4);
	f.set(0.5,3);
	f.reduce();
	assert.equal(f.numerator,1);
	assert.equal(f.denominator,6);
});
QUnit.test("reduced", function(assert) {
	var a,b,c,f,g;
	a = unit_test_util.gen_prime();
	do { b=unit_test_util.gen_prime(); } while(b==a);
	do { c=unit_test_util.gen_prime(); } while(c==b || c==a);
	f = new CTAT.Math.Fraction(a*c,b*c);
	g = f.reduced();
	assert.ok(f.equals(g));
	assert.ok(!f.deepEquals(g));
	assert.equal(f.numerator,a*c);
	assert.equal(f.denominator,b*c);
	assert.equal(g.numerator,a);
	assert.equal(g.denominator,b);
});
QUnit.test("reciprocal", function(assert) {
	var i,a,b,f,g;
	for (i=0;i<100;i++) {
		a=unit_test_util.gen100();
		b=unit_test_util.gen100();
		f=new CTAT.Math.Fraction(a,b);
		g=f.reciprocal();
		assert.equal(g.numerator,f.denominator);
		assert.equal(g.denominator,f.numerator);
	}
});
QUnit.test("negative", function(assert) {
	var a,b,f,g;
	a=unit_test_util.gen100();
	b=unit_test_util.gen100();
	f=new CTAT.Math.Fraction(a,b);
	g=f.negative();
	assert.equal(g.numerator,-a);
	assert.equal(g.denominator,b);
	f.set(-a,b);
	g=f.negative();
	assert.equal(g.numerator,a);
	assert.equal(g.denominator,b);
	f.set(a,-b); // should handle negative denominators better
	g=f.negative();
	assert.equal(g.numerator,-a);
	assert.equal(g.denominator,-b);
	f.set(-a,-b);
	g=f.negative();
	assert.equal(g.numerator,a);
	assert.equal(g.denominator,-b);
});
QUnit.test("add", function(assert) {
	var a,b,c,d;
	var f,g,h;
	// Fraction+Number
	a = unit_test_util.gen_prime();
	do { b=unit_test_util.gen_prime(); } while(b==a);
	do { c=unit_test_util.gen_prime(); } while(c==b || c==a);
	f = new CTAT.Math.Fraction(a,b);
	g = f.add(c);
	assert.equal(f.numerator,a,"Immutable f");
	assert.equal(f.denominator,b,"Immutable f");
	assert.equal(g.numerator,a+(b*c),"fraction.add(Number)");
	assert.equal(g.denominator,b,"fraction.add(Number)");

	// Fraction(0,1)+Number
	c=unit_test_util.gen100();
	f = new CTAT.Math.Fraction();
	g = f.add(c);
	assert.equal(f.numerator,0,"Immutable f");
	assert.equal(f.denominator,1,"Immutable f");
	assert.equal(g.numerator,c,"(0/1).add(Number)");
	assert.equal(g.denominator,1,"(0/1).add(Number)");

	// Fraction(0,1)+Fraction
	a = unit_test_util.gen_prime();
	do { b=unit_test_util.gen_prime(); } while(b==a);
	f = new CTAT.Math.Fraction();
	g = f.add(new CTAT.Math.Fraction(a,b));
	assert.equal(f.numerator,0,"Immutable f");
	assert.equal(f.denominator,1,"Immutable f");
	assert.equal(g.numerator,a,"(0/1).add(Fraction)");
	assert.equal(g.denominator,b,"(0/1).add(Fraction)");
	// Fraction+Fraction(0,1)
	a = unit_test_util.gen_prime();
	do { b=unit_test_util.gen_prime(); } while(b==a);
	f = new CTAT.Math.Fraction(a,b);
	g = f.add(new CTAT.Math.Fraction());
	assert.equal(f.numerator,a,"Immutable f");
	assert.equal(f.denominator,b,"Immutable f");
	assert.equal(g.numerator,a,"Fraction.add(0/1)");
	assert.equal(g.denominator,b,"Fraction.add(0/1)");

	// Fraction+Fraction, common denominator
	a = unit_test_util.gen_prime();
	do { b=unit_test_util.gen_prime(); } while(b==a);
	do { c=unit_test_util.gen_prime(); } while(c==b || c==a);
	f = new CTAT.Math.Fraction(a,c);
	g = f.add(new CTAT.Math.Fraction(b,c));
	assert.equal(f.numerator,a,"Immutable f");
	assert.equal(f.denominator,c,"Immutable f");
	assert.equal(g.numerator,a+b,"fraction.add(Fraction) common denominator");
	assert.equal(g.denominator,c,"fraction.add(Fraction) common denominator");
	// Fraction+Fraction, common denominator reducable (but not reduced)
	a = unit_test_util.gen_prime();
	do { b=unit_test_util.gen_prime(); } while(b==a);
	do { c=unit_test_util.gen_prime(); } while(c==b || c==a);
	f = new CTAT.Math.Fraction(a*2,c*2);
	g = f.add(new CTAT.Math.Fraction(b*2,c*2));
	assert.equal(f.numerator,a*2,"Immutable f");
	assert.equal(f.denominator,c*2,"Immutable f");
	assert.equal(g.numerator,(a+b)*2,"fraction.add(Fraction) common denominator");
	assert.equal(g.denominator,c*2,"fraction.add(Fraction) common denominator");

	// Fraction+String, common denominator
	a = unit_test_util.gen_prime();
	do { b=unit_test_util.gen_prime(); } while(b==a);
	do { c=unit_test_util.gen_prime(); } while(c==b || c==a);
	f = new CTAT.Math.Fraction(a,c);
	g = f.add(b+"/"+c);
	assert.equal(f.numerator,a,"Immutable f");
	assert.equal(f.denominator,c,"Immutable f");
	assert.equal(g.numerator,a+b,"fraction.add(String)");
	assert.equal(g.denominator,c,"fraction.add(String)");

	// adding, no reduction
	a = unit_test_util.gen_prime();
	do { b=unit_test_util.gen_prime(); } while(b==a);
	f=new CTAT.Math.Fraction(a,b);
	h=new CTAT.Math.Fraction(b,a);
	g=f.add(h);
	assert.equal(f.numerator,a,"Immutable f");
	assert.equal(f.denominator,b,"Immutable f");
	assert.equal(g.numerator,a*a+b*b,"a/b.add(b/a) "+f.toString()+"+"+h.toString()+'='+g.toString());
	assert.equal(g.denominator,a*b,"a/b.add(b/a)");

	// known to trip up inexact math
	a = 5309;
	b = 7687;
	f=new CTAT.Math.Fraction(a,b);
	h=new CTAT.Math.Fraction(b,a);
	g=f.add(h);
	assert.equal(f.numerator,a,"Immutable f");
	assert.equal(f.denominator,b,"Immutable f");
	assert.equal(g.numerator,a*a+b*b,"a/b.add(b/a) "+f.toString()+"+"+h.toString()+'='+g.toString());
	assert.equal(g.denominator,a*b,"a/b.add(b/a)");


	// adding with reduction
	a = unit_test_util.gen_prime();
	do { b=unit_test_util.gen_prime(); } while(b==a);
	do { c=unit_test_util.gen_prime(); } while(c==b || c==a);
	f=new CTAT.Math.Fraction(a*c,b*c);
	h=new CTAT.Math.Fraction(b*c,a*c);
	g=f.add(h);
	assert.equal(f.numerator,a*c,"Immutable f");
	assert.equal(f.denominator,b*c,"Immutable f");
	assert.equal(g.numerator,a*a+b*b, f.toString()+"+"+h.toString()+'='+g.toString());
	assert.equal(g.denominator,a*b,f.toString()+"+"+h.toString()+'='+g.toString());

	// adding, different denominators, no reduction
	a = unit_test_util.gen_prime();
	do { b=unit_test_util.gen_prime(); } while(b==a);
	do { c=unit_test_util.gen_prime(); } while(c==b || c==a);
	f=new CTAT.Math.Fraction(a,b*c);
	g=f.add(new CTAT.Math.Fraction(b,a*c));
	assert.equal(f.numerator,a,"Immutable f");
	assert.equal(f.denominator,b*c,"Immutable f");
	assert.equal(g.numerator,a*a+b*b,"a/b*c=="+f.toString()+".add(b/a*c)");
	assert.equal(g.denominator,a*b*c,"a/b*c.add(b/a*c)");
});
QUnit.test("subtract", function(assert) {
	// this is a simple check because the tests on add() and negative()
	// should catch most potential errors.
	var f = new CTAT.Math.Fraction(2,3);
	var g = new CTAT.Math.Fraction(1,2);
	var h = f.subtract(g);
	assert.ok(h.deepEquals(new CTAT.Math.Fraction(1,6)));
	h = f.subtract("1/2");
	assert.ok(h.deepEquals(new CTAT.Math.Fraction(1,6)));
	h = f.subtract(1);
	assert.ok(h.deepEquals(new CTAT.Math.Fraction(-1,3)));
});
QUnit.test("multiply", function(assert) {
	var f,g,h;
	f = new CTAT.Math.Fraction(1,2);
	g = new CTAT.Math.Fraction(1,3);
	h = new CTAT.Math.Fraction(1,6);
	assert.ok(h.deepEquals(g.multiply(f)));
	assert.ok(h.deepEquals(f.multiply(g)));
	assert.ok(h.deepEquals(f.multiply('1/3')));
	assert.ok(h.deepEquals(g.multiply(0.5)));
	h = new CTAT.Math.Fraction(1,4);
	assert.ok(h.deepEquals(f.multiply(f)));
	h = new CTAT.Math.Fraction(1,9);
	assert.ok(h.deepEquals(g.multiply(g)));

	f = new CTAT.Math.Fraction(2,4);
	g = new CTAT.Math.Fraction(2,6);
	h = new CTAT.Math.Fraction(1,6);
	assert.ok(h.deepEquals(g.multiply(f)));
});
QUnit.test("divide", function(assert) {
	// this is a simple check because the tests on multiply and reciprocal
	// should cover most of the potential errors.
	var f = new CTAT.Math.Fraction(2,3);
	var h = f.divide(new CTAT.Math.Fraction(1,2));
	assert.ok(h.deepEquals(new CTAT.Math.Fraction(4,3)));
	h = f.divide('1/2');
	assert.ok(h.deepEquals(new CTAT.Math.Fraction(4,3)));
	h = f.divide(2);
	assert.ok(h.deepEquals(new CTAT.Math.Fraction(1,3)));
});
QUnit.test("clone", function(assert) {
	var a,b,f,g;
	a=unit_test_util.gen100();
	b=unit_test_util.gen100();
	f=new CTAT.Math.Fraction(a,b);
	g=f.clone();
	assert.propEqual(g,f);
	assert.ok(g.equals(f));
	assert.ok(f.equals(g));
	assert.ok(f.deepEquals(g));
	assert.ok(g.deepEquals(f));
	assert.ok(!(g==f));
});
QUnit.test("CTAT.Math.Fraction.Sum", function(assert) {
	var r = new CTAT.Math.Fraction(1,1);
	var s = CTAT.Math.Fraction.Sum(0.5,'1/3',new CTAT.Math.Fraction(1,6));
	assert.ok(r.deepEquals(s.reduced()));
});
QUnit.test("CTAT.Math.Fraction.Product", function(assert) {
	var r = new CTAT.Math.Fraction(1,36);
	var s = CTAT.Math.Fraction.Product(0.5,'1/3',new CTAT.Math.Fraction(1,6));
	assert.ok(r.deepEquals(s));
});