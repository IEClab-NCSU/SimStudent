/* This object represents an CTATExampleTracerTracer */

goog.provide('CTATExampleTracerTracer');
goog.require('CTATBase');
goog.require('CTATMsgType');
goog.require('CTATSAI');
goog.require('CTATExactMatcher');
goog.require('CTATExpressionMatcher');
goog.require('CTATMatcher');
goog.require('CTATVectorMatcher');
goog.require('CTATExampleTracerLink');
goog.require('CTATExampleTracerLinkComparator');
goog.require('CTATExampleTracerEvent');
goog.require('CTATExampleTracerInterpretation');
goog.require('CTATExampleTracerInterpretationComparator');
goog.require('CTATExampleTracerPath');
goog.require('CTATFormulaParser');

//goog.require('CTATVariableTable');//


/* LastModify: FranceskaXhakaj 07/14*/

/**************************** GLOBAL VARIABLES ******************************************************/

/**
 * @global
 */
var CTATExampleTracerTracer_count = 0;

/**
 * Top-level algorithms for the example tracer.
 * @constructor
 * @param {CTATExampleTracerGraph} givenGraph
 * @param {CTATVariableTable} givenVT
 */
CTATExampleTracerTracer = function(givenGraph, givenVT)
{
    CTATBase.call(this, "CTATExampleTracerTracer", givenGraph);

/**************************** PUBLIC INSTACE VARIABLES ******************************************************/

/**************************** PRIVATE INSTACE VARIABLES ******************************************************/

    /**
     * @type {CTATVariableTable}
     */
	var startStateVT = givenVT;

	/**
     * @type {array of CTATExampleTracerInterpretation}
     */
	var interpretations = null;

	/**
     * @type {Map<Integer, CTATExampleTracerLink>}
     */
	var incorrectActionMatches = null;

	/**
     * @type {array of CTATSAI}
     */
	var studentSAIs = null;

	/**
     * @type {CTATExampleTracerGraph}
     */
	var graph = givenGraph;

	/**
     * @type {CTATExampleTracerEvent}
     */
	var lastResult = null;

	/**
     * @type {boolean}
     */
	var isDemonstrateMode = false;

	/**
     * @type {integer}
     */
	var instance = CTATExampleTracerTracer_count++;

	/**
	 * Last known best interpretation.
     * @type {CTATExampleTracerInterpretation}
     */
	var bestInterpretation = null;

	//We do not have listeners anymore, we have decided to remove them from our implementation
	//var listeners = new Set(); //set of CTATExampleTracerEventListener

	/**
	 * Map telling what links were matched by selection and what the match() result was.
	 */
	var matchedSelections = {};

	/**
     * Make the object available to private methods
     */
	var that = this; // used to make the object available to the private methods

/***************************** PRIVATE METHODS *****************************************************/

	/**
	 * Replace <%= ... %> segments of a string with the formula results.
	 * @param {string} text the string to edit
     * @param {CTATVariableTable} vt the variable table for formula evaluation
     * @param {CTATSAI} sai to provide selection, action, input values for evaluation
	 * @return {string} edited string; null if text null
	 */
	var findFormula = new RegExp("(.*?)(<%=.*?%>)", "gm");  // not used, but tighter
	function interpolate(text, vt, sai)
	{
		if(!text)
			return text;

		var fp = new CTATFormulaParser(vt);
		that.ctatdebug("CTATETT.interpolate("+text+",vt,"+sai+")");
		var selection = sai.getSelection();
		var action = sai.getAction();
		var input = sai.getInput();
		var inputConv = CTATVariableTable.standardizeType(input);
		that.ctatdebug("CTATETT.interpolate() calling CTATFP.interpolate("+text+", "+selection+", "+action+", "+inputConv);
		var newText = fp.interpolate(text, selection, action, inputConv);
		that.ctatdebug("CTATETT.interpolate() returning "+newText);
		return newText;
	};

	/**
	 * Perform the state updates needed after {@link #evaluate(ExampleTracerEvent, boolean, boolean)}.
	 * @param result
	 * @param doUpdate
	 * @param type
	 * @param link the reportable link, used only if bestInterp is null
	 * @param bestInterp
	 * @param newInterps
	 * @return return value for evaluate()
	 */
	function finishEvaluate(result, doUpdate, type, link, bestInterp, newInterps)
	{
		that.ctatdebug("finishEvaluate() doUpdate "+doUpdate+", link "+link+", bestInterp.getLastMatchedLink() "+bestInterp.getLastMatchedLink());

		if(link == null)
		{
			link = bestInterp.getLastMatchedLink();
		}

		if(doUpdate || result.getWantReportableHints())
		{
			newInterps.forEach(function(interp)
			{
				var iterLink = interp.getLastMatchedLink();
				if(!iterLink)
				{
					return;
				}
				if(iterLink.getActionType() == CTATExampleTracerLink.CORRECT_ACTION)
				{
					if(result.getHintRequest())
					{
						if(result.getWantReportableHints())
						{
							interp.setLatestHints(link.interpolateHints(interp.getVariableTable()), iterLink.getHints());
						}
					}
					else
					{
						interp.setLatestSuccessMessage(interpolate(iterLink.getSuccessMsg(), interp.getVariableTable(), result.getStudentSAI()));
					}
				}
				else
				{
					interp.setLatestBuggyMessage(interpolate(iterLink.getBuggyMsg(), interp.getVariableTable(), result.getStudentSAI()));
				}
			});
		}

		if(doUpdate)
		{
			studentSAIs.push(result.getStudentSAI());  //FIXME? shouldn't append TPA SAIs

			if(link != bestInterp.getLastMatchedLink())
			{
				bestInterp.addLink(link);
				result.setResult(link.getActionType());
			}

			if(type.toString() === CTATExampleTracerLink.CORRECT_ACTION.toString() || type.toString() === CTATExampleTracerLink.FIREABLE_BUGGY_ACTION.toString())
			{
				that.ctatdebug("In evaluate -- in first branch doUpdate()");

				newInterps.forEach(function(iter)
				{
					if(iter.getLastMatchedLink().getType().toString() === CTATExampleTracerLink.BUGGY_ACTION.toString())
					{
						that.ctatdebug("In evaluate -- deleting an incorrect interp");
						newInterps.delete(iter);
					}
				});

				that.ctatdebug("In evaluate -- to call setInterpretations(), if 0 < newInterps.size "+newInterps.size);
				if(newInterps.size > 0)
				{
					setInterpretations(newInterps);
					bestInterpretation = bestInterp;
				}

				//the best way I know of to clear a map/object
				for (var i in incorrectActionMatches)
				{
					if(incorrectActionMatches.hasOwnProperty(i))
					{
						delete incorrectActionMatches[i];
					}
				}
				that.ctatdebug("In evaluate -- out of DoUpdate if branch");
			}
			else
			{
				that.ctatdebug("In evaluate -- in else branch of doUpdate");

				result.setNumberOfInterpretations(0);

				//the best way I know of to clear a map/object
				for (var j in incorrectActionMatches)
				{
					if(incorrectActionMatches.hasOwnProperty(j))
					{
						delete incorrectActionMatches[j];
					}
				}

				newInterps.forEach(function(interp)
				{
					incorrectActionMatches[interp.getLastMatchedLink().getUniqueID()] = interp.getLastMatchedLink();
				});
			}

			if(type.toString() === CTATExampleTracerLink.BUGGY_ACTION.toString())
			{
				//use this to remove an element from an array
				//removes the element, and resizes the array
				studentSAIs.splice(studentSAIs.length - 1, 1);
			}
		}

		if(!(result.isSolverResult()))
		{
			that.ctatdebug("In evaluate inside the NOT solver result if condition " + type);
			result.setResult(type);
		}

		that.ctatdebug("In evaluate out the solver result if condition");
		result.setReportableLink(link);
		result.setReportableInterpretation(bestInterp);
		result.setReportableVariableTable(bestInterp.getVariableTable());
		if(!result.getHintRequest())                    // hint traces will set tutorSAI separately
		{
			var tutorSai = link.getTutorSAI(result.getInterpolatedSAI(), bestInterp.getVariableTable());
			that.ctatdebug("In evaluate -- TUTORSAI: " + tutorSai + ", studentSAI was "+result.getStudentSAI());
			result.setTutorSAI(tutorSai);
		}
		var successOrBuggyMsg = (type == CTATExampleTracerLink.CORRECT_ACTION ? bestInterp.getLatestSuccessMessage() : bestInterp.getLatestBuggyMessage());
		that.ctatdebug("ETT.finishEvaluate() successOrBuggyMsg \""+successOrBuggyMsg+"\"");
		result.setSuccessOrBuggyMsg(successOrBuggyMsg);

		if(result.getHintRequest())
		{
			result.setReportableHints(bestInterp.getLatestHints());
			that.ctatdebug("In evaluate --> after setReportableHints");
		}

		//We will not have anymore listeners, this function is not needed
		//that.fireExampleTracerEvent(result);
		that.ctatdebug("In evaluate after fireExampleTracerEvent");

		that.ctatdebug("CTATExampleTracerTracer --> out of finishEvaluate");
		return (type.toString() !== CTATExampleTracerLink.BUGGY_ACTION.toString());
	};

	/**
	 * Decide whether to return CORRECT for a Done step. If feedback is suppressed, a Done step
	 * might be accepted as correct any time. However, when feedback is suppressed but the
	 * must student complete all required steps before exiting, this method checks
	 * {@link #matchedSelections} against paths to Done links to see whether any required steps
	 * are yet undone.
	 * @param {CTATExampleTracerEvent} result current trace request info
	 * @param {boolean} isHintTrace skip completion check if a hint request, to avoid cost on silent hint cycle
	 * @param {boolean} doUpdate argument for finishEvaluate()
	 * @param {Array<ExampleTracerInterpretation>} newInterps argument for finishEvaluate()
	 * @return non-null if calculated a return value for this call to
	 *         {@link #evaluate(ExampleTracerEvent, boolean, boolean)};
	 *         null if did not generate a return value
	 */
	function checkDoneStep(result, isHintTrace, doUpdate, newInterps)
	{
		that.ctatdebug("checkDoneStep() hintTrace "+isHintTrace+", sai "+result.getStudentSAI()+", exitOnIncorrectDone "+graph.exitOnIncorrectDone()+", hideButRequireSteps "+graph.hideButRequireSteps()+", nInterps "+newInterps.size);
		if(!result.getStudentSAI().isDone())
		{
			that.ctatdebug("checkDoneStep() not isDone(), so setDoneStepFailed(false) & return null ");
			return null;
		}
		if(graph.exitOnIncorrectDone())
		{
			that.ctatdebug("checkDoneStep() exitOnIncorrectDone() with setDoneStepFailed(false), so return CORRECT");
			return forceCorrectDone(result, doUpdate, null, newInterps);
		}
		if(!isHintTrace && graph.hideButRequireSteps())
		{
			var doneLinks = graph.getDoneLinks();
			that.ctatdebug("checkDoneStep getDoneLinks().size "+doneLinks.size);
			var iter = doneLinks.values(), doneLink;
			while(!((doneLink = iter.next()).done))
			{
				if(graph.pathToLinkIsSubset(doneLink.value, matchedSelections))
				{
				        return forceCorrectDone(result, doUpdate, doneLink.value, newInterps);
				}
			}
		}
		if(newInterps.size < 1)
		{
			result.setDoneStepFailed(true);
		}
		return null;
	}

	/**
	 * Call finishEvaluate() to declare the problem finished even when the Done step may be premature.
	 * Used when feedback is suppressed.
	 * @param {Object<CTATExampleTracerEvent>} result result bundle to update
	 * @param {boolean} argument to finishEvaluate()
	 * @param {Object<CTATExampleTracerLink>} doneLink a Done link on the current path, if any; can be null
	 * @param [<CTATExampleTracerInterpretation>] newInterps the new set of interpretations after the current match attempt
	 * @returns result from finishEvaluate(): the result argument
	 */
	function forceCorrectDone(result, doUpdate, doneLink, newInterps)
	{
		result.setDoneStepFailed(false);  // by fiat, done step did NOT fail
		if(newInterps.size < 1)
		{
			return finishEvaluate(result, doUpdate, CTATExampleTracerLink.CORRECT_ACTION, doneLink, that.getBestInterpretation(), that.getInterpretationsInternal());
		}
		else
		{
			return finishEvaluate(result, doUpdate, CTATExampleTracerLink.CORRECT_ACTION, doneLink, findBestInterpretation(newInterps), newInterps);
		}
	}

	/**
	 * Evaluates the given sai and updates the tracer with new interpretations
	 * If there are no link matches or only incorrect-action link matches, then
	 * the state of the tracer remains unchanged.
	 * @private
	 * @param {CTATExampleTracerEvent} result Instance to hold trace results
	 * @param {boolean} isHintTrace
	 * @param {boolean} doUpdate
	 * @return {boolean} True, if there are any correct/suboptimal action link matches
	 */
	function _evaluate (givenResult, isHintTrace, doUpdate)
	{
		that.ctatdebug("CTATExampleTracerTracer --> _evaluate("+givenResult+", "+isHintTrace+", "+doUpdate+")");
		lastResult = givenResult;

		var newInterps = new Set(); //Set of CTATExampleTracerInterpretation
		var saiLinkMatches = givenResult.getPreloadedLinkMatches(); //array of CTATExampleTracerLink objects ONLY

		that.ctatdebug("interps # : " + interpretations.length);
		that.ctatdebug("interps: " + interpretations);

		interpretations.forEach(function(interpretation) //the best way to iterate through an array
		{
			that.ctatdebug("In evaluate -- entered the interpretations loop");

			if(typeof(saiLinkMatches) === 'undefined' || saiLinkMatches === null)
			{
				that.ctatdebug("In evaluate -- entered if check for saiLinkMatches");
				saiLinkMatches = findSAIMatchingLinks(givenResult.getStudentSAI(), givenResult.getActor(), isHintTrace, interpretation.getVariableTable(), givenResult);
				that.ctatdebug("In evaluate -- exiting if check for saiLinkMatches");
			}
			else
			{
				for(var i = 0; i < saiLinkMatches.length; ++i)
				{
					updateMatchedSelections(givenResult.getStudentSAI(), true, saiLinkMatches[i],saiLinkMatches[i].getActor(), interpretation.getVariableTable());
				}
			}
			that.ctatdebug("Link matches # : " + saiLinkMatches.length);
			saiLinkMatches.forEach(function(link)
			{
				that.ctatdebug("In evaluate -- entered the saiLinkMatches loop + " + link);

				if(!graph.relaxOrderConstraints() && interpretation.getTraversalCount(link) >= link.getMaxTraversals())
				{
					that.ctatdebug("In evaluate -- skipped a saiLinkMatches loop \n Skipped due to max traversals" +link.getMaxTraversals() );
					return false; //instead of continue we do return
				}

				var newInterp = interpretation.clone(); //of type CTATExampleTracerInterpretation

				that.ctatdebug("In evaluate size of getPaths "+ newInterp.getPaths().size);

				newInterp.getPaths().forEach(function(path)
				{
					that.ctatdebug("In evaluate -- looping through the newInterp.getPaths()\n Examining path: " + path);

					if(isPathOK(link, newInterp, path, isDemonstrateMode, givenResult) === false)
					{
						that.ctatdebug("In evaluate -- in if condition, checking if isPathOK");

						newInterp.getPaths().delete(path); //might not be a great idea, it might have undefined behavior, make sure it is working correctly

						that.ctatdebug("In evaluate -- out of if condition, checking if isPathOK\n Tried to delete path.");
					}
				});

                that.ctatdebug("In evaluate -- done looping through the newInterp.getPaths(), size " + newInterp.getPaths().size);
				if(newInterp.getPaths().size > 0)
				{
					that.ctatdebug("In evaluate -- if number of paths is greater than 0");

					//not working with solverResult for now

					newInterp.addLink(link);

					that.ctatdebug("In evaluate -- new link added");

					if(doUpdate === true)
					{
						that.ctatdebug("In evaluate -- we are in the doUpdate if condition");
						var replacementInput = replaceInput(link, givenResult.getStudentSAI(), newInterp);

						that.ctatdebug("In evaluate -- updatingVariable table");
						givenResult.setInterpolatedSAI(newInterp.updateVariableTable(givenResult.getStudentSAI(), replacementInput, link));
						that.ctatdebug("In evaluate -- done updatingVariable table: "+newInterp.getVariableTable());
					}

					newInterps.add(newInterp); //adding to a set
					that.ctatdebug("In evaluate -- added new interp");
				}

				that.ctatdebug("In evaluate -- out of saiLinkMatches loop");
			});

		that.ctatdebug("In evaluate -- out of interpretation loops");

		});

		givenResult.setNumberOfInterpretations(newInterps.size);

		that.ctatdebug("In evaluate -- number of interpretations " + newInterps.size + " set");

		var doneResult = checkDoneStep(givenResult, isHintTrace, doUpdate, newInterps);
		if(doneResult !== null)
		{
			return doneResult;
		}

		if(newInterps.size === 0)
		{
			that.ctatdebug("In evaluate -- if condition no new interpretations");

			if(saiLinkMatches.length !== 0 && saiLinkMatches[0].isDone() === true)
			{
				givenResult.setDoneStepFailed(true);
			}

			givenResult.setResult(CTATExampleTracerLink.NO_MODEL);

			that.ctatdebug("In evaluate -- if condition no new interpretations returning false");

			return false;
		}

		var bestInterp = findBestInterpretation(newInterps);
		that.ctatdebug("In evaluate -- just found bestInterp");

		var type = null; //of type string

		if(givenResult.isSolverResult() === true)
		{
			that.ctatdebug("In evaluate -- in if branch of isSolverResult");
			type = (CTATExampleTracerLink.NO_MODEL.toString().toUpperCase() === givenResult.getResult().toString().toUpperCase() ? CTATExampleTracerLink.BUGGY_ACTION.toString() : givenResult.getResult().toString());
		}
		else
		{
			that.ctatdebug("In evaluate -- in else branch of isSolverResult");
			type = bestInterp.getLastMatchedLink().getType();
		}

		return finishEvaluate(givenResult, doUpdate, type, null, bestInterp, newInterps);
	};

	/**
	 * Insert or update the link in {@link #matchedSelections}, if the SAI matches for hint
	 * @param {CTATSAI} sai
	 * @param {boolean} matched whether the sai matched already
	 * @param {CTATExampleTracerLink} link
	 * @param {string} actor
	 * @param {CTATVariableTable} vt
	 */
	function updateMatchedSelections(sai, matched, link, actor, vt)
    {
		var newResult = (matched && link.isCorrect());
		if(typeof(matchedSelections[link.getUniqueID()]) != "undefined" || link.matchesSAIforHint(sai, actor, null, vt))
		{
			matchedSelections[link.getUniqueID()] = newResult;
		}
		that.ctatdebug("updateMatchedSelections(): link "+link.getUniqueID()+", matched "+matched+", newResult "+newResult+", matchedSelections[link] "+matchedSelections[link.getUniqueID()]);
	}

   /**
	* Find all the links with the given sai.
	* @private
	* @param {CTATSAI} sai Student sai
	* @param {string} actor which actor is performing
	* @param {boolean} hint Are we finding matching links for a hint trace?
	* @param {CTATVariableTable} vt Interp specific vt, if null refers to problemmodel(best interp)'s vt
	* @return {array of CTATExampleTracerLink} Links that match
	*/
	function findSAIMatchingLinks (sai, actor, hint, vt, givenResult)
	{
		that.ctatdebug("CTATExampleTracerTracer --> in findSAIMatchingLinks("+sai+", "+actor+", "+hint+")");

		var matchingLinks = []; //array of CTATExampleTracerLink ONLY!

		graph.getLinks().forEach(function(link)
		{
			if(hint === false)//hint will only be a boolean
			{
				//Note: this function call belongs to CTATExampleTracerEvent now

				that.ctatdebug("Calling link.matchesSAI() on link " + link + ", sai " + sai);
				var matched = link.matchesSAI(sai, actor, vt);
				that.ctatdebug("Result from link.matchesSAI() on link " + link + ": " + matched + ", typeof " + typeof(matched));

				if(matched === true) //function not done
				{
					matchingLinks.push(link);
				}
				if(graph.hideButRequireSteps())
				{
					updateMatchedSelections(sai, matched, link, actor, vt);
				}
			} //matchesSAI will take an extra parameter, the vt
			else if (link.matchesSAIforHint(sai, actor, givenResult, vt) === true)
			{
				matchingLinks.push(link);
			}
		});

		that.ctatdebug("CTATExampleTracerTracer --> out of findSAIMatchingLinks: #matchingLinks " + matchingLinks.length);

		return matchingLinks;
	}

	/**
	 * @private
	 * @param {CTATExampleTracerLink} newLink The link we're trying to extend the interpretation/path with
	 * @param {CTATExampleTracerInterpretation} interp
	 * @param {CTATExampleTracerPath} path
	 * @param {boolean} isDemonstrateMode If we're in demonstrate mode, ignore the path beyond
	 * the deepest traced link and recheck the interpretation fully
	 * @param {CTATExampleTracerEvent} result True if the newLink can be added, false otherwise
	 * @return {boolean}
	 */
	function isPathOK (newLink, interp, path, isDemonstrateMode, result)
	{
		that.ctatdebug("CTATExampleTracerTracer --> in isPathOK");

		var pathLinks = null; // object of type set of CTATExampleTracerLink

		if(isDemonstrateMode === true)
		{
			that.ctatdebug("CTATExampleTracerTracer --> in isPathOK in demonstrate mode");

			var allLinks = interp.getMatchedLinks().slice(); //array of CTATExampleTracerLink
			allLinks.push(newLink);
			pathLinks = path.getLinksRestricted(allLinks);
		}
		else
		{
			that.ctatdebug("CTATExampleTracerTracer --> in isPathOK NOT in demonstrate mode");
			pathLinks = path.getLinks();
		}

		that.ctatdebug("CTATExampleTracerTracer --> in isPathOK path.getLinks() " + path.getLinks().size);
		that.ctatdebug("CTATExampleTracerTracer --> in isPathOK pathLinks " + pathLinks.size);


		if(isDemonstrateMode === true)
		{
			var traversedLinks = []; //array of CTATExampleTracerLink
			var returnValue = true;

			interp.getMatchedLinks().forEach(function(link)
			{
				//mimic a break in a forEach iteration
				if(returnValue === false)
				{
					return;
				}

				if(graph.observesOrderingConstraints(traversedLinks, link, pathLinks, result) === false || doneStepOK(interp, link, pathLinks) === false)
				{
					that.ctatdebug("CTATExampleTracerTracer --> in isPathOK returning false1");
					returnValue = false;
					return;
				}

				traversedLinks.push(link);
			});

			//mimicking the return that should have happened within the loop above
			if(returnValue === false)
			{
				that.ctatdebug("CTATExampleTracerTracer --> in isPathOK returning false2");
				return false;
			}
		}

		if(newLink.getType().toString() ===  CTATExampleTracerLink.BUGGY_ACTION.toString())
		{
			if(graph.isIncorrectLinkOK(interp.getMatchedLinks(), newLink, pathLinks, interp) === false)
			{
				that.ctatdebug("CTATExampleTracerTracer --> in isPathOK returning false3");
				return false;
			}
		}
		else
		{
			if(graph.observesOrderingConstraints(interp.getMatchedLinks(), newLink, pathLinks, result) === false)
			{
				that.ctatdebug("CTATExampleTracerTracer --> in isPathOK returning false4");
				return false;
			}

			if(doneStepOK(interp, newLink, pathLinks) === false)
			{
				that.ctatdebug("CTATExampleTracerTracer --> in isPathOK returning false5");
				return false;
			}
		}

		that.ctatdebug("CTATExampleTracerTracer --> out of isPathOK returning true");

		return true;
	}

	/**
	 * @private
	 * If indicated by replaceInput(), calculate a new value for the student's
	 * input using evaluateReplacement(sai, CTATVariableTable)}.
	 * @param {CTATExampleTracerLink} link Has evaluateReplacement(sai, CTATVaraibleTable)
	 * @param {CTATSAI} sai Student's input data
	 * @param {CTATExampleTracerInterpretation} newInterp Supplied variable table to use
	 * @return {string} replacement value; null if no replacement indicated
	 */
	function replaceInput(link, sai, newInterp)
	{
		that.ctatdebug("CTATExampleTracerTracer.replaceInput("+link+", "+sai+", ...)");

		if(link === null || typeof(link) === 'undefined' || link.replaceInput() === false)
		{
			that.ctatdebug("replaceInput false, returning null");
			return null;
		}

		var replacementInput = link.evaluateReplacement(sai, newInterp.getVariableTable(), that);

		that.ctatdebug("CTATExampleTracerTracer.replaceInput() returning "+replacementInput);

		return replacementInput;
	}

	/**
	 * @private
	 * @param {Set of CTATExampleTracerInterpretations} iter
	 * @return {CTATExampleTracerInterpretation}
	 */
	function findBestInterpretation(iter)
	{
		that.ctatdebug("CTATExampleTracerTracer --> in findBestInterpretation");

		var comp = new CTATExampleTracerInterpretationComparator();
		var bestInterp = null; //instance of CTATExampleTracerInterpretation

		iter.forEach(function(interp)
		{
			that.ctatdebug("CTATExampleTracerTracer --> in findBestInterpretation iteration");

			if(bestInterp === null || typeof(bestInterp) === 'undefined')
			{
				that.ctatdebug("CTATExampleTracerTracer --> in findBestInterpretation first if condition");

				bestInterp = interp;
			}
			else
			{
				that.ctatdebug("CTATExampleTracerTracer --> in findBestInterpretation else of first if condition");

				var compResult = comp.compare(interp, bestInterp);

				if(compResult > 0)
				{
					that.ctatdebug("CTATExampleTracerTracer --> in findBestInterpretation second if condition");

					bestInterp = interp;
				}
			}
		});

		that.ctatdebug("CTATExampleTracerTracer --> out of findBestInterpretation");

		return bestInterp;
	}

	/**
	 * @private
	 * @param {Set of CTATExampleTracerInterpretation} c
	 * @return {undefined}
	 */
	function setInterpretations(c)
	{
		that.ctatdebug("CTATExampleTracerTracer --> in setInterpretations");

		interpretations.length = 0; //clear the elements in the array

		if(c.size === 0)
		{
			that.ctatdebug("CTATExampleTracerTracer --> returning from setInterpretations");

			return;
		}

		that.ctatdebug("CTATExampleTracerTracer --> setInterpretations c.size: " + c.size);

		//interpretations = interpretations.concat(c);
		c.forEach(function(el)
		{
			interpretations.push(el);
		});

		bestInterpretation = null;

		that.ctatdebug("CTATExampleTracerTracer --> out of setInterpretations");
	}

	/**
	 * @private
	 * @return {Set of CTATExampleTracerPath}
	 */
	function getAllPaths()
	{
		that.ctatdebug("CTATExampleTracerTracer --> in getAllPaths");

		var result = graph.findAllPaths();
        that.ctatdebug("CTATExampleTracerTracer --> in getAllPaths: #paths " + result.size);

        result.forEach(function(el)
		{
			that.ctatdebug("CTATExampleTracerTracer --> in getAllPaths loopring through paths");
			that.ctatdebug("CTATExampleTracerTracer --> in getAllPaths size of path" + el.getLinks().size);
		});

		return result;
	}

	/**
	 * Tell whether a step is valid with respect to achieving a problem-done state.
	 * Returns true if  the matched link is not a Done step or it's an incorrect action or
	 * there is one path in the extension with all links visited.
	 * @private
     * @param {CTATExampleTracerInterpretation} interp Check min traversal counts in this interpretation
     * @param {CTATExampleTracerLink} newLink Return false if link is a Done step and it's premature
     * @param {Set of CTATExampleTracerLink} path Check this path
     * @return {boolean}
	 */
	function doneStepOK(interp, newLink, path)
	{
		that.ctatdebug("CTATExampleTracerTracer --> in doneStepOK: link "+newLink+", isDone() "+newLink.isDone());

		if(newLink === null || typeof(newLink) === 'undefined' || newLink.isDone() === false)
		{
			that.ctatdebug("doneStepOK in first if condition");
			return true; //newLink is not a Done step
		}

		if(newLink.isDone() && graph.exitOnIncorrectDone())
		{
			return true;
		}

		if(newLink.getType().toString() === CTATExampleTracerLink.BUGGY_ACTION.toString())
		{
			that.ctatdebug("doneStepOK in second if condition");
			return true; //newLink is an incorrect action
		}

		//removed variable visitCount: never used

		that.ctatdebug("doneStepOK before loop");

		//there is no way we can break out of a forEach
		//this way at least we can return the right value
		var returnValue = true;

		path.forEach(function(link)
		{
			if(returnValue === false)
			{
				that.ctatdebug("CTATExampleTracerTracer --> we are breaking from the loop");
				return; //the only way we can mimic a break from a forEach
			}

			if(link.getUniqueID() === newLink.getUniqueID())
			{
				that.ctatdebug("CTATExampleTracerTracer --> inside second if condition");
				return; //similar to continue in Java
			}

			var traversalCount = interp.getTraversalCount(link); //of type integer

			if (graph.hideButRequireSteps() && (traversalCount > 0 || link.getMinTraversals() < 1))
			{
				return;  // ok if link optional or traversed at least once
			}

			//even though we should break the for loop once we go into this if
			//we have to keep going, there is no way we can break that
			if(traversalCount < link.getMinTraversals())
			{
				that.ctatdebug("CTATExampleTracerTracer --> we should return false from the second if condition");
				//return false;

				returnValue = false;
				return;
			}
		});

		if(returnValue === false)
		{
			that.ctatdebug("CTATExampleTracerTracer --> out of doneStepOK returning false");

			return false;
		}

		that.ctatdebug("CTATExampleTracerTracer --> out of doneStepOK returning true");

		return true; //there is np path in the extension with all links visited
	}

	/**
	 * Find an unvisited link that would be a valid next step.
	 * @private
	 * @param {boolean} wantHint Require link to have hints
	 * @param {array of CTATExampleTracerInterpretation} rtnInterp If not null, supply (in element 0) or return the interpretation used
	 * @return {CTATExampleTracerLink} Highest unvisited link that would be a good next step
	 */
	function _getBestNextLink(wantHint, rtnInterp)
	{
		that.ctatdebug("CTATExampleTracerTracer --> in _getBestNextLink");

		var interp = (rtnInterp !== null && typeof(rtnInterp) !== 'undefined' && rtnInterp[0] !== null && typeof(rtnInterp[0]) !== 'undefined' ? rtnInterp[0] : null);

		if(interp === null || typeof(interp) === 'undefined')
		{
			that.ctatdebug("CTATExampleTracerTracer --> in _getBestNextLink first if condition");
			interp = that.getBestInterpretation();
		}

		if(rtnInterp !== null && typeof(rtnInterp) !== 'undefined')
		{
			rtnInterp[0] = interp;
		}

		that.ctatdebug("CTATExampleTracerTracer --> in _getBestNextLink interp.getPaths(): " + interp.getPaths().size);

		var path = CTATExampleTracerPath.getBestPath(interp.getPaths());

		that.ctatdebug("CTATExampleTracerTracer --> in _getBestNextLink path: " + path);

		var highestLink = getHighestUntraversedLink(interp, path, wantHint, false);

		that.ctatdebug("CTATExampleTracerTracer --> in _getBestNextLink highestLink: " + highestLink);

		if(highestLink !== null && typeof(highestLink) !== 'undefined')
		{
			that.ctatdebug("CTATExampleTracerTracer --> in _getBestNextLink returning highestLink");
			return highestLink;
		}

		var lastLink = null;

		//dbg = path;
		that.ctatdebug("CTATExampleTracerTracer --> in _getBestNextLink returning path.getLinks() " + path.getLinks().size);
		that.ctatdebug("CTATExampleTracerTracer --> in _getBestNextLink returning path.getSortedLinks() " + path.getSortedLinks());


		var breakVal = false;
		var val = null;

		//ITERATE OVER LINKS OR SORTEDLINKS?
		path.getSortedLinks().forEach(function(link)
		{
			if(breakVal === true)
			{
				return;
			}

			that.ctatdebug("CTATExampleTracerTracer --> in _getBestNextLink in for loop" + link);
			lastLink = link;

			if((interp.getTraversalCount(link) < link.getMaxTraversals()) && (wantHint === false || that.nonEmptyHints(link, interp.getVariableTable()) > 0) && graph.observesOrderingConstraints(interp.getMatchedLinks(), link, path.getLinks(), null) && doneStepOK(interp, link, path.getLinks()))
			{
				that.ctatdebug("CTATExampleTracerTracer --> in _getBestNextLink in link: " + link);
				val = link;

				breakVal = true;
				return;
				//return link;
			}
		});

		if(breakVal === true)
		{
			return val;
		}

		//no last node here

		that.ctatdebug("CTATExampleTracerTracer --> out of _getBestNextLink, returning: " + lastLink);

		return null;
	};

	/**
	 * Find the first (moving from the start state) unvisited link in an interpretation, such
	 * that it would be a preferred next step.
	 * @private
	 * @param {CTATExampleTracerInterpretation} interp Interpretation with set of visited links
	 * @param {CTATExampleTracerPath} path Preferred path within the interp
	 * @param {boolean} wantHint Require link to have hints
	 * @param {boolean} countOptionalAsTraversed argument for
	 * CTATExampleTracerInterpretation.isTraversed(CTATExampleTracerLink, boolean)}
	 * @return {CTATExampleTracerLink} or null if no link qualifies
	 */
	function getHighestUntraversedLink(interp, path, wantHint, countOptionalAsTraversed)
	{
		that.ctatdebug("CTATExampleTracerTracer --> in getHighestUntraversedLink");

		var result = new CTATExampleTracerEvent(that, null, CTATMsgType.DEFAULT_STUDENT_ACTOR);

		var lastLinkVisited = true;

		var suggestedLinks = []; //array of CTATExampleTracerLink

		//is this sorted or normal links?
		path.getSortedLinks().forEach(function(link)
		{
			that.ctatdebug("CTATExampleTracerTracer --> in getHighestUntraversedLink in loop link.getUniqueID(): " + link.getUniqueID());
			that.ctatdebug("CTATExampleTracerTracer --> in getHighestUntraversedLink in loop interp.isTraversed(link, countOptionalAsTraversed): " + interp.isTraversed(link, countOptionalAsTraversed));
			that.ctatdebug("CTATExampleTracerTracer --> in getHighestUntraversedLink in loop isNoOp(link): " + isNoOp(link));

			if(interp.isTraversed(link, countOptionalAsTraversed) === true || isNoOp(link) === true)
			{
				that.ctatdebug("CTATExampleTracerTracer --> in getHighestUntraversedLink in if condition");

				lastLinkVisited = true;
				return;
			}

			if(lastLinkVisited === true)
			{
				that.ctatdebug("CTATExampleTracerTracer --> in getHighestUntraversedLink in second if condition");

				var pNode = graph.getNode(link.getPrevNode());
				var outLinks = pNode.getOutLinks();

				outLinks.forEach(function(outLink)
				{
					if(wantHint && that.nonEmptyHints(outLink, interp.getVariableTable()) < 1)
					{
						return;
					}

					if(interp.getTraversalCount(outLink) >= outLink.getMaxTraversals())
					{
						return;
					}

					that.ctatdebug("CTATExampleTracerTracer --> in getHighestUntraversedLink pushing outlink: " + outLink.getUniqueID());
					suggestedLinks.push(outLink);
				});
			}

			lastLinkVisited = (link === null || typeof(link) === 'undefined' ? false : (link.getMinTraversals() <= interp.getTraversalCount(link)));
		});


		//sorting suggestedLinks using the compare function from CTATExampleTracerLinkComaprator
		suggestedLinks.sort(function(a,b)
		{
			return (new CTATExampleTracerLinkComparator(interp, that)).compare(a, b);
		});

		that.ctatdebug("CTATExampleTracerTracer --> in getHighestUntraversedLink before sorting");

		var retVal = false;
		var val = null;

		suggestedLinks.forEach(function(suggestedLink)
		{
			if(retVal === true)
			{
				return;
			}

			that.ctatdebug("CTATExampleTracerTracer --> in getHighestUntraversedLink after sorting in fro loop");

			if(isPathOK(suggestedLink, interp, path, isDemonstrateMode, result) === true)
			{
				that.ctatdebug("CTATExampleTracerTracer --> in getHighestUntraversedLink after sorting first if");
				val = suggestedLink;
				retVal = true;
				return;
				//return suggestedLink;
			}

			interp.getPaths().forEach(function(otherPath)
			{

				if(retVal === true)
				{
					return;
				}

				that.ctatdebug("CTATExampleTracerTracer --> in getHighestUntraversedLink after sorting in inner loop");

				if(path !== otherPath)
				{
					that.ctatdebug("CTATExampleTracerTracer --> in getHighestUntraversedLink after sorting second if");

					if(isPathOK(suggestedLink, interp, otherPath, isDemonstrateMode, result) === true)
					{
						that.ctatdebug("CTATExampleTracerTracer --> in getHighestUntraversedLink after sorting third if");
						val = suggestedLink;
						retVal = true;
						return;
						//return suggestedLink;
					}
				}
			});
		});

		if(retVal === true)
		{
			that.ctatdebug("CTATExampleTracerTracer --> in getHighestUntraversedLink returning: " + val.getUniqueID());
			return val;
		}

		that.ctatdebug("CTATExampleTracerTracer --> out of getHighestUntraversedLink");

		return null;
	};

	/**
	 * Tell whether the given link is a no-op for example tracing. A no-op link
	 * is automatically considered traversed in a path, but generates no transaction or log.
	 * @private
	 * @param {CTATExampleTracerLink} link
	 * @return {boolean} True if minTraversals and maxTraversals are both zero
	 */
	function isNoOp(link)
	{
		// that.ctatdebug("CTATExampleTracerTracer --> in isNoOp");

		if(link === null || typeof(link) === 'undefined')
		{
			// that.ctatdebug("CTATExampleTracerTracer --> in isNoOp first if branch");
			return false;
		}
		else
		{
			// that.ctatdebug("CTATExampleTracerTracer --> in isNoOp second if branch");
			return ((link.getMinTraversals() < 1) && (link.getMaxTraversals() < 1));
		}
	}

/***************************** PRIVILEDGED METHODS *****************************************************/

	/**
	 * Traverse a given interpretation to a done state.
	 * @param {Object<CTATExampleTracerGraph>} graph
	 * @param {Object<CTATExampleTracer>} tracer top-level tracer
	 * @return {boolean} true if no error
	 */
	this.goToDone = function(interp, graph, tracer)
	{
		var path = interp.getPathToDone(graph);
		if(!path)
		{
			return false;
		}
		return tracer.traceLinks(path.getSortedLinks());
	};

	/**
	 * For debugging.
	 */
	this.getMatchedSelections = function()
	{
		return matchedSelections;
	};

	/**
	 * Return the results of the last trace.
	 * @return {CTATExampleTracerEvent} Null if no trace
	 */
	this.getLastResult = function ()
	{
		that.ctatdebug("CTATExampleTracerTracer --> in getResult");
		return lastResult;
	};

	//NOTE: We decided to remove listeners totally, therefore this function is not needed anymore
	//The listeners container will be removed too
	/*
	 * @param e of type CTATExampleTracerEvent
	 * @return undefined
	 */
	/*this.fireExampleTracerEvent = function (e)
	{
		that.ctatdebug("CTATExampleTracerTracer --> in fireExampleTracerEvent");

		listeners.forEach(function(listener)
		{
			listener.ExampleTracerEventOccurred(e);
		});

		that.ctatdebug("CTATExampleTracerTracer --> out of fireExampleTracerEvent");
	};*/

	/**
	 * @return {undefined}
	 */
	this.resetTracer = function ()
	{
		that.ctatdebug("CTATExampleTracerTracer --> in resetTracer entering");

		if(interpretations === null || typeof(interpretations) === 'undefined')
		{
			that.ctatdebug("CTATExampleTracerTracer --> in resetTracer making interpretations array");
			interpretations = []; // array of CTATExampleTracerInterpretation
		}
		else
		{
			that.ctatdebug("CTATExampleTracerTracer --> in resetTracer clearing interpretations array");
			interpretations.length = 0; //clearing array
		}

		var tempInterp = new CTATExampleTracerInterpretation(getAllPaths());
		that.ctatdebug("CTATExampleTracerTracer tempInterp--> in resetTracer tempInterp " + tempInterp);

		if(startStateVT !== null && typeof(startStateVT) !== 'undefined')
		{
			that.ctatdebug("CTATExampleTracerTracer --> in resetTracer startStateVT if condition");
			tempInterp.setVariableTable(startStateVT);
		}

		interpretations.push(tempInterp);
		bestInterpretation = tempInterp;

		if(incorrectActionMatches === null || typeof(incorrectActionMatches) === 'undefined')
		{
			that.ctatdebug("CTATExampleTracerTracer --> in resetTracer incorrectActionMatches if condition");
			incorrectActionMatches = {}; //Map of integer - CTATExampleTracerLink
		}
		else
		{
			that.ctatdebug("CTATExampleTracerTracer --> in resetTracer else branch of incorrectActionMatches if condition");

			//clear map
			for (var property in incorrectActionMatches)
			{
				if(incorrectActionMatches.hasOwnProperty(property))
				{
					delete incorrectActionMatches[property];
				}

			}
		}

		matchedSelections = {};

		if(studentSAIs === null || typeof(studentSAIs) === 'undefined')
		{
			that.ctatdebug("CTATExampleTracerTracer --> in resetTracer last if condition");
			studentSAIs = []; //array of CTATSAI
		}
		else
		{
			that.ctatdebug("CTATExampleTracerTracer --> in resetTracer else branch of last if condition");
			studentSAIs.length = 0; //clear array
		}

		that.ctatdebug("CTATExampleTracerTracer --> in resetTracer before iterating over all the links in the graphs");

		graph.getLinks().forEach(function(link)
		{
			link.getMatcher().resetMatcher();//note changed name of last function
		});

		that.ctatdebug("CTATExampleTracerTracer --> out of resetTracer");
	};

	/**
	 * Trace an attempt against the graph.
	 * @param {integer} linkID  Preselected link, used for tutor-performed actions
	 * @param {CTATSAI} sai Student SAI
	 * @return {boolean} Result of the private _evaluate
	 */
	this.evaluate = function(givenResult)
	{
		that.ctatdebug("CTATExampleTracerTracer --> in public evaluate(), calling private _evaluate; given event " + givenResult);

		return _evaluate(givenResult, false, true);
	};

	/**
	 * Return the number of nonempty hints on an link.
	 * @param {CTATExampleTracerLink} link
	 * @param {CTATVariableTable} vt For evaluating formulas in hints
	 * @return {integer} Number of non-empty hints, evaluated dynamically
	 */
	this.nonEmptyHints = function(link, vt)
	{
		that.ctatdebug("CTATExampleTracerTracer --> in nonEmptyHints");

		if(link === null || typeof(link) === 'undefined')
		{
			return 0;
		}

		var hints = link.interpolateHints(vt);

		that.ctatdebug("CTATExampleTracerTracer --> in nonEmptyHints: link.interpolateHints() " + link.interpolateHints().length);

		if(hints === null || typeof(hints) === 'undefined' || hints.length < 1)
		{
			return 0;
		}

		var nHints = 0;
		for(var i = 0; i < hints.length; ++i)
		{
			if((String(hints[i])).trim().length > 0) nHints++;
		}

		that.ctatdebug("CTATExampleTracerTracer --> returning from nonEmptyHints " + nHints);
		return nHints;
	};

	/**
	 * @param {CTATExampleTracerEvent} givenResult
	 * @return {CTATExampleTracerLink}
	 */
	this.traceForHint = function(givenResult)
	{
		that.ctatdebug("CTATExampleTracerTracer --> in traceForHint");

		var evalRet = _evaluate(givenResult, true, false);

		that.ctatdebug("CTATExampleTracerTracer --> in traceForHint return from evaluate " + evalRet);
		that.ctatdebug("CTATExampleTracerTracer --> in traceForHint result from evaluate " + givenResult.getResult().toString());
		that.ctatdebug("CTATExampleTracerTracer --> in traceForHint link   from evaluate " + givenResult.getReportableLink());

		if(givenResult.getResult().toString() === CTATExampleTracerLink.CORRECT_ACTION.toString())
		{
			var hintLink = givenResult.getReportableLink();
			givenResult.setTutorSAI(new CTATSAI(givenResult.getStudentSAI().getSelection(), hintLink.getDefaultSAI().getAction(), hintLink.getDefaultSAI().getInput()));
			givenResult.setActor(CTATMsgType.DEFAULT_STUDENT_ACTOR);

			that.ctatdebug("CTATExampleTracerTracer --> traceForHint returning hintLink "+hintLink+", result "+givenResult);
			return hintLink; //of type CTATExampleTracerLink
		}
		that.ctatdebug("CTATExampleTracerTracer --> out of traceForHint, returning null");
		return null;
	};

	/**
	 * Attempt to find a link using the given sai or, if that fails,
	 * using getBestNextLink().
	 * This method resembles a hint request, but accepts the first selection
	 * element instead of pulling the previous focus from an ordinary hint
	 * request.
	 * @param {CTATExampleTracerEvent} givenResult With CTATExampleTracerEvent.getStudentSAI() set
	 * @return {CTATExampleTracerLink} CORRECT link that best matches selection, or result of
	 * getBestNextLink(); can return null
	 */
	this.matchForHint = function(givenResult)
	{
		that.ctatdebug("CTATExampleTracerTracer --> in matchForHint");

		var link = null;
		var studentSAI = givenResult.getStudentSAI();
		var selection = !studentSAI ? null : studentSAI.getSelectionArray(); //of type array

		if(selection && selection.length > 0)
		{
			that.ctatdebug("CTATExampleTracerTracer --> in matchForHint first if");

			link = that.traceForHint(givenResult); //of type CTATExampleTracerLink

			if(link && givenResult.getReportableHints().length > 0)
			{
				that.ctatdebug("CTATExampleTracerTracer --> matchForHint via traceForHint returning "+link+", result "+givenResult);
				return link;
			}
		}
		link = that.getBestNextLink(true, givenResult); // no selection => nothing to match;
		that.ctatdebug("CTATExampleTracerTracer --> matchForHint() traceForHint via getBestNextLink returning "+link);
		return link;
	};

	/**
	 * Attempt to find a link using the given sai or, if that fails,
	 * using getBestNextLink().
	 * This method resembles a hint request, but accepts the first selection
	 * element instead of pulling the previous focus from an ordinary hint
	 * request.
	 * @param {boolean} wantHint If true, return null if the link chosen has no hints
	 * @param {CTATExampleTracerEvent} givenResult if not null, populate hints, result, tutorSAI, reportableLink
	 * @return {CTATExampleTracerLink} CORRECT link that best matches selection, or result of
	 *         getBestNextLink(); can return null
	 */
	this.getBestNextLink = function(wantHint, givenResult)
	{
		that.ctatdebug("CTATExampleTracerTracer --> in getBestNextLink");

		var interp = [];

		var etLink = _getBestNextLink(wantHint, interp);

		if(etLink === null || typeof(etLink) === 'undefined')
		{
			that.ctatdebug("CTATExampleTracerTracer --> in getBestNextLink returning null");
			//there is no next step
			return null;
		}

		if(etLink.getType().toString() === CTATExampleTracerLink.BUGGY_ACTION.toString())
		{
			that.ctatdebug("CTATExampleTracerTracer --> in getBestNextLink return null no correct suboptimal step");
			// means there's no correct or suboptimal next step
			return null;
		}
		else
		{
			that.ctatdebug("CTATExampleTracerTracer --> in getBestNextLink else branch");

			//not doing solverMatcher for now

			that.ctatdebug("CTATExampleTracerTracer --> in getBestNextLink got interp " + (interp == null ? "null" : interp[0]));

			if(givenResult)
			{
				var interpolatedHints = etLink.interpolateHints(interp[0].getVariableTable());
				givenResult.setInterpolatedHints(interpolatedHints);

				that.ctatdebug("CTATExampleTracerTracer --> in getBestNextLink setInterpolatedHints");

				if(Array.isArray(interpolatedHints) && interpolatedHints.length > 0) {
					givenResult.setReportableHints(interpolatedHints);
				} else {
					givenResult.setReportableHints(etLink.getHints());
				}
				that.ctatdebug("In evaluate --> after setReportableHints");
				if(interp && interp[0])
				{
					interp[0].setLatestHints(interpolatedHints, etLink.getHints());
				}

				givenResult.setReportableLink(etLink);
				givenResult.setReportableInterpretation(interp[0]);
				givenResult.setResult(etLink.getType());

				givenResult.setTutorSAI(etLink.getDefaultSAI());
			}
			that.ctatdebug("CTATExampleTracerTracer --> in getBestNextLink return etLink");

			return etLink;
		}
	};

	/**
	 * Top-level method to process a hint request.
	 * @param {array} givenSelection
	 * @param {array} givenAction
	 * @param {array} givenInput
	 * @param {string} givenActor
	 * @param {array of CTATExampleTracerEvent} rtnResult If not null, put result here
	 * @param {boolean} allowHintBias
	 * @return {CTATExampleTracerLink}
	 */
	this.doHint = function(result, respArray/*givenSelection, givenAction, givenActor, rtnResult, allowHintBias*/)
	{
/*
		--- Moved to CTATExampleTracer.doHint ---
		
		var previousFocus = null; //of type array
		var previousAction = null; //of type array
		
		if(allowHintBias && (givenAction !== null) && (typeof(givenAction) !== 'undefined') && (givenAction.length > 1) && (givenAction[1].toString() === CTATMsgType.PREVIOUS_FOCUS.toString()) && (givenSelection !== null) && (typeof(givenSelection) !== 'undefined') && (givenSelection.length > 1) && (givenSelection[1] !== null) && (typeof(givenSelection[1]) !== 'undefined') && (givenSelection[1].toString() !== "null".toString()))
		{
			that.ctatdebug("CTATExampleTracerTracer --> in doHint first if condition");
			previousFocus = []; //array
			previousFocus.push(givenSelection[1]);

			if(givenAction.length > 2)
			{
				that.ctatdebug("CTATExampleTracerTracer --> in doHint inner if condition");

				previousAction = []; //of type array

				for(var i = 2; i < givenAction.length; i++)
				{
					that.ctatdebug("CTATExampleTracerTracer --> in doHint for loop " + i);
					previousAction.push(givenAction[i]);
				}
			}
		}
		that.ctatdebug("CTATExampleTracerTracer --> in doHint out of if condition");
		
		var result = new CTATExampleTracerEvent(that, new CTATSAI(previousFocus, previousAction, null), givenActor);
		result.setHintRequest(true);
		
		that.ctatdebug("CTATExampleTracerTracer --> in doHint result: " + result);
*/
		that.ctatdebug("CTATExampleTracerTracer --> in doHint");

		var link = that.matchForHint(result);

		if(Array.isArray(respArray))
		{
			that.ctatdebug("CTATExampleTracerTracer --> in doHint last if condition");
			respArray.push(result);
		}

		that.ctatdebug("CTATExampleTracerTracer --> returning from doHint: " + link);

		return link;
	};

	/**
	 * @return {CTATExampleTracerInterpretation}
	 */
	this.getBestInterpretation = function()
	{
		that.ctatdebug("CTATExampleTracerTracer --> in getBestInterpretation");

		if(bestInterpretation === null || typeof(bestInterpretation) === 'undefined')
		{
			that.ctatdebug("CTATExampleTracerTracer --> in getBestInterpretation in if condition");
			bestInterpretation = findBestInterpretation(that.getInterpretationsInternal());
		}

		that.ctatdebug("CTATExampleTracerTracer --> out of getBestInterpretation " + (bestInterpretation === null || bestInterpretation === undefined));

		return bestInterpretation;
	};

	/**
	 * Internal accessor
	 * @return {array of CTATExampleTracerInterpretation} Returns the current interpretations in the tracer
	 */
	this.getInterpretationsInternal = function()
	{
		that.ctatdebug("CTATExampleTracerTracer --> in getInterpretationsInternal");

		return interpretations;
	};

	/**
	 * @return {string}
	 */
	this.toString = function()
	{
		var s = "TracerState\n";

        if(interpretations === null)
        {
            s += "(no interpretations)\n";
        }
        else
        {
			interpretations.forEach(function(interp)
			{
				s += interp.toString() + "\n";
			});
        }
		return s;
	};

    /**
     * For each of the given event's tutor SAI selection and input elements, bind a variable in the
     * CTATVariableTable whose name is the selection and value is the input.
     * @param {CTATExampleTracerEvent} evt
     */
	this.addInterfaceVariablesFromEvent = function(evt)
	{
		if(!evt)
		{
			return;
		}
		var sv = evt.getTutorSelection();
		var iv = evt.getTutorInput();
		that.addInterfaceVariables(sv, iv);
	};

    /**
     * For each of the given event's tutor SAI selection and input elements, bind a variable in the
     * CTATVariableTable whose name is the selection and value is the input.
     * @param {array} sv selection list
     * @param {array} iv input list
     */
	this.addInterfaceVariables = function(sv, iv)
	{
		that.ctatdebug("CTATExampleTracerTracer.addInterfaceVariables("+sv+", "+iv+")");
		if(!sv || !iv)
		{
			return;
		}

		var nVars = sv.length;
		if(nVars > iv.length)        // nVars = min(sv.length, iv.length)
		{
			nVars = iv.length;
		}
		for(var i = 0; i < nVars; i++)
		{
			if(sv[i])
			{
		  		startStateVT.put(sv[i], CTATVariableTable.standardizeType(iv[i]));
		  		startStateVT.put(CTATVariableTable.nameAsString(sv[i]), CTATVariableTable.valueAsString(iv[i]));
			}
		}
		that.ctatdebug("CTATExampleTracerTracer.addInterfaceVariables() startStateVT "+startStateVT);

  		if(!interpretations)
  		{
  			return;
  		}
  		interpretations.forEach(function(interp)
  		{
  			var vt = interp.getVariableTable();
  			if(!vt)
  			{
  				return; //instead of continue
  			}
			for(var j = 0; j < nVars; j++)
			{
				if(sv[j])
				{
					vt.put(sv[j], CTATVariableTable.standardizeType(iv[j]));
		  			vt.put(CTATVariableTable.nameAsString(sv[j]), CTATVariableTable.valueAsString(iv[j]));
				}
			}
			that.ctatdebug("CTATExampleTracerTracer.addInterfaceVariables() interp.vt "+vt);
  		});
	};

	/**
	  * @return {CTATExampleTracerNode}
	  */
	this.findCurrentState = function()
	{
		that.ctatdebug("Entering findCurrentState");

		var reportableInterpretation = that.getBestInterpretation(); //of type CTATExampleTracerInterpretation
		if(reportableInterpretation && reportableInterpretation.getLastMatchedLink() && reportableInterpretation.getLastMatchedLink().isDone())
		{
			return reportableInterpretation.getLastMatchedLink().getNextNode();  // return Done state if done
		}

		var rtnInterp = [ reportableInterpretation ];
		var bestNextLink = _getBestNextLink(false, rtnInterp );
		if(bestNextLink)
		{
			return bestNextLink.getPrevNode();
		}
		else
		{
			return (graph ? graph.getStartNode() : null);
		}
	};

/****************************** PUBLIC METHODS ****************************************************/

/*************************** PART OF CONSTRUCTOR ************************************/

	//Used to be part of the constructor being called from here
	//We had a problem with the startStateNode so we decided to remove this from here
	//and call it outside whenever we are creating the graph from the brd.
	//this.resetTracer();
};

/**************************** SETTING UP INHERITANCE ******************************************************/

CTATExampleTracerTracer.prototype = Object.create(CTATBase.prototype);
CTATExampleTracerTracer.prototype.constructor = CTATExampleTracerTracer;

if(typeof module !== 'undefined')
{
	module.exports = CTATExampleTracerTracer;
}
