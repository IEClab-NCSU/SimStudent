# Formula expression parser (using JS)

goog.provide('CTATFormulaParser')
goog.require('CTATVariableTable')
goog.require('CTATAlgebraParser')
goog.require('CTATFormulaFunctions')
goog.require('CTATFormulaActions')

stringPattern = /"(?:[^\\"]|\\\")*"|'(?:[^\\'']|\\\')*'/
identifierPattern = /[A-Za-z_][\w._]*(?![\w(._])/g
keywords = [
  'abstract', 'await', 'boolean', 'break', 'byte', 'case', 'catch', 'char', 'class', 'const',
  'continue', 'debugger', 'default', 'delete', 'do', 'double', 'else', 'enum', 'export',
  'extends', 'false', 'final', 'finally', 'float', 'for', 'function', 'goto', 'if', 'implements',
  'import', 'in', 'instanceof', 'int', 'interface', 'let', 'long', 'native', 'new', 'null', 'of',
  'package', 'private', 'protected', 'public', 'return', 'short', 'static', 'super', 'switch', 'synchronized',
  'this', 'throw', 'throws', 'transient', 'true', 'try', 'typeof', 'var', 'void', 'volatile', 'while',
  'with', 'yield', 'Array', 'Date', 'eval', 'function', 'global', 'hasOwnProperty', 'Infinity', 'isFinite',
  'isNaN', 'isPrototypeOf', 'length', 'Math', 'NaN', 'name', 'Number', 'Object', 'prototype', 'String',
  'toString', 'undefined', 'valueOf', 'window']

class CTATFormulaParser
  constructor: (@variableTable) ->
    @algebraParser = new CTATAlgebraParser()
    @keys = []; @values = []
    (@keys.push key; @values.push Number[key]) for key in [
      'EPSILON', 'MAX_VALUE', 'MIN_VALUE', 'POSITIVE_INFINITY', 'NEGATIVE_INFINITY',
      'isFinite', 'isInteger', 'isNaN', 'parseFloat', 'parseInt']
    (@keys.push key; @values.push ((fun) -> (number, args...) -> fun.apply number, args)\
      (Number::[key])) for key in [
        'toExponential', 'toFixed', 'toLocaleString', 'toPrecision', 'toString', 'valueOf']
    (@keys.push key; @values.push Math[key]) for key in [
      'E', 'LN10', 'LN2', 'LOG10E', 'LOG2E', 'PI', 'SQRT1_2', 'SQRT2',
      'abs', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atanh', 'atan2', 'cbrt', 'ceil', 'clz32',
      'cos', 'cosh', 'exp', 'expm1', 'floor', 'fround', 'hypot', 'imul', 'log', 'log10', 'log1p',
      'log2', 'max', 'min', 'pow', 'random', 'round', 'sign', 'sin', 'sinh', 'sqrt', 'tan', 'tanh',
      'trunc']
    (@keys.push key; @values.push String[key]) for key in ['fromCharCode', 'fromCodePoint']
    (@keys.push key; @values.push ((fun) -> (string, args...) -> fun.apply string, args)\
      (String::[key])) for key in [
        'charAt', 'charCodeAt', 'codePointAt', 'concat', 'contains', 'endsWith', 'indexOf',
        'lastIndexOf', 'localeCompare', 'match', 'repeat', 'replace', 'search', 'slice', 'split',
        'startsWith', 'substr', 'substring', 'toLocaleLowerCase', 'toLocaleUpperCase', 'toLowerCase',
        'toUpperCase', 'trim', 'valueOf']
    @keys.push 'length'; @values.push (string) -> string.length
    (@keys.push key; @values.push ((fun, parser) -> (args...) -> fun.apply parser, args)\
      (@algebraParser[key], @algebraParser)) for key in [
        'algParse', 'algEvaluate', 'algPartialSimplify', 'algSimplify', 'algValid', 'algValued',
        'algPartialSimplified', 'algSimplified', 'algIdentical', 'algEqual', 'algPartialEquivalent',
        'algEquivalent', 'isAlgValid', 'algEval', 'algStrictEquivTermsSameOrder', 'algEquivTermsSameOrder',
        'algStrictEquivTerms', 'algEquivTerms', 'algEquiv', 'isSimplified', 'calc', 'calca', 'simplify',
        'algebraicEqual', 'patternMatches', 'polyTermsEqual', 'algebraicMatches', 'expressionMatches']
    (@keys.push key; @values.push ((fun, klass) -> (args...) -> fun.apply klass, args)\
      (CTATFormulaFunctions[key], CTATFormulaFunctions)) for key, value of CTATFormulaFunctions
    (@keys.push key; @values.push ((fun, klass) -> (args...) -> fun.apply klass, args)\
      (CTATFormulaActions[key], CTATFormulaActions)) for key, value of CTATFormulaActions

  evaluate: (expression, selection, action, input) ->
    try
      object = window ? global; globals = (key for key of object).concat ['selection', 'action', 'input']
      for nonString in expression.split(stringPattern)
        (CTATFormulaFunctions.assign(key, undefined) for key in (match = nonString.match(identifierPattern) ? []) \
          when key not in keywords and key not in globals and key not in @keys)
      object[key] = table[key] for key of (table = @variableTable.getTable())
      (new Function('selection', 'action', 'input', @keys..., "return #{expression.trim()}")).
        apply object, [selection, action, input, @values...]
    catch error
      console.log(error); null
    finally
      (table[key] = object[key]; delete object[key]) for key of object when key? and key not in globals

  interpolateSplitPattern: /<%=|%>/
  interpolate: (message, selection, action, input) ->
    ((if index % 2 then @evaluate(item, selection, action, input) else item) \
      for item, index in message.split(@interpolateSplitPattern)).join('')
  # interpolate: (message, selection, action, input) ->
  #   message.split(@interpolateSplitPattern).map((item, index) => \
  #     if index % 2 then @evaluate(item, selection, action, input) else item).join('')

if module? then module.exports = CTATFormulaParser else @CTATFormulaParser = CTATFormulaParser
