# Parse tree node for power & square roots

goog.provide('CTATPowerNode')
goog.require('CTATTreeNode')

class CTATPowerNode extends CTATTreeNode
  constructor: (@operator, @base, @exponent, @parens = 0, @sign = 1, @exp = 1) ->
  clone: -> new CTATPowerNode @operator, @base.clone(), @exponent.clone(), @parens, @sign, @exp
  toString: ->
    @base.setParens @operator; @exponent.setParens @operator
    super "#{@base.toString()}#{CTATTreeNode.toOperatorString(@operator)}#{@exponent.toString()}"
  evaluate: -> super @base.evaluate() ** @exponent.evaluate()
  equals: (node) -> super(node) and @base.equals(node.base) and @exponent.equals node.exponent
  simplify: (@methods) ->
    @base = @base.simplify(@methods); @exponent = @exponent.simplify(@methods); super

  flatten: ->
    super; @operator = 'EXP'; @popNegation().popInversion()
    if @base.power()
      methods = CTATTreeNode.diff(@methods, ['flatten'])
      factors = unless @base.exponent.multiplication() then [@base.exponent]
      else @base.exponent.pushNegation().pushInversion().factors
      unless @exponent.multiplication() then factors.push @exponent
      else factors.push @exponent.pushNegation().pushInversion().factors...
      @base.exponent = new CTATMultiplicationNode('TIMES', factors).simplifyNode methods
      @pushBaseNegation().pushBaseInversion().base
    else @

  computeConstants: ->
    if @base.constant() and (@exponent.constant() or
        @exponent.multiplication() and @exponent.factors[0].constant())
      if @exponent.constant() then @base = new CTATConstantNode @evaluate(); @exponent = null
      else
        @base = new CTATConstantNode (new CTATPowerNode 'EXP', @base, @exponent.factors.shift()).evaluate()
        @exponent = @exponent.pushNegation().pushInversion().factors[0] if @exponent.factors.length is 1
      if @exponent then @ else @pushBaseNegation().pushBaseInversion().base
    else @

  powerOne: -> @exponent = @exponent.multiplyOne(); @pushInversion()

  expand: ->
    if @base.addition() and (@exponent.integer() and @exponent.value > 1 or
        @exponent.multiplication() and @exponent.factors[0].integer() and @exponent.factors[0].value > 1)
      if @exponent.integer() then exponent = @exponent; @exponent = null
      else
        exponent = @exponent.factors.shift()
        @exponent = @exponent.pushNegation().pushInversion().factors[0] if @exponent.factors.length is 1
      factors = [@base]
      factors.push @base.clone() for i in [1...exponent.evaluate()]
      @base = (new CTATMultiplicationNode('TIMES', factors)).simplifyNode ['distribute']
      if @exponent then @ else @pushBaseNegation().pushBaseInversion().base
    else @

  distribute: ->
    if @base.multiplication() or @exponent.addition()
      factors = if @base.multiplication() then @base.pushNegation().pushInversion().factors else [@base]
      pairs = unless @exponent.addition() then factors.map (factor) => [factor, @exponent.clone()]
      else factors.reduce ((result, factor) => result.push @exponent.terms.map((term) ->
        [factor.clone(), term.clone()])...; result), []
      @base = @packFactors pairs
      @pushBaseNegation().pushBaseInversion().base
    else @
  packFactors: (pairs) ->
    methods = CTATTreeNode.diff(@methods, ['flatten'])
    new CTATMultiplicationNode('TIMES', pairs.map ([base, exponent]) ->
      new CTATPowerNode('EXP', base, exponent).simplifyNode methods)

  removeIdentity: ->
    @popInversion()
    if @exponent.constant(0) then @base = new CTATConstantNode 1; @pushBaseNegation().base
    else if @base.constant(0) then @pushBaseInversion().base
    else if @exponent.constant(1) then @pushBaseNegation().pushBaseInversion().base
    else @exponent = @exponent.removeIdentity(); @

  compare: (node, reverse) ->
    super or (@countVariables() - node.countVariables()) * (if reverse then -1 else 1) or
    @exponent.compare(node.exponent, reverse) or @base.compare(node.base, reverse) or
    @compareSigns(node, reverse)
  countVariables: ->
    @base.countVariables() * if @exponent.constant() then Math.abs(@exponent.evaluate()) else Infinity

  pushBaseNegation: -> (@negate(); @base.negate()) if @negated(); @
  pushInversion: -> (@invert(); @exponent.negate()) if @inverted(); @
  pushBaseInversion: -> (@invert(); @base.invert()) if @inverted(); @
  popNegation: ->
    (@base.negate(); @negate() unless @exponent.even()) if @base.negated() and @exponent.constant(); @
  popInversion: ->
    (@invert(); @exponent.negate()) if @exponent.negated()
    (@invert(); @base.invert()) if @base.inverted()
    @
  even: -> not @inverted() and @base.even() and @exponent.integer()

if module? then module.exports = CTATPowerNode else @CTATPowerNode = CTATPowerNode
