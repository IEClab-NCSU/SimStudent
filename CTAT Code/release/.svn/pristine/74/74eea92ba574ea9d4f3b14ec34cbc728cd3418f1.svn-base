/**
 * @fileoverview Defines the CTATLMS object with a set of static methods that
 * are called by the tracer to communicate with the hosting LMS.  The initial
 * setup assumes no LMS and the initial functions are essentially no-ops.
 *
 * There are CTATLMS.is<LMS> functions for testing for various key features of
 * that LMS.
 *
 * There are CTATLMS.init<LMS> functions that replace the initial bindings with
 * LMS appropriate functions.
 *
 * Note: xBlock does not have any of these functions defined because in that LMS
 * having edx assign these integration functions which are more tightly coupled
 * with how the xBlock is defined as opposed to a generic framework is much
 * easier to test and maintain as ctat.min.js does not have to be updated if
 * there are any changes.
 */
goog.provide('CTATLMS');

//goog.require('CTATGlobals');
goog.require('CTATConfiguration'); // needed for TutorShop
goog.require('CTATTutorMessageBuilder');
goog.require('CTAT.ToolTutor'); // needed for TutorShop

/**
 * @namespace
 * @property {string} identifier - A specifier for the type of LMS
 * @property {function} initLMSConnection - The function called to initialize the connection with the LMS.
 * @property {function} closeLMSConnection - The function that closes the connection to the LMS.
 * @property {function} setValue - Sets the given variable to the given value in the LMS.
 * @property {function} getValue - Retrieves the value of the given variable from the LMS.
 * @property {function} saveProblemState - Send the representation of the current state to the LMS.
 * @property {function} getProblemState - Retrieve a state representation from the LMS.
 * @property {function} gradeStudent - Takes the number of successfully
 *       completed steps and the total number of steps and calculates and posts
 *       a score appropriate for the LMS.
 * @property {function} processProblemSummary - Posts summary information to the LMS.
 * @export
 */
CTATLMS = {};
/** @export */CTATLMS.identifier = null;
/** @export */CTATLMS.initLMSConnection = function () {};
/** @export */CTATLMS.closeLMSConnection = function () {};
/** @export */CTATLMS.setValue = function (key,value) {};
/** @export */CTATLMS.getValue = function (key) { return null; };
/** @export */CTATLMS.saveProblemState = function (data) {};
/** @export */CTATLMS.getProblemState = function (handler) { return handler(null); };
/** @export */CTATLMS.gradeStudent = function (correct_steps, required_steps) {};
/** @export */CTATLMS.logEvent = function (aMessage) {};
/** @export */CTATLMS.processProblemSummary = function (problem_summary_xml) {};
//};

/**
 * Store tests in an object to make them easy to extend and iterate over.
 */
/** @export */
CTATLMS.is = {};
/** @export */
CTATLMS.init = {};

/**
 * Resets the CTATLMS to the stand-alone bindings.
 */
CTATLMS.init.StandAlone = function () {
	CTATLMS.identifier = null;
	CTATLMS.initLMSConnection = function () {};
	CTATLMS.closeLMSConnection = function () {};
	CTATLMS.commit = function () {};
	CTATLMS.setValue = function () {};
	CTATLMS.getValue = function () { return null; };
	CTATLMS.logEvent = function (aMessage) {};	
	CTATLMS.saveProblemState = function () {};
	CTATLMS.getProblemState = function (handler) { return handler(null); };
	CTATLMS.gradeStudent = function () {};
	CTATLMS.processProblemSummary = function () {};
};

/**
 * Test if this is in a SCORM environment.
 * @returns {boolean}
 * @export
 */
CTATLMS.is.SCORM = function() {
	return window.location.search && /[?&;]mode=SCORM/i.test(window.location.search);
};
/**
 * Sets the CTATLMS functions to use the SCORM methods for communicating with
 * the LMS.

	 <message>
		<verb>NotePropertySet</verb>
		<properties>
			<MessageType>ProblemSummaryResponse</MessageType>
			<cmi.core.lesson_status>completed</cmi.core.lesson_status>
			<cmi.core.score.raw>100</cmi.core.score.raw>
			<cmi.core.exit>suspend</cmi.core.exit>
			<cmi.core.session_time>0000:11:27.71</cmi.core.session_time>
			<ProblemSummary>&lt;ProblemSummary ProblemName="none" CompletionStatus="complete" Correct="2" UniqueCorrect="2" UniqueCorrectUnassisted="2" Hints="0" UniqueHints="0" HintsOnly="0" Errors="0" UniqueErrors="0" ErrorsOnly="0" UniqueSteps="2" RequiredSteps="2" TimeElapsed="687715"&gt;&lt;Skills&gt;&lt;/Skills&gt;&lt;/ProblemSummary&gt;</ProblemSummary>
			<end_of_transaction>true</end_of_transaction>
		</properties>
	</message>

	Valid values for cmi.core.lesson_status:

		passed
		failed
		completed
		incomplete
		browsed
		not attempted

	http://www.vsscorm.net/2009/07/24/step-22-progress-and-completion-cmi-core-lesson_status/
 * @export
 */
CTATLMS.init.SCORM = function ()
{
	var sInit=false;

	CTATLMS.identifier = 'SCORM';
	CTATLMS.initLMSConnection = function ()
	{
		if (sInit===true)
		{
			//console.log ("SCORM already initialized, bump");
			return;
		}

		window.parent.doLMSInitialize ();

		var pRestoreStatus=CTATLMS.getValue('cmi.core.lesson_status');

		CTATConfiguration.set("problem_state_status",pRestoreStatus);

		//console.log ("Found a problem status of: " + pRestoreStatus);

		if (pRestoreStatus=="not attempted")
		{
			CTATConfiguration.set("problem_state_status","incomplete");
		}

		if (pRestoreStatus=="passed")
		{
			CTATConfiguration.set("problem_state_status","completed");
		}

		if (pRestoreStatus=="failed")
		{
			CTATConfiguration.set("problem_state_status","incomplete");
		}

		if (pRestoreStatus=="browsed")
		{
			CTATConfiguration.set("problem_state_status","incomplete");
		}

		CTATLMS.setValue('cmi.core.lesson_status','incomplete');

		/*
		//console.log ("Verify status set in LMS: " + CTATLMS.getValue('cmi.core.lesson_status'));

		//////////////////////////////////////////////////////////
		//         We're forcing problem restore for now        //
		//////////////////////////////////////////////////////////
		CTATConfiguration.set("problem_state_status","incomplete");
		*/

		sInit=true;
	};
	CTATLMS.commit = window.parent.doLMSCommit;
	CTATLMS.closeLMSConnection = window.parent.doLMSFinish;
	CTATLMS.setValue = window.parent.doLMSSetValue;
	CTATLMS.getValue = window.parent.doLMSGetValue; // use GetLastError method if empty to check for error
	CTATLMS.logEvent = function (aMessage) {};	
	CTATLMS.saveProblemState = function (data)
	{
		//console.log ("Saving problem state: " + data.problem_state);

		var pResult=CTATLMS.setValue('cmi.suspend_data',data.problem_state);

		//console.log ("Set value result: " + pResult);

		return (pResult);
	};
	CTATLMS.getProblemState = function (handler)
	{
		var pResult=CTATLMS.getValue('cmi.suspend_data');

		//console.log ("Problem restore value: " + pResult);

		return handler(pResult);
	};
	CTATLMS.gradeStudent = function (correct_steps, required_steps)
	{
		// SCORM apparently wants scores in [0,100]
		CTATLMS.setValue('cmi.core.score.min', 0);
		CTATLMS.setValue('cmi.core.score.max', 100);
		return CTATLMS.setValue('cmi.core.score.raw', Number((correct_steps/required_steps).toFixed(2).replace(/[.]/,"")));
	};
	CTATLMS.processProblemSummary = function (problemXML)
	{
		var cmi = ['cmi.core.lesson_status', 'cmi.core.score.raw', 'cmi.core.exit', 'cmi.core.session_time'];
		cmi.forEach(function (key)
		{
		    var value = this.getElementsByTagName(key);
		    // FIXME: should there be a check to see if value exists before setting?
			CTATLMS.setValue(key,$('<div>').html(value [0].innerHTML).text());
		}, problemXML);

		CTATLMS.commit();

		CTATLMS.closeLMSConnection ();
	};

	CTATLMS.initLMSConnection ();
};

// XBlock initialization is done in https://github.com/CMUCTAT/XBlockCTAT/blob/master/ctatxblock/public/js/CTATXConfig.js
// OLI initialization is done in svn://pact-cvs.pact.cs.cmu.edu/usr4/local/svnroot/Studies/OLI/superactivity/ctat2/tutor.js

/**
 * Test if this is in a XBlock/EdX environment.
 * @returns {boolean}
 * @export
 */
CTATLMS.is.XBlock = function() {
	return window.location.search && /[?&;]mode=XBlock/i.test(window.location.search);
};

CTATLMS.init.XBlock = function() {
	var porigin = document.referrer?(new URL(document.referrer)).origin:'';
	CTATLMS.identifier = 'XBlock';
	CTATLMS.initLMSConnection = function () {};
	CTATLMS.closeLMSConnection = function () {};
	CTATLMS.commit = function () {};
	CTATLMS.setValue = function (key, value) {};
	CTATLMS.getValue = function (key) { return null; };
	CTATLMS.saveProblemState = function (state) {
		parent.postMessage({'action': 'save_problem_state',
			'input': window.btoa(state.problem_state)}, porigin);
	};
	CTATLMS.getProblemState = function (handler) {
		return handler(window.atob(CTATConfiguration.get('saveandrestore')));
	};
	CTATLMS.gradeStudent = function (correct_steps, total_steps) 
	{
		parent.postMessage({'action': 'grade',
			'input': {'value': correct_steps, 'max': total_steps}}, porigin);
	};
	CTATLMS.logEvent = function (aMessage) 
	{
		parent.postMessage({'action': 'log', 'input': aMessage}, porigin);
	};
	CTATLMS.processProblemSummary = function (problemXML) {};
	// for skills: parent.postMessage({'action': 'skills',
	//    'input': encodeURIComponent(CTATSkillSet.skills.toSetPreferencesXMLString())});
};
/**
 * Test if this is in Authoring mode.
 * @return {boolean}
 * @export
 */
CTATLMS.is.Authoring = function() {
	return window.location.search && /[?&;]mode=AUTH(ORING)?/i.test(window.location.search);
};

/**
 * @return {boolean} true if iframe attribute "data-superactivityserver" is nonempty
 * @export
 */
CTATLMS.is.OLI = function() {
	return (CTATConfiguration.get("CTATTarget")=="OLI");
};

/**
 * Test if in TutorShop.
 * @return {boolean}
 * @export
 */
CTATLMS.is.TutorShop = function() {
	// TODO: Might need to test for single quotes, but this works so far with TutorShop.
	//return window.frameElement && /"LMS":\s*"TutorShop"/i.test(window.frameElement.getAttribute("data-params"));
	return CTATConfiguration.get("LMS") == "TutorShop";
};
/**
 * Set CTATLMS functions to use TutorShop methods.
 * @export
 */
CTATLMS.init.TutorShop = function () {
	CTATLMS.identifier = "TutorShop";
	CTATLMS.initLMSConnection = function () {};
	CTATLMS.closeLMSConnection = function () {};
	CTATLMS.commit = function () {};
	CTATLMS.setValue = function (key,value) {};
	CTATLMS.getValue = function (key) { return null; };
	CTATLMS.logEvent = function (aMessage) {};
	CTATLMS.saveProblemState = function (data) {
		if(CTATConfiguration.get("restoreProblemUrl") && CTATConfiguration.get("curriculum_service_url"))
		{
			data['session_id'] = data['session_id'] ? data['session_id'] : "dummySession";
			var postVars = [];
			for (var prop in data) {
				postVars.push(prop+'='+encodeURIComponent(data[prop]));
			}
			$.post(CTATConfiguration.get("curriculum_service_url"),
					postVars.join('&'), null, "application/x-www-form-urlencoded");
		}
	};
	CTATLMS.getProblemState = function (handler) {
		if (CTATConfiguration.get("restoreProblemUrl")) {
			$.get(CTATConfiguration.get("restoreProblemUrl"),"",null,"text")
			    .done(function (data) { handler(data); })
			    .fail(function (jqxhr, status, thrownError) {
			    	handler(null);
			    	var msg = new CTATTutorMessageBuilder().createErrorMessage("Load ProblemState Error", status+' '+thrownError);
			    	CTAT.ToolTutor.sendToInterface(msg, true);
				});
		} else { handler(null); }
	};
	CTATLMS.gradeStudent = function () {};
	CTATLMS.processProblemSummary = function () {};
};

CTATLMS.is.Assistments = function() {
	return CTATTarget && CTATTarget=="ASSISTMENTS";
};
