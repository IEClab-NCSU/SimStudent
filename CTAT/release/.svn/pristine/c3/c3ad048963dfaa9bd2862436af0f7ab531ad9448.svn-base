/**-----------------------------------------------------------------------------
 $Author$
 $Date$
 $HeadURL$
 $Revision$

 -
 License:
 -
 ChangeLog:
 -
 Notes:

 */
/*
 * This file represents the core javascript example tracer, with which the interface communicates.
 * NOTE: The tutor launchers must be run off a web server. Opening them directly in a browser off the filesystem
 * would cause AJAX requests to fail (due to browser security restrictions), and the tutor will not load.
 *
 */

goog.provide('CTATExampleTracer');

goog.require('CTATBase');
goog.require('CTATHintPolicyEnum');
goog.require('CTATSAI');
goog.require('CTATExampleTracerSkill');
goog.require('CTATGraphParser');
goog.require('CTATProblemStateStatus');
goog.require('CTATMessage');
goog.require('CTATMessageTank');
goog.require('CTATMsgType');
goog.require('CTATProblemSummary');
goog.require('CTATSkills');
goog.require('CTATTutoringServiceMessageBuilder');
goog.require('CTATTutorMessageBuilder');
goog.require('CTAT.ToolTutor');
goog.require('CTATXML');
goog.require('ProblemStateSaver');
goog.require('ProblemStateRestorer');
goog.require('CTATCommLibrary');
goog.require('CTATLanguageManager');
goog.require('SCORMProblemSummary');

CTATExampleTracer = function()
{
	CTATBase.call(this, "CTATExampleTracer", "tracer");

	//var failure=0/0;

    var xmlHeader = '<?xml version="1.0" encoding="UTF-8"?>';

    var that = this;
	var questionFile = null;
    var exampleTracer;
	var outOfOrderMessage;
    var graph;
    var parser = new CTATXML();
    var serializer = new XMLSerializer();
    var errorSAI = null;
    var groupModel;
    var hintPolicy;
    var highlightRightSelection = true;

    //Problem Model vars
    var feedbackSuppressed = false;
    var problemSummary = null; //of type CTATProblemSummary
    var problemName = null; //of type string
    var sourceID = null; //of type string

	var problemStateSaver = new ProblemStateSaver(that);
	problemStateSaver.setAuthenticityToken(CTATCommLibrary.getAuthenticityToken());

	var problemStateRestorer = null;

	var outputStatus = new CTATProblemStateStatus();
	var restoreQueue = [];
	var workQueue = [];
	var working = 0;  // 1-bit for main workQueue, 2-bit for restoreQueue
	var graphLoaded = false;

	var session_id="";

	/** Node identifier of destination node for go-to-state; -1 if none. */
	var goToStateTargetNodeID = -1;

    /**
     * Map of selections to delayed feedback messages: retain only the last feedback on each selection.
     */
    var delayedFeedback = null;

	that.ctatdebug("CTATExampleTracer constructor outputStatus="+outputStatus);

	// Properties for debugging. An instance of this class is the tutorObject in the global scope, so that
	// these properties should be visible as tutorObject.lastMessage [etc.] on the browser's JavaScript console.
	// Do not use these properties to govern behavior: they should be write-only in this file, read-only everywhere else.
	this.lastMessageAsString = null;     // last input message from student interface
	this.lastMessageAsXML = null;        // last message as XML element
	this.lastMessage = null;             // last message as CTATMessage instance
	this.lastResult = null;              // result of last trace as CTATExampleTracerEvent instance
	this.lastSilentHintResult = null;    // result of last silent hint trace as CTATExampleTracerEvent instance
	this.messageTank = null;			 // collects and post-processes responses for delivery to UI

	var tracerCommLibrary=new CTATCommLibrary ();

    /**
     * API to external system.
	 * @param {string} aMessage incoming message
     */
    this.receiveFromInterface = function(aMessage)
    {
        that.ctatdebug("CTATExampleTracer.receiveFromInterface() \n  " + aMessage);

		workQueue.push(aMessage);
		workTheQueue();
	};

	/**
	 * Set variables in the tracer's variable table from the SAI in a message.
	 * @param {Element} xml message or properties element from a CTAT message
	 * @param {CTATXML} parser
	 */
	this.setVariablesFromSAI = function(xml, parser)
	{
		var saiArrays = CTATMsgType.getSAIArraysFromElement(xml, parser);
		if(that.getTracer())
		{
			that.getTracer().addInterfaceVariables(saiArrays.selection, saiArrays.input);
		}
	};

	/**
	 * Trace a list of links: skip any for which we've already satisfied min traversals.
	 * @param {Array<CTATExampleTracerLink>} links list to follow
	 * @return {Array<CTATExampleTracerEvent>} results for each trace
	 */
	this.traceLinks = function(links)
	{
		var results = [];
		var interp = that.getTracer().getBestInterpretation();
        for(var i = 0; i < links.length && links[i] !== null; ++i)
        {
			if(interp.getTraversalCount(links[i]) < links[i].getMinTraversals())
			{
				that.messageTank = new CTATMessageTank(that, null);
				results.push(doNewExampleTrace(links[i], links[i].getDefaultSAI(), links[i].getActor(), false, null));
				that.ctatdebug("traceLinks["+i+"] result "+results[i]);
			}
        }
		return results;
	};

	/**
	 * Put the given messages on the restoreQueue and process them.
	 * @param {array<string>} restoreMsgTexts
	 */
	this.enqueueForRestore = function(restoreMsgTexts)
	{
		that.ctatdebug("enqueueForRestore: got "+restoreMsgTexts.length+" message elements");
		restoreQueue = restoreQueue.concat(restoreMsgTexts);
		var endMsg = (new CTATTutorMessageBuilder()).createMessage(CTATMsgType.PROBLEM_RESTORE_END, null);
		restoreQueue.push(endMsg);
		that.startWorking(1);
	};

	/**
 	 * Enable or reenable work by workTheQueue().
	 * Whenever we clear the flag, call workTheQueue() to resume processing.
	 * @param {integer} digit binary place of digit == shift distance
	 * @param {boolean} setOrClear true to set, false to clear
	 */
	this.startWorking = function(shift)
	{
		setWorking(shift, false);
	};

	/**
 	 * Stop the action of workTheQueue(), typically to wait for some event,
	 * as when we await restore messages before we can process student actions.
	 * @param {integer} digit binary place of digit == shift distance
	 */
	this.stopWorking = function(shift)
	{
		setWorking(shift, true);
	};

	/**
 	 * Control the working flag that governs access in workTheQueue().
	 * Whenever we clear the flag, call workTheQueue() to resume processing.
	 * @param {integer} digit binary place of digit == shift distance
	 * @param {boolean} setOrClear true to set, false to clear
	 */
	function setWorking(shift, setOrClear)
	{
		if(setOrClear)             // set
			working |= (1<<shift);
		else                       // clear
		{
			working &= ((~0x10000)>>(16-shift));
			workTheQueue();
		}
	}

	/**
	 * If feedback is suppressed, insert a start-state message to hide the Hint button.
	 * @param {Array<string>} startStateMessageStrings start-state messages so far; will append to end
	 */
	function maybeHideHintButton(startStateMessageStrings)
	{
		if(graph.getFeedbackPolicy() == CTATMsgType.SHOW_ALL_FEEDBACK)
		{
			return;   // no-op unless feedback is suppressed
		}
		var sai = new CTATSAI("hint", "SetVisible", "false");
		var msg = (new CTATTutoringServiceMessageBuilder()).createInterfaceActionMessage("dummyTransactionID", sai);
		startStateMessageStrings.push(msg);
	}

	/**
	 * @return {string} message of CTATMsgType.INTERFACE_REBOOT
	 */
	function createInterfaceReboot()
	{
		return "<message><verb>NotePropertySet</verb><properties><MessageType>"+CTATMsgType.INTERFACE_REBOOT+"</MessageType></properties></message>";
	}

	/**
	 * Process and send start state msgs.
	 * @param {Array:Element} startStateMsgs
	 * @param {string} stateGraphMsg initial message to tutor
	 * @param {CTATGraphParser} graphParser function that parsed the graph
	 * @return {string} StartStateEnd message
     */
    function sendStartStateMessages(startStateMsgs, stateGraphMsg, graphParser)
	{
		that.ctatdebug("sendStartStateMessages() nMsgs "+startStateMsgs.length+", outputStatus "+outputStatus);
		var startStateMessageStrings = [];
		var serializer = new XMLSerializer();
		var sseMsgStr = null;
		for(var m = 0 ; m < startStateMsgs.length; m++)
		{
			if (parser.getElementName(startStateMsgs[m]) == "message")
			{
				var msgString = serializer.serializeToString(startStateMsgs[m]);
				var msgType = CTATMsgType.getMessageType(msgString);
				if(CTATMsgType.UNTUTORED_ACTION == msgType || CTATMsgType.INTERFACE_ACTION == msgType)
				{
					that.setVariablesFromSAI(startStateMsgs[m], parser);
				}
				if(CTATMsgType.START_STATE_END == msgType)
				{
					maybeHideHintButton(startStateMessageStrings);  // appends msg if feedback suppressed
					sseMsgStr = msgString;          // tells where to protect given values via LockWidget
					startStateMessageStrings.push((new CTATTutoringServiceMessageBuilder()).createInterfaceConfigurationEnd());
					startStateMessageStrings.push((new CTATTutorMessageBuilder()).createLockWidgetMsg(graphParser.getLockWidget()));
					continue;                      // delay StartStateEnd until after TPAs, worked examples
				}
				startStateMessageStrings.push(msgString);
			}
		}
		startStateMessageStrings.unshift(stateGraphMsg);  // prefix to start of list
		startStateMessageStrings.unshift(createInterfaceReboot());

		that.ctatdebug("sendStartStateMessages(): "+startStateMsgs.length+" elts, "+startStateMessageStrings.length+" strings, "+outputStatus);
		that.sendBundle(startStateMessageStrings);
		return sseMsgStr;
	}

	/**
	 * Partially-worked examples: If the student-starts-here state in the graph is not the
	 * origin state, find a path to the student-starts-here state and follow it.
	 */
	function advanceToStudentStartsHere()
	{
		var results = [];
		var origin = graph.getStartNode();
		var studentStartsHere = resetGoToState(CTATMsgType.START_STATE_END, null, origin.getNodeID());
		if(!studentStartsHere)
		{
			studentStartsHere = graph.getStudentStartsHereNode();
		}
		if(origin !== null && studentStartsHere !== null && origin.getNodeID() != studentStartsHere.getNodeID())
		{
			var path = graph.getBestSubpath(origin, studentStartsHere);  // array of CTATExampleTracerLink
			that.ctatdebug("advanceToStudentStartsHere() path "+path);
			if(!path)
			{
				return;  // no-op if cannot find a path
			}
			var sortedPath = path.getSortedLinks();
			results = that.traceLinks(sortedPath);
			that.ctatdebug("advanceToStudentStartsHere() results "+results);
		}
		var lastNode = null;
		var lastResult = null;
		if(results.length > 0)
		{
			lastResult = results[results.length-1];
			var lastLink = lastResult.getReportableLink();
			if(lastLink !== null)
			{
				lastNode = lastLink.getNextNode();
			}
		}
		that.ctatdebug("advanceToStudentStartsHere() to check for TPA "+lastNode+", "+lastResult);
		var tpaResult = checkForTutorAction(lastNode, exampleTracer.findCurrentState(false, false), null, lastResult);
	}

	/**
	 * Process the workQueue and restoreQueue. No-op if working already.
	 */
	function workTheQueue()
	{
		that.ctatdebug("workTheQueue() working "+working+", workQueue.length "+workQueue.length+", restoreQueue.length "+restoreQueue.length);
		if(working != 0)   // would like explicit synchronization
			return;
		while((working = ((workQueue.length>0) | ((restoreQueue.length>0)<<1))) != 0)   // update working boolean with each iteration
        {
			var msg = null;                       // grab msg at head of queue
			var restoring = false;
			if(restoreQueue.length>0)
			{
				msg = restoreQueue.shift();
				restoring = true;
			}
			else
				msg = workQueue.shift();
			if(!handleMessageFromInterface(msg, restoring))  // false if work on this message not yet complete
			{
				that.ctatdebug("workTheQueue() suspending workQueue.length "+workQueue.length+", restoreQueue.length "+restoreQueue.length);
				that.stopWorking(restoring ? 1 : 0);
				return;
			}
			that.ctatdebug("workTheQueue() bottom workQueue.length "+workQueue.length+", restoreQueue.length "+restoreQueue.length);
		}
	}

	/**
	 * Top-level message processor.
	 * @param {string} aMessage message from student interface
	 * @param {boolean} restoring true if from restore queue
	 * @return true if handled message; false if message should go back on the work queue
	 */
	function handleMessageFromInterface(aMessage, restoring)
    {
		that.lastMessageAsString = aMessage;

        var xml = that.lastMessageAsXML = new CTATXML().parseXML(aMessage);
        var message = that.lastMessage = new CTATMessage(xml);
		var msgType = message.getMessageType();

        that.ctatdebug("CTATExampleTracer.handleMessageFromInterface(msgType " + msgType + ")");

        switch(msgType) {                // Switch, depending on type of message.

        case CTATMsgType.SET_PREFERENCES:
            handleSetPreferences(aMessage, message, parser, xml);
			return false;    // queue messages until graph arrives

        case CTATMsgType.INTERFACE_IDENTIFICATION:
            return true;

        case CTATMsgType.UNTUTORED_ACTION:
			if(restoring)
			{
				that.sendBundle([aMessage]);
			}
            handleUntutoredAction(aMessage, message, parser, xml);
            return true;

        case CTATMsgType.INTERFACE_ACTION:
			if(restoring)
			{
				that.sendBundle([aMessage]);
			}
			handleInterfaceAction(aMessage, message, parser, xml);
			return true;

        case CTATMsgType.PROBLEM_SUMMARY_REQUEST:
			setTimeout(function(problemName)  // delay response 4 sec to allow done step's logging to complete
			{
				handleProblemSummaryRequest(that.getProblemSummary());
				that.startWorking(restoring ? 1 : 0);
			}, 4000);
			return false;

        case CTATMsgType.START_STATE_END:
			outputStatus.transition(CTATMsgType.START_STATE_END);
			return true;     // don't send to UI: if here, PROBLEM_RESTORE_END will do the job

        case CTATMsgType.PROBLEM_RESTORE_END:
			sendProblemRestoreEnd();
			return true;

		case CTATMsgType.GO_TO_STATE:
			return handleGoToState(message);

        default:
			console.log("CTATExampleTracer.handleMessageFromInterface(restoring "+restoring+") "+(restoring ? "sending" : "unprocessed")+" message, type "+msgType+"\n  "+aMessage);
			if(restoring)
				that.sendBundle([aMessage]);
			return true;
		}
    }

	/**
	 * Process a SetPreferences message.
	 * @param aMessage incoming message as string
	 * @param message incoming message as CTATMessage
	 * @param parser XML parser for incoming xml
	 * @param xml incoming message as XML element
	 */
	function handleSetPreferences(aMessage, message, parser, xml)
	{
		that.ctatdebug("handleSetPreferences ()");

		graphLoaded = false;
		problemName = message.getProperty('problem_name');
		that.ctatdebug("SetPreferences.problem_name = " + problemName);

		var setPrefChildren = parser.getElementChildren(parser.getElementChildren(xml)[1]);
		for (var i = 0; i < setPrefChildren.length; i++)
		{
			var eltName = parser.getElementName(setPrefChildren[i]);
			that.ctatdebug("SetPreferences eltName "+eltName);
			if(!eltName)
			{
				continue;
			}
			switch(eltName.toLowerCase()) {
			case "source_id":
				sourceID = parser.getNodeTextValue(setPrefChildren[i]);
				break;
			case "question_file":
				questionFile = parser.getNodeTextValue(setPrefChildren[i]);
				break;
			case "skills":
				that.ctatdebug(" parseSkills("+setPrefChildren[i]+")");
				parseSkills(setPrefChildren[i]);
				break;
			case "problem_state_status":
				outputStatus.transition(CTATMsgType.SET_PREFERENCES, parser.getNodeTextValue(setPrefChildren[i]));
				if(!problemStateRestorer)
					problemStateRestorer = new ProblemStateRestorer(that);
				that.ctatdebug("SetPreferences problemStateRestorer "+problemStateRestorer);
				break;
			case "curriculum_service_url":
				//problemStateSaver.setCurriculumServiceUrl(parser.getNodeTextValue(setPrefChildren[i]));
				CTATConfiguration.set("curriculum_service_url", parser.getNodeTextValue(setPrefChildren[i]));
				break;
			case "restore_problem_url":
				if(!problemStateRestorer)
					problemStateRestorer = new ProblemStateRestorer(that);
				that.ctatdebug("SetPreferences problemStateRestorer "+problemStateRestorer);
				CTATConfiguration.set("restoreProblemUrl", parser.getNodeTextValue(setPrefChildren[i]));
				//problemStateRestorer.setRestoreProblemUrl(parser.getNodeTextValue(setPrefChildren[i]));
				break;
			case "session_id":
				session_id = parser.getNodeTextValue(setPrefChildren[i]);
				break;
			case "authenticity_token":
				problemStateSaver.setAuthenticityToken(parser.getNodeTextValue(setPrefChildren[i]));
				break;
			default:
				break;
			}
		}

		that.ctatdebug("questionFile "+questionFile+", outputStatus "+outputStatus+", problemStateRestorer "+problemStateRestorer);

		retrieveGoToState();  // could change outputStatus to cancel problem state restore

		that.ctatdebug("outputStatus "+outputStatus+", problemStateRestorer "+problemStateRestorer);

		retrieveBRD(questionFile, parser);

		if(problemStateRestorer)
			problemStateRestorer.retrieveMessages(outputStatus);
	}

	/**
	 * Return to the starting state, clearing entries on the student interface.
	 * @return {boolean} false if fails; true if traverses
	 */
	this.goToStartState = function()
	{
		var destNode=(graph.getStudentStartsHereNode() || graph.getStartNode());
		if(destNode)
		{
			that.goToState(destNode.getNodeName());
			return;  // not reached
		}
		console.trace("goToStartState() did not find start node");
	};

	/**
	 * Advance to the named state, sending output to the student interface.
	 * This function works by enqueuing a "GoToState" message on the work queue, as if sent by the student interface.
	 * @param {string} stateName name of node to reach
	 */
	this.goToState = function(stateName)
	{
		var node = graph.findNode(stateName), nodeID = (node ? node.getNodeID() : -1);
		if(nodeID > 0)
		{
			var msg = "<message><verb>NotePropertySet</verb><properties><MessageType>"+CTATMsgType.GO_TO_STATE+"</MessageType><nodeID>" + nodeID + "</nodeID></properties></message>";
			that.receiveFromInterface(msg);  // defer until after the end of the current transaction
		}
	};

	/**
	 * Get the 'Go-To-State' value from sessionStorage and reset the value. Emtpy values are null
	 * or undefined or NaN or '-1'. If a valid nodeID is found, then sets goToStateTargetNodeID and
	 * sets outputStatus to CTATMsgType.BEGIN_GO_TO_STATE.
	 */
	function retrieveGoToState()
	{
		var ssGTS = (typeof(sessionStorage) != "undefined" && sessionStorage ? sessionStorage.getItem('Go-To-State') : null);
		if(ssGTS == null)
		{
			return;			
		}
		sessionStorage.removeItem('Go-To-State');  // housekeep
		var nGTS = Number(ssGTS);
		if(!Number.isSafeInteger(nGTS) || nGTS <= 0)
		{
			return;
		}
		goToStateTargetNodeID = nGTS;
		outputStatus.transition(CTATMsgType.BEGIN_GO_TO_STATE, null);
	}

	/**
	 * Return the go-to-state node and reset goToStateTargetNodeID to -1. If it does
	 * not hold a valid node identifier, then return -1 and reset outputStatus.
	 * @param msgType argument for CTATProblemStateStatus.transition() if target node invalid or noop
	 * @param problemStateStatus 2nd argument for CTATProblemStateStatus
	 * @param noopNode if the go-to-state node is this node (usually the start node), then no transition
	 * @return go-to-state destination node; null if none
	 */
	function resetGoToState(msgType, problemStateStatus, noopNodeID)
	{
		var destNodeID = goToStateTargetNodeID;
		goToStateTargetNodeID = -1;  // prevent reuse
		var destNode = null;
		if(destNodeID == noopNodeID)
		{
			outputStatus.transition(msgType, problemStateStatus);
		}
		else if(destNodeID > 0)
		{
			destNode = graph.getNode(destNodeID);
		}
		that.ctatdebug("CTATET.resetGoToState("+msgType+", "+problemStateStatus+", "+noopNodeID+") returns "+destNode);
		if(destNode)
		{
			outputStatus.transition(CTATMsgType.END_GO_TO_STATE, null);
		}
		return destNode;
	}

	/**
     * Get the BRD file; parse it on receipt. Returns as soon as request is posted.
	 * @param {string} questionFile BRD file URL
	 * @param {CTATXML} parser for BRD file
     */
	function retrieveBRD(questionFile, parser)
	{
		that.ctatdebug ("retrieveBRD ("+questionFile.indexOf ("data:file/brd;base64,")+")");

		// apparently HTTPObject is smart enough to handle this on its own.
		/*if (questionFile.indexOf ("data:file/brd;base64,")==0) // Found the key string right smack at the start of the question file variable
		{
			console.log ("Found Base 64 encoded data in question file, decoding and processing ...");

			var bData=questionFile.substring (21);

			var bDecoded=window.atob (bData);

			//that.ctatdebug ("Decoded BRD: " + bDecoded);

			var xmlDoc = (parser = new CTATXML()).parseXML(bDecoded);

			that.processXML (xmlDoc);
		}
		else
		{*/
			that.ctatdebug ("Using network retrieval to obtain BRD ..."+questionFile);

			tracerCommLibrary.retrieveXMLFile (questionFile, parser, that);
		//}
	}

	/**
	*
	*/
	this.processXML=function processXML (xmlDoc)
	{
		that.ctatdebug ("processXML ()");

		if (xmlDoc==null)
		{
			that.startWorking(0);   // clear 1-bit: SetPreferences always on the workQueue, never on restoreQueue
			return;
		}

		that.ctatdebug("No of children" + parser.getElementChildren(xmlDoc).length);

		var gp = new CTATGraphParser();
		var parserResponse = gp.parseGraph(xmlDoc, that);
		graph = parserResponse.gr;
		exampleTracer = parserResponse.tracer;
		var startStateEndMsgStr = sendStartStateMessages(parserResponse.ssm, parserResponse.sgMsg, gp);
		advanceToStudentStartsHere();
		var endStartStateBundle = [];
		if(startStateEndMsgStr)                     // if saw StartStateEnd, insert SendWidgetLock as last msg
		{
			endStartStateBundle.push(startStateEndMsgStr);
		}
		if(!outputStatus.canRestore())              // if not awaiting problem restore, wrap up start state
		{
			endStartStateBundle.push((new CTATTutorMessageBuilder()).createMessage(CTATMsgType.PROBLEM_RESTORE_END, null));
		}
		if(endStartStateBundle.length > 0)
		{
			that.sendBundle(endStartStateBundle); // if have StartStateEnd and not awaiting restore, send it
		}
		graphLoaded = true;

		that.startWorking(0);   // clear 1-bit: SetPreferences always on the workQueue, never on restoreQueue
	};

	/**
	 * Call this. function to process an incoming ProblemSummaryRequest from the client. Creates msg and calls sendBundle().
	 * @param {CTATProblemSummary} ps
	 */
	function handleProblemSummaryRequest(ps)
	{
		that.ctatdebug("CTATExampleTracer.ProblemSummaryRequest getProblemSummary() " + that.getProblemSummary());

		var psResp = "<message><verb>NotePropertySet</verb><properties><MessageType>"+CTATMsgType.PROBLEM_SUMMARY_RESPONSE+"</MessageType>";
		psResp += SCORMProblemSummary.getProblemSummaryElements(ps);
		psResp += '<ProblemSummary>' + ps.toXML(true) + '</ProblemSummary>';  // true => escape XML markup
		psResp += '<end_of_transaction>true</end_of_transaction>';
		psResp += '</properties></message>';

		var psResps = [];
		psResps.push(psResp);
		that.sendBundle(psResps);
		outputStatus.transition(CTATMsgType.PROBLEM_SUMMARY_RESPONSE, ps.getCompletionStatus());
		that.ctatdebug("CTATExampleTracer.handleProblemSummaryRequest() sent result '" + psResp + "';");
	}

	/**
	 * Call this function when processing a new UntutoredAction from the student.
	 * @param aMessage incoming message as string
	 * @param message incoming message as CTATMessage
	 * @param parser XML parser for incoming xml
	 * @param xml incoming message as XML element
	 */
	function handleUntutoredAction(aMessage, message, parser, xml)
	{
		var transactionID = message.getTransactionID();
		that.ctatdebug("UntutoredAction (" + (aMessage) + "), getTransactionID " + transactionID);
		problemStateSaver.appendToProblemState(aMessage, that.getOutputStatus(), false);
		if(!graphLoaded)
			return false;
		that.setVariablesFromSAI(xml, parser);
		return true;
	}

	/**
 	 * Save the destination nodeID to browser storage and enqueue an InterfaceReboot message to the UI.
	 * @return false to halt further queue processing, since InterfaceReboot exits
	 */
	function handleGoToState(message)
	{
		var nodeID = message.getProperty("nodeID");
		if(nodeID < 0 || !sessionStorage || !sessionStorage.setItem)
		{
			return true;  // no-op
		}
		sessionStorage.setItem('Go-To-State', String(nodeID));

		if(!CTAT.ToolTutor.reboot("Go-To-State "+nodeID+" from CTATExampleTracer"))
		{
			var msgs = [];
			msgs.push(createInterfaceReboot());
			that.ctatdebug("CTATET.handleGoToState() saved nodeID "+nodeID+"; sending to interface\n"+msgs);
			that.sendBundle(msgs);
		}
		return false;  // false to halt further processing of the workQueue?
	}

    /**
	 * Call this function when processing a new InterfaceAction from the student. This call might
	 * trigger a tutor-performed action, but do not call this function to process a TPA.
	 * @param aMessage incoming message as string
	 * @param message incoming message as CTATMessage
	 * @param parser XML parser for incoming xml
	 * @param xml incoming message as XML element
	 */
	function handleInterfaceAction(aMessage, message, parser, xml)
	{
		that.ctatdebug("Interface action received.");
		var transactionID = message.getTransactionID();
		if(!graphLoaded)
			return false;
		that.messageTank = new CTATMessageTank(that, transactionID);
		that.ctatdebug("MessageTank "+that.messageTank);
		that.ctatdebug("InterfaceAction (" + (aMessage) + "), getTransactionID " + transactionID);
		var selectionArray = message.getSelectionArray().slice(0);
		var actionArray = message.getActionArray().slice(0);
		that.ctatdebug("selectionArray "+selectionArray+", message.getSelectionArray() "+message.getSelectionArray());

		//Process a command to the tutor itself
		if (selectionArray[0] && (selectionArray[0].toLowerCase() == "_tutor"))
		{
			that.ctatdebug("handleInterfaceAction tutor cmd SAI "+message.getSAI()+";");
			if (actionArray[0] && typeof(that[actionArray[0]]) === "function")
			{
				var input = message.getSAI().getInput();
				that[actionArray[0]](input);
			}
			return true;
		}

		//Process an interface action that is a hint
		if (selectionArray[0] && (selectionArray[0].toLowerCase() == "hint" || selectionArray[0].toLowerCase() == "help"))
		{
			that.ctatdebug("handleInterfaceAction() hint request: hintPolicy "+hintPolicy+", errorSAI "+errorSAI);
			if (hintPolicy === CTATHintPolicyEnum.HINTS_UNBIASED)
			{
				if (selectionArray.length > 1)
					selectionArray[1] = "";
				if (actionArray.length > 1)
					actionArray[1] = "";
			}
			else if (hintPolicy === CTATHintPolicyEnum.HINTS_BIASED_BY_CURRENT_SELECTION_ONLY)
			{
			}
			else if (hintPolicy === CTATHintPolicyEnum.HINTS_BIASED_BY_PRIOR_ERROR_ONLY)
			{
				if (errorSAI && errorSAI.getSelection())
				{
					selectionArray.splice(1, 0, errorSAI.getSelection());
					actionArray.splice(1, 0, "PreviousFocus");
				}
				else        // prevent PreviousFocus bias
				{
					selectionArray[1] = "";
					actionArray[1] = "";
				}
			}
			else if (hintPolicy === CTATHintPolicyEnum.HINTS_BIASED_BY_ALL)
			{
				if (errorSAI && errorSAI.getSelection())
				{
					selectionArray.splice(1, 0, errorSAI.getSelection());
					actionArray[1] = CTATMsgType.PREVIOUS_FOCUS.toString();
				}
			}

			that.startSkillTransaction();

			var eventArray = []; //Create an eventArray that would be populated by doHint
			var edge = exampleTracer.doHint(selectionArray, actionArray, message.getInputArray(), "student", eventArray, true);
			var result = eventArray[0];
			var hints = result.getReportableHints();
			var stepID = (edge ? ""+edge.getUniqueID() : "");
			result.setStepID(stepID);

            that.updateSkills(CTATExampleTracerSkill.HINT, (edge ? edge.getSkillNames() : []), stepID);

			that.ctatdebug("Before building hint message: tutorSAI "+result.getTutorSAI()+", hints " + hints + ", edge # " + stepID);
			var hintMessage = new CTATTutorMessageBuilder().createHintMessage(hints, result.getTutorSAI(), stepID, transactionID);
			that.messageTank.addToMessageTank(CTATMsgType.SHOW_HINTS_MESSAGE, hintMessage, result, null);

			var assocMsg = new CTATTutorMessageBuilder().createAssociatedRulesMessageForHint(hints, result.getTutorSAI(), actorForLog(CTATMsgType.DEFAULT_STUDENT_ACTOR), that.getSkillBarVector(true), stepID, transactionID);
			that.messageTank.addToMessageTank(CTATMsgType.ASSOCIATED_RULES, assocMsg, result, null);

			var ps = that.getProblemSummary(result.getReportableInterpretation());
			that.messageTank.flushMessageTank(ps, true);
			that.ctatdebug("handleInterfaceAction() sent hint result " + result);
			errorSAI = null;	// Error bias lasts only through first hint request
		}
		else    //Process a interface action that is not a hint
		{
			that.ctatdebug("calling doNewExampleTrace(null, "+message.getSAI()+") sai.selectionArray "+message.getSAI().getSelectionArray()+" msg.selectionArray "+message.getSelectionArray());
            doNewExampleTrace(null, message.getSAI(), "student", true, transactionID, aMessage);
		}
		return true;
	}

    function parseSkills(element)
    {
        var skillList = [];
        var skills = parser.getElementChildren(element);
        for (var index = 0; index < skills.length; index++)
        {
			var eltName = parser.getElementName(skills[index]);
            if (eltName && (eltName.toLowerCase() == "skill"))
            {
                var name = parser.getElementAttr(skills[index],"name");
				if(!name || name.trim() == "")
				{
					continue;
				}
				var label = parser.getElementAttr(skills[index],"label");
                var pSlip = parser.getElementAttr(skills[index],"pSlip");
                var description = parser.getElementAttr(skills[index],"description");
                var pKnown = parser.getElementAttr(skills[index],"pKnown");
                var category = parser.getElementAttr(skills[index],"category");
                var pLearn = parser.getElementAttr(skills[index],"pLearn");
                var pGuess = parser.getElementAttr(skills[index],"pGuess");
				var history = parser.getElementAttr(skills[index],"history");
				var skill = new CTATExampleTracerSkill(category,name,pGuess,pKnown,pSlip,pLearn,history);
				skill.setLabel(label);
				skill.setDescription(description);
				skillList.push(skill);
            }
        }
        that.getProblemSummary().setSkills(new CTATSkills(skillList));
    }

    this.addGraphSkills = function(graphSkills)
    {
    	that.ctatdebug("adding graph skills: "+graphSkills.length);
    	if (graphSkills.length > 0)
    	{
    		var skillsFromGraph = new CTATSkills(graphSkills);
    		skillsFromGraph.setExternallyDefined(false);
    		that.getProblemSummary().setSkills(skillsFromGraph);
    	}
    };

    /**
     * Send an array of messages via CTAT.ToolTutor.sendToInterface().
     * @param msgs the array to send; no-op if empty
     * @return {boolean} true if actually sent
     */
    this.sendBundle = function(msgs)
    {
        that.ctatdebug("sending bundle #msgs = " + msgs.length + ", outputStatus " + outputStatus);
		var count = 0;
        for (var index = 0; index < msgs.length; index++)
        {
            that.ctatdebug("Sending message #" + index);
            var msg = msgs[index];
            if (index <= 0)
                msg = xmlHeader + msg;
            if(problemStateSaver.forwardToInterface(msg, (index >= msgs.length - 1), outputStatus))
				++count;
        }
		return (count > 0);
    };

	/**
	 * @param {string} thePolicy one of
	 */
    this.setHintPolicy  = function(thePolicy)
    {
		hintPolicy = CTATHintPolicyEnum.lookup(thePolicy);
    };

	/**
	 * @return highlightRightSelection
	 */
	this.isHighlightRightSelection = function()
	{
		return highlightRightSelection;
	};

	/**
	 * @param {boolean} b new value for highlightRightSelection
	 */
	this.setHighlightRightSelection = function(b)
	{
		highlightRightSelection = b;
	};

    /**
     * Update a list of skills according to the given transaction result.
     * @param transactionResult (of type String): one of Skill.CORRECT(), Skill.INCORRECT, Skill.HINT
     * @param skillNames (of type set of strings): skills to update
     * @param stepID (of type string): identifier for this step, to ensure no step is updated more than once
     * @return array of CTATExampleTracerSkill: list of skills modified
     */
    this.updateSkills = function(transactionResult, skillNames, stepID)
    {
        var result = []; //array of CTATExampleTracerSkill
        that.ctatdebug("in updateSkills("+skillNames+") with step ID = " + stepID + ", transaction result = " +transactionResult);

        //we will not have a controller

        var skills = that.getProblemSummary().getSkills();
        if (skills === null || typeof (skills) === 'undefined')
        {
            return result;

        }
        skillNames.forEach(function(skillName)
        {
            var modifiedSkill = skills.updateSkill(transactionResult, skillName, stepID);
            if (modifiedSkill !== null && typeof (modifiedSkill) !== 'undefined')
            {
                result.push(modifiedSkill);
            }
        });
        return result;
    };

    /**
     * @return {string} session_id
     */
    this.getSessionID = function()
    {
		return session_id;
    };

    /**
	 * @param {CTATExampleTracerInterpretation} interp for counting required steps
     * @return object of type CTATProblemSummary
     */
    this.getProblemSummary = function(interp)
    {
		that.ctatdebug("Entering getProblemSummary() problemSummary "+problemSummary);

        //rule production goes here
        //catalog commented out for now

        if (problemSummary === null || typeof (problemSummary) === 'undefined')
        {
            var problemName = that.getProblemName();

            if (problemName === null || typeof (problemName) === 'undefined' || problemName.length < 1)
            {
                problemName = "NoProblemDefined";
                problemSummary = new CTATProblemSummary(problemName, null, that.isFeedbackSuppressed());
            }
			else
			{
				problemSummary = new CTATProblemSummary(problemName, null, that.isFeedbackSuppressed());
			}
        }
		if(interp)
		{
			problemSummary.setRequiredSteps(interp.countStepsForScore(graph));
		}

        //skills are external and are determined at author time
        /*if(problemSummary.getSkills() === null || typeof(problemSummary.getSkills()) === 'undefined')
         {
         //rules go here

         var skills = new CTATSkills([]);

         //We do not have a BR_CONTROLLER, this goes away
         //skills.setVersion();

         //rules go here


         problemSummary.setSkills(skills);
         }*/

        return problemSummary;
    };

    /**
     * @return problemName
     */
    this.getProblemName = function()
    {
        return problemName;
    };

    /**
     * @return sourceID
     */
    this.getSourceID = function()
    {
        return sourceID;
    };

    /**
     * @return sourceID
     */
    this.isSourceFlash = function()
    {
        return typeof(sourceID) == "string" && sourceID.match(/flash/i);
    };

    /**
     * @return true if suppressStudentFeedback matched CTATMsgType.HIDE_ALL_FEEDBACK
     */
    this.isFeedbackSuppressed = function()
    {
        return feedbackSuppressed;
    };

	/**
	 * @param {string} policy one of CTATMsgType.SHOW_ALL_FEEDBACK, .HIDE_ALL_FEEDBACK, etc.
	 */
    this.setFeedbackSuppressed = function(policy)
    {
		if(policy === "false")     feedbackSuppressed = false;
		else if(policy === "true") feedbackSuppressed = true;
		else if(policy === CTATMsgType.SHOW_ALL_FEEDBACK) feedbackSuppressed = false;
		else if(policy === CTATMsgType.HIDE_ALL_FEEDBACK) feedbackSuppressed = true;
		else if(policy === CTATMsgType.HIDE_BUT_ENFORCE) feedbackSuppressed = true;
		else if(policy === CTATMsgType.HIDE_BUT_COMPLETE) feedbackSuppressed = true;
		else if(policy === CTATMsgType.DELAY_FEEDBACK) feedbackSuppressed = false;
		else feedbackSuppressed = false;
		that.ctatdebug("setFeedbackSuppressed("+policy+"): "+feedbackSuppressed);
		if(problemSummary)
		{
			problemSummary.setCountOnlyLastResults(feedbackSuppressed);
		}
    };

    /**
     * @param {boolean} updateOnly If true, get skills for update: set to true for AssociatedRules messages
	 * @param {string} actor If contains "tutor", return null: don't log skills for tutor-performed steps
     * @return array of strings: returns null if no skills
     */
    this.getSkillBarVector = function(updateOnly, actor)
    {
        var skills = that.getProblemSummary().getSkills();

        if (skills === null || typeof (skills) === 'undefined')
        {
            return null; // not tracing any skills
        }
        else if (actorForLog(actor) != "Student")
        {
            return null; // not tracing any skills
        }
        else
        {
        	return (typeof(updateOnly) != 'undefined' && updateOnly ? skills.getSkillBarVector(false, false) : skills.getSkillBarVector(true, true));
        }
    };

    /**
     * Set a new serial number for skill updates. Call this at the start of each transaction.
     */
    this.startSkillTransaction = function()
    {
        var skills = that.getProblemSummary().getSkills();
        if(!skills)
            return;
        skills.startTransaction();
    };

    /**
	 * @return {ProblemStateSaver} problemStateSaver
	 */
	this.getProblemStateSaver = function()
	{
		return problemStateSaver;
	};

	/**
	 * Tell whether the current state requires that we actually send saved messages for restore.
	 * @return {boolean} true if should save for restore
	 */
	this.isSendingSavedMsgsForRestore = function()
	{
		return (that.getOutputStatus().isSendingSavedMsgsForRestore());
	};

	/**
	 * @return {CTATProblemStateStatus} outputStatus
	 */
	this.getOutputStatus = function()
	{
		return outputStatus;
	};

	/**
	 * @param {string} newStatus new value for this.outputStatus
	 */
	this.setOutputStatus = function(newStatus)
	{
		var oldStatus = outputStatus.getStatus();
		that.ctatdebug("setOutputStatus() old "+oldStatus+", new "+newStatus);

		if(CTATProblemStateStatus[newStatus])
		{
			outputStatus.setStatus(CTATProblemStateStatus[newStatus]);
			return;
		}
		console.error("CTATExampleTracer.setOutputStatus() unexpected argument " + newStatus);
		outputStatus.setStatus(CTATProblemStateStatus.empty);
	};

	/**
	 * Create a message for any available feedback text. Returns an object with properties<ul>
	 * <li>tutorAdvice: the feedback text for the AssociatedRules message; null if none;</li>
	 * <li>msg: an entire message with message type BuggyMessage or HighlightMsg; null if none to send.</li>
	 * </ul>
	 * @param {CTATExampleTracerEvent} resultEvent result from the original trace
	 * @param {CTATExampleTracerLink} hintLink result from  the silent hint cycle
	 * @param {CTATTutorMessageBuilder} msgBuilder
	 * @return {{tutorAdvice: string|null, msg: string|null, msgType: string|null}}
	 */
	function createBuggyMessage(resultEvent, hintResult, msgBuilder)
	{
		var rtn = {tutorAdvice: null, msg: null, msgType: null};
		if(resultEvent.getReportableLink())
		{
			rtn.tutorAdvice = resultEvent.getSuccessOrBuggyMsg();
			if(rtn.tutorAdvice && rtn.tutorAdvice.trim())
			{
				rtn.msg = msgBuilder.createBuggyMessage(resultEvent.getTransactionID(), rtn.tutorAdvice);
				rtn.msgType = "BuggyMessage";
			}
			else
			{
				rtn.tutorAdvice = null;  // buggy link has no buggy message
			}
			return rtn;
		}
		that.ctatdebug("CTATET.createBuggyMessage() past getReportableLink()");

		if(resultEvent.isDoneStepFailed())
		{
			rtn.tutorAdvice = CTATMsgType.NOT_DONE_MSG;
			rtn.msg = msgBuilder.createBuggyMessage(resultEvent.getTransactionID(), rtn.tutorAdvice);
			rtn.msgType = "BuggyMessage";
			return rtn;
		}
		that.ctatdebug("CTATET.createBuggyMessage() past isDoneStepFailed()");

		// Out of order text: only if hint cycle recommends a step on a different selection.

		var hintSelection0 = (hintResult && hintResult.getTutorSAI() ? hintResult.getTutorSAI().getSelection() : null);
		hintSelection0 = (hintSelection0 && hintSelection0.trim() !== "" ? hintSelection0 : null);

		var studentSelection0 = (resultEvent.getStudentSAI() ? resultEvent.getStudentSAI().getSelection() : null);
		studentSelection0 = (studentSelection0 && studentSelection0.trim() !== "" ? studentSelection0 : null);
		that.ctatdebug("CTATET.createBuggyMessage() past hintSelection0 "+hintSelection0+", studentSelection0 "+studentSelection0);

		if((resultEvent.getResult() == CTATExampleTracerLink.NO_MODEL) && resultEvent.isOutOfOrder() && hintSelection0 && (hintSelection0 != studentSelection0))
		{
			that.ctatdebug("CTATET.createBuggyMessage() to create out of order");
			if(that.isHighlightRightSelection())
			{
				rtn.tutorAdvice = that.getOutOfOrderMessage();
				rtn.msg = msgBuilder.createHighlightWidgetMessage(hintSelection0, hintResult.getTutorSAI().getAction(), rtn.tutorAdvice, resultEvent.getTransactionID());
				rtn.msgType = "HighlightMsg";
			    that.ctatdebug("createBuggyMessage() out of order with highlight; rtn: " + rtn);
			}
			else
			{
				//rtn.tutorAdvice = "You need to do other steps first, before doing the step you just worked on. You might request a hint for more help.";
				rtn.tutorAdvice= CTATGlobals.languageManager.getString ("OUTOFORDER");
				rtn.msg = msgBuilder.createBuggyMessage(resultEvent.getTransactionID, rtn.tutorAdvice);
				rtn.msgType = "BuggyMessage";
			    that.ctatdebug("createBuggyMessage() out of order without highlight; rtn: " + rtn);
			}
			return rtn;
		}
		var defaultBuggyMsg = graph.getDefaultBuggyMsg();
		if(defaultBuggyMsg)
		{
			rtn.tutorAdvice = defaultBuggyMsg;
			rtn.msg = msgBuilder.createBuggyMessage(resultEvent.getTransactionID, rtn.tutorAdvice);
			rtn.msgType = "BuggyMessage";
		    that.ctatdebug("createBuggyMessage() default buggy msg: " + rtn);
			return rtn;
		}
	    that.ctatdebug("createBuggyMessage() no buggy msg: " + rtn);
		return rtn;
	}

/******************************************************/
//Tutor performed actions

    /**
     * Check whether there's a tutor-performed step at the given node in the
     * graph and, if so, do it with traverseEdge()
     * @param {CTATExampleTracerNode} priorLinkDest the destination node of the last-matched link; can be null
     * @param {CTATExampleTracerNode} currNode the current node, as calculated by the example-tracer algo
     * @param {CTATSAI} studentSAI last selection, action, input from student
	 * @param {CTATExampleTracerEvent} result from the previous step
     * @return {CTATExampleTracerEvent} result from the last step traversed
     */
    function checkForTutorAction(priorLinkDest, currNode, studentSAI, priorResult)
    {
		that.ctatdebug("checkForTutorAction("+priorLinkDest+", "+currNode+", "+studentSAI+", "+priorResult+")");

        var links = []; //contains CTATExampleTracerLinks
        links[0] = nodeTutorActionFires(graph.getNode(priorLinkDest), true);
        links[1] = nodeTutorActionFires(graph.getNode(currNode), false);
		that.ctatdebug("checkForTutorAction() links[0] "+links[0]+", links[1] "+links[1]+";");

        var i = 0;
        if(links[0] === links[1])
        {
            links[1] = null; // fire the tutor action only once
        }
        else if(links[0] === null || typeof(links[0]) === 'undefined')
        {
            i = 1; // skip null entry
        }

        var result = null; //of type CTATExampleTracerEvent
		if(!that.messageTank)
		{
			that.messageTank = new CTATMessageTank(that, null);
		}

        for( ; i < links.length && links[i] !== null && typeof(links[i]) !== 'undefined'; ++i)
        {
            if(studentSAI == null || typeof(studentSAI) == 'undefined')
            {
                result = doNewExampleTrace(links[i], links[i].getDefaultSAI(), links[i].getActor(), true, null);
            }
            else        // FIXME? evaluate defaultSAI with studentSAI--now trying this below
            {
				var evaluatedInput = links[i].getEvaluatedInput(studentSAI, priorResult.getReportableVariableTable());
				var sai = links[i].getDefaultSAI().clone();
				sai.setInput(evaluatedInput);
                result = doNewExampleTrace(links[i], sai, links[i].getActor(), true, null);
            }
        }

		that.ctatdebug("checkForTutorAction() returning "+result+";");
        return result;
    }

    /**
     * Tell whether the given state has an outgoing tutor-performed action to fire.
     * @param {CTATExampleTracerNode} src source state whose outgoing link(s) would be candidates
     * @param {boolean} linkTriggered true if action must be link-triggered, false if state-triggered
     * @return {CTATExampleTracerLink} object if action should fire; else null if not
     */
    function nodeTutorActionFires (src, linkTriggered)
    {
        if(src === null || typeof(src) === 'undefined')
        {
            return null;
        }
        if(src.getCorrectOutDegree() !== 1)
        {
            return null; // must be exactly one CORRECT outgoing link
        }
		var result = null;
		src.getCorrectOutLinks().forEach(function(nextLink) {
			if(result !== null)
			{
				return;
			}
	        if(nextLink.isTutorPerformed(linkTriggered) && nextLink.getMaxTraversals() > 0)
    	    {
            	result = nextLink;
        	}
        });
		return result;
    }

    /**
     * Perform an example-trace on a preselected edge, as when doing a tutor-performed step.
     * @param {CTATExampleTracerLink} link edge already selected
	 * @param {CTATSAI} student SAI
     * @param {string} actor
     * @param {boolean} doTutorPerformedSteps
	 * @param {string} transactionID
	 * @param {string} origMsgTxt original message from student: if present, append to the problem state on traversal
     * @return {CTATExampleTracerEvent} result from the step traversed
     */
    function doNewExampleTrace (link, sai, actor, doTutorPerformedSteps, transactionID, origMsgTxt)
    {
		that.ctatdebug("doNewExampleTrace (link "+link+", sai "+sai+", actor "+actor+", doTutorPerformedSteps "+doTutorPerformedSteps+", transactionID "+transactionID+", origMsgTxt "+origMsgTxt);

		var newTransactionID = transactionID;
		var result = new CTATExampleTracerEvent(that, sai, actor);

		if(that.getOutputStatus().isComplete() && sai.isDone())
		{
			result.setResult(CTATExampleTracerLink.CORRECT_ACTION);
			result.setTutorSAI(sai);
			result.setTransactionID(newTransactionID);
			var rtn = finishNewExampleTrace(result, sai, actor, false);

			that.ctatdebug("doNewExampleTrace("+link+", "+sai+", "+actor+", "+doTutorPerformedSteps+", "+newTransactionID+") returns "+rtn);
			return rtn;
		}

       	that.startSkillTransaction();

		if(link)
		{
			result.addPreloadedLinkMatch(link);
		}
        var isCorrect = exampleTracer.evaluate(result);
		that.ctatdebug("Evaluate returned : "+isCorrect+", given link "+link+", result "+result);
		if(link)
		{
			that.ctatdebug("result.getTutorSelection() "+result.getTutorSelection());
			that.ctatdebug("result.getTutorAction() "+result.getTutorAction());
			that.ctatdebug("result.getTutorInput() "+result.getTutorInput());
			that.ctatdebug("typeof(messageTank) "+typeof(messageTank));
	        newTransactionID = enqueueToolActionToStudent(result.getTutorSelection(), result.getTutorAction(), result.getTutorInput());
    	    setTransactionId(newTransactionID);  // for messageTank
		}
		else  // only append student actions (where link is not known prior) to the problem state, and only if a link was traversed or feedback is suppressed
		{
			if(that.isFeedbackSuppressed())  // except with HIDE_BUT_ENFORCE, save only last entry for each unique step
			{
				problemStateSaver.replaceInProblemState(origMsgTxt, that.getOutputStatus(), result.getStudentSAI(), graph.getFeedbackPolicy() == CTATMsgType.HIDE_BUT_ENFORCE);
			}
			else if(result.getResult() == CTATExampleTracerLink.CORRECT_ACTION || result.getResult() == CTATExampleTracerLink.FIREABLE_BUGGY_ACTION)
			{
				problemStateSaver.appendToProblemState(origMsgTxt, that.getOutputStatus(), false);
			}
		}
		result.setTransactionID(newTransactionID);
		var rtn = finishNewExampleTrace(result,sai,actor,doTutorPerformedSteps);

		that.ctatdebug("doNewExampleTrace("+link+", "+sai+", "+actor+", "+doTutorPerformedSteps+", "+newTransactionID+") returns "+rtn);
		return rtn;
    }

    /**
     * Generate a ToolMessage log entry, to create
     * a DataShop transaction where we don't normally have one. E.g., for tutor-
     * performed steps.
     * @param {array} selection
     * @param {array} action
     * @param {array} input
     * @return {String} new message's transaction_id
     */
    function enqueueToolActionToStudent(selection, action, input)
    {
		return that.messageTank.enqueueToolActionToStudent(selection, action, input, CTATTutorMessageBuilder.TUTOR_PERFORMED);
    }

    /**
     * @param {String} semanticEventId
     */
    function setTransactionId(semanticEventId)
    {
        if(semanticEventId)
        {
            that.messageTank.setTransaction_id(semanticEventId);
        }
    }

	/**
	 * Translate an actor from CTATMsgType to a string for logging.
	 * @param {string} actor value from CTATMsgType properties or elsewhere
	 * @return {string} "tutor" if argument contains tutor; else "student"
	 */
	function actorForLog(actor)
	{
		return (typeof(actor) != 'undefined' && actor && actor.toString().toLowerCase().indexOf("tutor") >= 0 ? "Tutor" : "Student");
	}

    /**
     * Factored out common conclusion steps to
     * {doNewExampleTrace(CTATExampleTracerLink, array, array, array, String)
     * @param {CTATSAI} sai
     * @param {String} actor
     * @param {boolean} doTutorPerformedSteps whether to go on to traverse a tutor-performed step
     * @return {CtatExampleTracerEvent} result of the last step traversed, including tutor-performed steps
     */
    function finishNewExampleTrace(result, sai, actor, doTutorPerformedSteps)
    {
		that.ctatdebug("finishNewExampleTrace("+result+", "+sai+", "+actor+", "+doTutorPerformedSteps+")");

        var depthSoFar = -1; //of type integer
        //MORE CODE GOES HERE
        var studentSAI = result.getStudentSAI();
        var tutorSAI = result.getTutorSAI();
        var transactionID = result.getTransactionID();
        var msgBuilder = new CTATTutorMessageBuilder();
        var stepID = "";
        var links = [];
        var length = 1;

        if(result.getReportableLink() !== null && typeof(result.getReportableLink()) !== 'undefined')
            links[0] = result.getReportableLink();
        else
            links[0] = null;

        var link = links[0]; //Equivalent to java edgeData = edges[0].getEdgeData();
		var tpaResult = null;

        if(result.isSolverResult()) //Not used
        {
            var transactionResult = (CTATExampleTracerLink.CORRECT_ACTION.toString() === result.getResult().toString ? CTATExampleTracerSkill.CORRECT : CTATExampleTracerSkill.INCORRECT); //of type String
        }
        else if (result.getResult() === CTATExampleTracerLink.CORRECT_ACTION)
        {
            stepID = (link ? ""+link.getUniqueID() : "");
			result.setStepID(stepID);

			if(CTATMsgType.UNGRADED_TOOL_ACTOR.toUpperCase() != actor.toUpperCase())
	            that.messageTank.addToMessageTank(CTATMsgType.CORRECT_ACTION, msgBuilder.createCorrectActionMessage(transactionID, tutorSAI), result, tutorSAI);
            if(link !== null && typeof(link) !== 'undefined')
            {
                that.updateSkills(CTATExampleTracerSkill.CORRECT,link.getSkillNames(),link.getUniqueID());
            }
			var successMsg = result.getSuccessOrBuggyMsg();
            that.messageTank.addToMessageTank(CTATMsgType.ASSOCIATED_RULES, msgBuilder.createAssociatedRulesMessageForAction(result.getResult(), tutorSAI,  actorForLog(actor), studentSAI, that.getSkillBarVector(true, actor), (link ? link.getUniqueID() : -1), transactionID, successMsg), result, tutorSAI);
			that.ctatdebug("finishNewExampleTrace() successMsg "+successMsg);
            if (successMsg)
			{
                that.messageTank.addToMessageTank("SuccessMessage", msgBuilder.createSuccessMessage(transactionID, successMsg), result, null);
			}
            errorSAI = null;

            if(doTutorPerformedSteps)
            {
                tpaResult = checkForTutorAction(link ? link.getNextNode() : null, exampleTracer.findCurrentState(false, false), (that.lastMessage ? that.lastMessage.getSAI() : null), result);
                if(tpaResult)
                {
                    result = tpaResult;
                }
            }
        }
        else
        {
            that.messageTank.addToMessageTank(CTATMsgType.INCORRECT_ACTION, msgBuilder.createInCorrectActionMessage(transactionID, result.getInterpolatedSAI()), result, null);
			that.ctatdebug("about to do silent traceForHint("+studentSAI+"), selectionArray "+studentSAI.getSelectionArray());
            var hintResult = that.lastSilentHintResult = new CTATExampleTracerEvent(that, studentSAI, actor);
			hintResult.setHintRequest(true);
            var hintLink = exampleTracer.traceForHint(hintResult);
            that.ctatdebug("silent hint result: " + hintResult + "; hintLink " + hintLink);
            if(!hintLink)                                    // found no correct step for student selection
            {
                hintLink = exampleTracer.getBestNextLink(false, hintResult);
				that.ctatdebug("getBestNextLink result: " + hintResult + "; hintLink " + hintLink);
	        }
			tutorSAI = null;
            if(hintLink)
			{
				tutorSAI = hintResult.getTutorSAI();
				if(tutorSAI && tutorSAI.getSelection())
				{
					result.setTutorSAI(tutorSAI);
				}
        	    stepID = "" + hintLink.getUniqueID();  // integer as string
				result.setStepID(stepID);
			}
            var textResp = createBuggyMessage(result, hintResult, msgBuilder);
            that.ctatdebug("createBuggyMessage() tutorAdvice: " + textResp.tutorAdvice + ";\n  msg " + textResp.msg);
            that.updateSkills(CTATExampleTracerSkill.INCORRECT, (hintLink ? hintLink.getSkillNames() : []), stepID);
            that.messageTank.addToMessageTank(CTATMsgType.ASSOCIATED_RULES, msgBuilder.createAssociatedRulesMessageForAction(result.getResult(), (tutorSAI && tutorSAI.getSelection() ? tutorSAI : studentSAI), actorForLog(actor), studentSAI, that.getSkillBarVector(true, actor), stepID, transactionID, textResp.tutorAdvice), result, null);

            if (textResp.msg)
	        {
                that.messageTank.addToMessageTank(textResp.msgType, textResp.msg, result);
	        }
            errorSAI = studentSAI;        // save incorrect SAI to bias next hint, if hint request follows

            if(doTutorPerformedSteps && CTATExampleTracerLink.FIREABLE_BUGGY_ACTION == result.getResult())
            {
                tpaResult = checkForTutorAction(link ? link.getNextNode() : null, exampleTracer.findCurrentState(false, false), (that.lastMessage ? that.lastMessage.getSAI() : null), result);
                if(tpaResult)
                {
                    result = tpaResult;
                }
            } else if (result.isDoneStepFailed()) {
				that.messageTank.flushDelayedFeedback();
			}
		}
        that.lastResult = result;
		var ps = that.getProblemSummary(result.getReportableInterpretation());
		that.ctatdebug("finishNewExampleTrace() to flushMessageTank");
        that.messageTank.flushMessageTank(ps, true);
        that.ctatdebug("finishNewExampleTrace() sent result " + result.getResult() + ", studentSAI " + studentSAI);
		return result;
    }


	/**
	 * Handle a ProblemRestoreEnd message: send current skills and restore output.
	 */
	function sendProblemRestoreEnd() {
		outputStatus.transition(CTATMsgType.PROBLEM_RESTORE_END);  // must transition before sending
		var skillBarVector = that.getSkillBarVector();
		var msgs = [];
		var builder = new CTATTutorMessageBuilder();
		msgs.push(builder.createMessage(CTATMsgType.PROBLEM_RESTORE_END, (skillBarVector ? {Skills: skillBarVector} : null)));
		that.sendBundle(msgs);
	}

	/**
	 * @return {string} policy one of CTATMsgType.SHOW_ALL_FEEDBACK, HIDE_ALL_FEEDBACK, DELAY_FEEDBACK
     */
	this.getFeedbackPolicy = function()
	{
		return (graph ? graph.getFeedbackPolicy() : CTATMsgType.SHOW_ALL_FEEDBACK);
	};

	/**
     * Public access to the graph.
     */
    this.getGraph = function()
    {
		return graph;
	};

	/**
     * Public access to the exampleTracer.
     */
    this.getTracer = function()
    {
		return exampleTracer;
	};

	/**
	 * @return {string} outOfOrderMessage}; if null or empty,
	 *         return CTATMsgType.DEFAULT_OUT_OF_ORDER_MESSAGE
	 */
	this.getOutOfOrderMessage = function()
    {
		if(!outOfOrderMessage)
			return CTATMsgType.DEFAULT_OUT_OF_ORDER_MESSAGE;
		else
			return outOfOrderMessage;
	};

	/**
	 * @param {string} newOutOfOrderMessage new value for outOfOrderMessage
	 */
	this.setOutOfOrderMessage = function(newOutOfOrderMessage)
    {
		outOfOrderMessage = newOutOfOrderMessage;
	};

	/**
	 * Create if needed and get contents of delayedFeedback list, stored as an object.
	 * @return {object} delayedFeedback; create if null
	 */
	this.getDelayedFeedback = function()
	{
		if(delayedFeedback == null)
		{
			delayedFeedback = {};
		}
		return delayedFeedback;
	};

	/**
	 * Clear the delayedFeedback list
	 */
	this.clearDelayedFeedback = function()
	{
		delayedFeedback = null;
	};

	/**
	 * @param {boolean} full if true, return full path; else just the simple file name
	 * @return {string} questionFile
	 */
	this.getQuestionFile = function(full)
    {
		if(!questionFile || full)
			return questionFile;
		var pathArr = questionFile.split("/");
		return pathArr[pathArr.length - 1];
	};
};

CTATExampleTracer.prototype = Object.create(CTATBase.prototype);
CTATExampleTracer.prototype.constructor = CTATExampleTracer;

if (typeof module !== 'undefined')
{
    module.exports = CTATExampleTracer;
}
