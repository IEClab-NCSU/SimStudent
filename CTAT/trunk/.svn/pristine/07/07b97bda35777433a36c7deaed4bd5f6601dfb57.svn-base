/* This object represents an CTATExpressionMatcher */

goog.provide('CTATExpressionMatcher');
goog.require('CTATExampleTracerException');
goog.require('CTATSingleMatcher');
goog.require('CTATVariableTable');
goog.require('CTATFormulaFunctions');
goog.require('CTATFormulaParser');
goog.require('CTATMatcher');

/* LastModify: sewall 2014/10/31 */

/**
 * @constructor
 * @param {integer} givenVectorector s a or i
 * @param {string} givenText The matcher's toString()
 */
CTATExpressionMatcher = function(givenVector, givenText)
{
	//calling the constructor fo the super class from where we are inheriting
	CTATSingleMatcher.call(this, givenVector, givenText);

/**************************** PUBLIC INSTACE VARIABLES ******************************************************/

/**************************** PRIVATE INSTACE VARIABLES ******************************************************/

	/**
     * Role
     * @type {integer}
     */
    var vector = givenVector;

    /**
     * Default
     * @type {integer}
     */
	var relation = CTATExpressionMatcher.EQ_RELATION;

    /**
     * @type {String}
     */
	var expression = givenText;

	/**
	 * @type {String}
	 */
	var lastInput = null;

	/**
	 * @type {String}
	 */
	var lastError = null;

	/**
	 * @type {Date}
	 */
	var lastEvaluationTime = null;

	/**
	 * @type {boolean}
	 */
	var lastComparison = false;

	/**
     * Make the object available to private methods
     */
	var that = this;

/***************************** PRIVATE METHODS *****************************************************/

	/**
	 * @private
	 */
	function initExpression()
	{
		if(givenText !== null && typeof(givenText) !== 'undefined')
		{
			var gExpression; //of type string
			var beginQuote = givenText.indexOf("\""); //of type int
			var endQuote = givenText.lastIndexOf("\""); //of type int

			if(beginQuote >= 0 && endQuote >= 0)
			{
				gExpression = givenText.substring(beginQuote + 1, endQuote);
				var testRel = givenText.substring(0, givenText.indexOf(" "));
				relation = CTATExpressionMatcher.nameToRelation(testRel);
			}
			else
			{
				gExpression = givenText;
			}

			that.setInputExpression(gExpression);
		}
	}

	/**
     * Evaluate the formula and compare the result with the proper SAI element.
     * @param {String} selection
     * @param {String} action
     * @param {String} input
     * @param {integer} vector
     * @param {CTATVariableTable} vt proper variable table for evaluate(String, String, String, VariableTable)
     * @return {boolean}
     */
     function testVector(selection, action, input, vector, vt)
     {
		that.ctatdebug("CTATExpressionMatcher.testVector["+vector+"]("+selection+", "+action+", "+input+", "+vt+") to call evaluate");
		var inputConv = CTATVariableTable.standardizeType(input);
		that.ctatdebug("CTATExpressionMatcher.testVector typeof input "+typeof(input)+"; inputConv "+inputConv+", typeof "+typeof(inputConv));
     	var result = that.evaluate(selection, action, inputConv, vt);
		that.ctatdebug("CTATExpressionMatcher.testVector evaluate("+selection+", "+action+", "+inputConv+", "+vt+") returned "+result+", type "+typeof(result));

     	var comparee = null;

     	switch(vector)
     	{
     		case CTATMatcher.SELECTION:
     			comparee = selection;
     			break;
     		case CTATMatcher.ACTION:
     			comparee = action;
     			break;
     		case CTATMatcher.INPUT:
     		case CTATMatcher.NON_SINGLE:
     			comparee = inputConv; //the old default
     	}

     	lastInput = comparee;
     	lastEvaluationTime = new Date();

		that.ctatdebug("CTATExpressionMatcher.testVector comparee "+comparee+", type "+typeof(comparee)+", relation "+relation+"( "+CTATExpressionMatcher.RELATIONS[relation]+" )");
		try {
			switch(relation)
			{
				case CTATExpressionMatcher.BOOL_RELATION:
					return Boolean(result);
				case CTATExpressionMatcher.EQ_RELATION:
					if(comparee == null) return result == null;                  // return true if both null
					if(result == null) return false;                             // return false: comparee not null, result null
					return that.compareNumberOrString(comparee, result, relation);
				case CTATExpressionMatcher.NOT_EQ_RELATION:
					if(comparee == null) return result != null;                  // return false if both null
					if(result == null) return true;                              // return true: comparee not null, result null
					return that.compareNumberOrString(comparee, result, relation);
				case CTATExpressionMatcher.LT_RELATION:
				case CTATExpressionMatcher.GT_RELATION:
					if (comparee == null || result == null) return false;        // return false: both null or cannot compare
					return that.compareNumberOrString(comparee, result, relation);
				case CTATExpressionMatcher.LTE_RELATION:
				case CTATExpressionMatcher.GTE_RELATION:
					if(comparee == null) return result == null;                  // true if both null, else false since cannot compare null comparee
					if(result == null) return false;                             // false: cannot compare non-null comparee to null result
					return that.compareNumberOrString(comparee, result, relation);
				default:
					//console.log("CTATExpressionMatcher.testVector() undefined relation "+relation);
					return false;
			}
		}
     	catch(e)
     	{
     		//console.log("CTATExpressionMatcher --> " + e.name + ": " + e.message);
			lastError = e.message;
     	}
     	return false;
     }
/***************************** PRIVILEDGED METHODS *****************************************************/

	/**
	 * @return {string} lastInput
	 */
	this.getLastInput = function()
	{
		that.ctatdebug("CTATExpressionMatcher.getLastInput() returns "+lastInput);
		return lastInput;
	};

	/**
	 * @return {boolean}
	 */
	this.isEqualRelation = function()
	{
		that.ctatdebug("CTATExpressionMatcher --> in isEqualRelation");
		return (relation === CTATExpressionMatcher.EQ_RELATION);
	};

	/**
	 * @param {CTATSAI} givenSAI sai for evaluation
	 * @param {CTATVariableTable} vt for evaluation
	 * @return {string} LastResult as a String
	 */
	this.getEvaluatedInput = function(givenSAI, vt)
	{
		that.ctatdebug("CTATExpressionMatcher --> in getEvaluatedInput("+givenSAI+", "+vt+")");
		var inputConv = CTATVariableTable.standardizeType(givenSAI.getInput());
     	var result = that.evaluate(givenSAI.getSelection(), givenSAI.getAction(), inputConv, vt);
		that.ctatdebug("CTATExpressionMatcher.getEvaluatedInput() returns "+result);
		return result;
	};

	/**
	 * This is a String representation of the expression matcher
	 * @return {string}
	 */
	this.toString = function()
	{
		//ctatdebug("CTATExpressionMatcher --> in toString");

		return CTATExpressionMatcher.RELATIONS[relation] + " \"" + expression + "\"";
	};

	/**
	 * The only way to implement this is if we had access to the selection, action, and input vectors originally ...
	 * @param {string} s
	 * @return {boolean}
	 */
	this.matchSingle = function(s)
	{
        //ctatdebug("CTATExpressionMatcher --> in matchSingle: s = " + s + " singleval = " + singleValue);

		throw new CTATExampleTracerException("UnsupportedOperationException");
	};

	/**
	 * @param {string} value
	 * @return {undefined}
	 */
	this.setInputExpression = function(value)
	{
		expression = value;
	};

	/**
	 * @param {string} value
	 * @return {undefined}
	 */
	this.setRelation = function(value)
	{
		relation = value;
	};

	/**
	 * @return Object
	 * @param {String} expression
	 * @param {String} selection
	 * @param {String} action
	 * @param {String} input
	 * @return {Object}
	 */
	this.interpolate = function(expression, selection, action, input)
	{
		try
		{
			var vt = new CTATVariableTable();
			var tempfunc = new CTATFormulaParser(vt);
			return tempfunc.interpolate(expression, selection, action, input);
		}
		catch(e)
		{
			//ctatdebug("CTATExpressionMatcher --> e.name + ': ' + e.message);
			lastError = e.message;
			return null;
		}

	};

    /**
     * @param {String} selection student's selection
     * @param {String} action student's action
     * @param {String} input student's input
     * @param {CTATVariableTable} vt if !null then given interp's vt, otherwise problem model(bestinterp)'s vt/
     * @return {Object} string, double, int, etc., that corresponds to the parsed version of either
     * the students selection action or input in the context of the interp's VT.
     */
	this.evaluate = function(selection, action, input, vt)
	{
		if(typeof(vt) == 'undefined' || vt == null)
			vt = new CTATVariableTable();

		that.ctatdebug("CTATExpressionMatcher.evaluate(..., vt="+vt+") creating CTATFormulaParser");
		var tempfunc = new CTATFormulaParser(vt);  //of type CTATFormulaParser

		that.ctatdebug("calling CTATFormulaParser.evaluate("+that.getInputExpression()+", "+selection+", "+action+", "+input+")");

		try
		{
			var funcRtn = tempfunc.evaluate(that.getInputExpression(), selection, action, input);
			return funcRtn;
		}
		catch(e)
		{
			that.ctatdebug("CTATExpressionMatcher --> "+e.name+": "+e.message);
			lastError = e.message;
			return null;
		}
	};

	/**
	 * @param {Array} s
	 * @param {Array} a
	 * @param {Array} i
	 * @param {CTATVariableTable} vt
	 * @return {boolean}
	 */
	this.matchConcatenation = function(s, a, i, vt)
	{
		var sel = that.array2ConcatString(s);

		//covers the function overloaded with boolean as parmeter case
		if(a === null || typeof(a) === 'undefined' || i === null || typeof(i) === 'undefined')
		{
			lastComparison = testVector(sel, null, null, vector, vt);
		}
		else
		{
			var act = that.array2ConcatString(a);
			var inp = that.array2ConcatString(i);
			lastComparison = testVector(sel, act, inp, vector, vt);
		}

		return lastComparison;
	};

	/**
	 * @param {array} selection
	 * @param {Array} action
	 * @param {array} input
	 * @param {string} actor
	 * @param {CTATVariableTable} vt
	 * @return {boolean}
	 */
	this.match = function(selection, action, input, actor, vt)
	{
		return that.matchConcatenation(selection, action, input, vt);
	};

	/**
	 * return {String}
	 */
	this.getInputExpression = function()
	{
		return expression;
	};
/****************************** CONSTRUCTOR METHODS ****************************************************/

	//method called as part of the constructor
	initExpression();
};

/**************************** CONSTANTS ******************************************************/

/**
 *
 */
Object.defineProperty(CTATExpressionMatcher, "EQ_RELATION", {enumerable: false, configurable: false, writable: false, value: 0});
Object.defineProperty(CTATExpressionMatcher, "LT_RELATION", {enumerable: false, configurable: false, writable: false, value: 1});
Object.defineProperty(CTATExpressionMatcher, "GT_RELATION", {enumerable: false, configurable: false, writable: false, value: 2});
Object.defineProperty(CTATExpressionMatcher, "NOT_EQ_RELATION", {enumerable: false, configurable: false, writable: false, value: 3});
Object.defineProperty(CTATExpressionMatcher, "GTE_RELATION", {enumerable: false, configurable: false, writable: false, value: 4});
Object.defineProperty(CTATExpressionMatcher, "LTE_RELATION", {enumerable: false, configurable: false, writable: false, value: 5});
Object.defineProperty(CTATExpressionMatcher, "BOOL_RELATION", {enumerable: false, configurable: false, writable: false, value: 6});

/**
 *
 */
Object.defineProperty(CTATExpressionMatcher, "RELATIONS", {enumerable: false, configurable: false, writable: false, value: ["=", "<", ">", "!=", ">=", "<=", "boolean"]});

/**
 * Find a relation name in RELATIONS and return the proper integer EQ_RELATION, BOOL_RELATION, etc.
 * @param {string} relationName entry in RELATIONS
 * @return {integer} one of EQ_RELATION, BOOL_RELATION, etc.; returns EQ_RELATION if no match
 */
CTATExpressionMatcher.nameToRelation = function(relationName)
{
	for(var i = 0; i < CTATExpressionMatcher.RELATIONS.length; i++)
	{
		if(relationName == CTATExpressionMatcher.RELATIONS[i])
			return i;
	}
	return CTATExpressionMatcher.EQ_RELATION;  // default
};

//setting up inheritance
CTATExpressionMatcher.prototype = Object.create(CTATSingleMatcher.prototype);
CTATExpressionMatcher.prototype.constructor = CTATExpressionMatcher;

/**
 * Set the expression or relation from a matcherParameter element in the .brd file.
 * @param {string} paramName parameter name
 * @param {Element} paramElement matcherParameter element
 * @param {object} parser XML parser for extracting paramElement data
 */
CTATExpressionMatcher.prototype.setParameter = function(paramElement, paramName, parser)
{
	if(paramElement && paramName && parser)
	{
		var value = parser.getNodeTextValue(paramElement);
		this.ctatdebug("CTATExpressionMatcher.setParameter("+paramName+", "+value+")");
		if(paramName == "InputExpression")
			this.setInputExpression(value);
		else if(paramName == "relation")
			this.setRelation(CTATExpressionMatcher.nameToRelation(value));
	}
};

/**
 * Compare input with expected first as numbers, if both can be converted; else as strings.
 * For the greater-than and less-than operators, compare without regard to case, to
 * avoid sorting all upper-case before any lower-case (else "Susan" < "ask").
 * @param {string} input assumed to be not null
 * @param expected result from formula; could be any type, but assumed to be not null
 * @param {number} relop one of the CTATExpressionMatcher.XX_RELATION constants
 * @return true if (input relop expected) is true; else false
 */
CTATExpressionMatcher.prototype.compareNumberOrString = function(input, expected, relop)
{
	input = String(input);
	expected = String(expected);
    var inputN = Number(input), expectedN = Number(expected);
	if(!isNaN(inputN) && !isNaN(expectedN))            // both operands are numbers, so compare as numbers
	{
		switch(relop)
		{
			case CTATExpressionMatcher.EQ_RELATION:
				return inputN == expectedN;
			case CTATExpressionMatcher.NOT_EQ_RELATION:
				return inputN != expectedN;
			case CTATExpressionMatcher.LT_RELATION:
				return inputN <  expectedN;
			case CTATExpressionMatcher.GT_RELATION:
				return inputN >  expectedN;
			case CTATExpressionMatcher.LTE_RELATION:
				return inputN <= expectedN;
			case CTATExpressionMatcher.GTE_RELATION:
				return inputN >= expectedN;
			case CTATExpressionMatcher.BOOL_RELATION:
				return Boolean(expectedN);
			default:
				//console.log("CTATExpressionMatcher.compareNumberOrString() called with relop["+relop+"] "+CTATExpressionMatcher.RELATIONS[relop]);
				return false;
		}
	} else {                                           // at least one operand is not a number
		switch(relop)
		{
			case CTATExpressionMatcher.EQ_RELATION:
				return input == expected;
			case CTATExpressionMatcher.NOT_EQ_RELATION:
				return input != expected;
			case CTATExpressionMatcher.LT_RELATION:                    // avoid sorting all upper-case before any lower-case
				return input.toLowerCase() <  expected.toLowerCase();
			case CTATExpressionMatcher.GT_RELATION:
				return input.toLowerCase() >  expected.toLowerCase();
			case CTATExpressionMatcher.LTE_RELATION:
				return input.toLowerCase() <= expected.toLowerCase();
			case CTATExpressionMatcher.GTE_RELATION:
				return input.toLowerCase() >= expected.toLowerCase();
			case CTATExpressionMatcher.BOOL_RELATION:
				return Boolean(expected);
			default:
				//console.log("CTATExpressionMatcher.compareNumberOrString() called with relop["+relop+"] "+CTATExpressionMatcher.RELATIONS[relop]);
				return false;
		}
	}
};

if(typeof module !== 'undefined')
{
	module.exports = CTATExpressionMatcher;
}