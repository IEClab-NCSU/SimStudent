/* This object represents matcher for an individual selection, action or input element. */

goog.provide('CTATSingleMatcher');
goog.require('CTATBase');
goog.require('CTATMsgType');
goog.require('CTATMatcher');
goog.require('CTATVariableTable');
goog.require('CTATFormulaParser');

/**
 * @param {boolean} givenSingle
 * @param {integer} givenVector
 * @param {boolean} givenCaseInsensitive
 */
CTATSingleMatcher = function(givenVector, givenCaseInsensitive)
{

/**************************** INHERITED CONSTRUCTOR ******************************************************/

	CTATMatcher.call(this, true, givenVector, givenCaseInsensitive);

/**************************** PRIVATE INSTANCE VARIABLES ******************************************************/

	var that = this;  // stable self-reference

	var singleValue = "";  // the value to test against

	var replacementFormula = "";  // evaluate this formula if using replace input

/**************************** PRIVILEGED METHODS ******************************************************/

    /**
     * @return {string} singleValue
     */
	this.getSingle = function(text)
	{
		return singleValue;
	};

    /**
     * Stores the expected value.
     * @return {undefined}
     */
	this.setSingle = function(text)
	{
		if(text === null || typeof(text) === 'undefined')
		{
			that.ctatdebug("CTATSingleMatcher --> bad argument \""+text+"\" to setSingle()");
			return;
		}
		singleValue = text;
	};

	this.toString = function()
	{
		console.log("Error: CTATSingleMatcher.toString() called: should be overridden");
	};

	/**
	 * This superclass always returns false.
	 * @param {string} singleStr
	 * @return boolean
	 */
	this.matchSingle = function(singleStr)
	{
		console.log("Error: CTATSingleMatcher.matchSingle("+singleStr+") called: should be overridden");
		return false;
	};

	/**
	 * @return {string} replacementFormula
	 */
	this.getReplacementFormula = function()
	{
		return replacementFormula;
	};

	/**
	 * @param {string} givenReplacementFormula new value for replacementFormula; sets "" if null
	 */
	this.setReplacementFormula = function(givenReplacementFormula)
	{
		replacementFormula = (givenReplacementFormula ? givenReplacementFormula : "");
	};

	/**
	 * Execute a replace-input-with formula and return its result.
	 * @param {CTATSAI} sai
	 * @param {CTATVariableTable} vt
	 * @param {CTATExampleTracerTracer} tracer
	 * @return {string} result from input matcher's evaluateReplacement method
	 */
	this.evaluateReplacement = function(sai, vt, tracer)
	{
		var result = null;
		if(!Boolean(replacementFormula))
		{
			return result;
		}
		that.ctatdebug("CTATSingleMatcher.evaluateReplacement("+sai+", "+vt+")");
		var s = sai.getSelection();
		var a = sai.getAction();
		var i = CTATVariableTable.standardizeType(sai.getInput());
		if(!vt)
		{
			vt = new CTATVariableTable();
		}
		var tempfunc = new CTATFormulaParser(vt);  //of type CTATFormulaParser

		that.ctatdebug("CTATSingleMatcher calling CTATFormulaParser.evaluate("+replacementFormula+", "+s+", "+a+", "+i+")");
		try
		{
			result = tempfunc.evaluate(replacementFormula, s, a, i);
		}
		catch(e)
		{
			that.ctatdebug("CTATSingleMatcher error from CTATFormulaParser.evaluate("+replacementFormula+") "+e.name+": "+e.message);
			result = null;
		}
		that.ctatdebug("CTATSingleMatcher.evaluateReplacement() returns "+result+", type "+typeof(result));
		return result;
	};
};

/**************************** SETTING UP INHERITANCE ******************************************************/

CTATSingleMatcher.prototype = Object.create(CTATMatcher.prototype);
CTATSingleMatcher.prototype.constructor = CTATSingleMatcher;

/**
 * @param singleArray (of type array)
 * @return boolean
 */
CTATSingleMatcher.prototype.matchConcatenation = function(singleArray)
{
	var singleConcat = this.array2ConcatString(singleArray);
	return this.matchSingle(singleConcat);
};

/**
 * @param singleArray (of type array)
 * @param action (of type array) ignored in this superclass implementation
 * @param input (of type array) ignored in this superclass implementation
 * @param actor (of type string) ignored in this superclass implementation
 * @return boolean
 */
CTATSingleMatcher.prototype.match = function(singleArray, action, input, actor)
{
	return this.matchConcatenation(singleArray);
};

/**
 * @param {string} expectedValue the expected value to match
 * @param {string} paramName optional name of the parameter to set
 */
CTATSingleMatcher.prototype.setParameter = function(expectedValue, paramName, parser)
{
	this.ctatdebug("CTATSingleMatcher.setParameter("+expectedValue+", "+paramName+", "+parser+") calling\n  "+this.setSingle.toString());
	this.setSingle(expectedValue);
};

if(typeof module !== 'undefined')
{
	module.exports = CTATSingleMatcher;
}
