/**
 * @fileoverview Adds common graphical and style handling to CTAT components.
 * Child objects of the component should reference the values in this when
 * getting constructed.
 *
 * The key methods added by this are setStyleHandler and setParameterHandler.
 * These methods should be used to set the function that will handle a given
 * style or parameter from the CTATComponentDescription.  For example, to add
 * or replace the handler for "DrawBorder" if the child component handles
 * borders itself like CTAT.Component.Hierarchy.SVG does, then something like
 * the following should be added:
 * this.setStyleHandler('DrawBorder',function(bool){...});
 * or
 * this.setStyleHandler('DrawBorder',this.setDrawBorder);
 * Note: the first parameter should match the name of the style in the brd and
 * the second parameter should be a function.
 *
 * @author $Author$
 * @version $Revision$
 */
/*
 * $Date$
 * $HeadURL$
 */
goog.provide('CTAT.Component.Base.Graphical');

goog.require('CTAT.Component.Base.Style');
goog.require('CTATComponentDescription');
goog.require('CTATGlobals');
goog.require('CTATGlobalFunctions');

CTAT.Component.Base.Graphical = function(aClassName,
		aName,
		aDescription,
		aX,
		aY,
		aWidth,
		aHeight) {
	CTAT.Component.Base.Style.call(this, aClassName,
			aName,
			//aDescription,
			aX,
			aY,
			aWidth,
			aHeight);
	var grDescription=aDescription || (new CTATComponentDescription()).setGenericDefaults();
	this.getGrDescription=function getGrDescription() {	return grDescription; };
	this.setGrDescription=function setGrDescription(aGrDescription)	{
		grDescription=aGrDescription;
		this.processDescription(grDescription);
	};

	/*----- Styles -----*/
	var border={}, font={};
	/**
	 * Gets the alignment setting
	 * @returns {String} an alignment
	 */
	this.getAlign = function() {
		if (this.component) {
			return $(this.component).css('text-align');
		}
		return $(this.getDivWrap()).css('text-align');
	};
	/**
	 * Sets the alignment
	 * @param {String} alignment	an alignment (eg) "left", "right", "center", etc.
	 */
	this.setAlign = function(alignment) {
		if (this.component) {
			this.component.style.textAlign = alignment;
		}
		return this;
	};
	
	this.getBackgroundColor = function()
	{
		return $(this.getComponent()).css('background-color');
	};

	/**
	 * Sets the background color.
	 * @param {String} color	a color, see @see CTATGlobalFunctions#formatColor for acceptable strings.
	 */
	this.setBackgroundColor = function (color) {
		color = color?CTATGlobalFunctions.formatColor(color):null;
		if (this.component)
			this.component.style.backgroundColor = color;
		return this;
	};

	/** @deprecated */
	this.setDisabledBGColor = function(color) { // Ignore, use CSS.
		//background.color_disabled = CTATGlobalFunctions.formatColor(color);
		return this;
	};

	/**
	 * Set the disabled text color setting.
	 * @param {String} a color.
	 * @deprecated
	 */
	this.setDisabledTextColor = function(color) { // Ignore and use CSS
		//font.disabled_color = CTATGlobalFunctions.formatColor(color);
		return this;
	};
	
	this.getBorderColor = function()
	{
		return $(this.getComponent()).css('border-color');
	}
	
	this.setBorderColor = function(color) {
		color = CTATGlobalFunctions.formatColor(color);
		if (this.getComponent()) {
			$(this.getComponent()).css('border-color', color);
		} else {
			this.getDivWrap().style.borderColor = color;
		}
		return this;
	};

	this.getBorderRoundness = function()
	{
		return $(this.getComponent()).css('border-radius');
	}
	
	this.setBorderRoundness = function(radius) {
		radius = parseInt(radius, 10);
		if (!isNaN(radius))
		{
			border.roundness = radius;
		}
		else
		{
			border.roundness = 0;
			radius = 0;
		}
		radius = radius+'px';
		if (this.component && this.getBorderRoundness()!==radius) 
		{
			$(this.component).css('border-radius', radius);
			this.component.style.borderRadius = border.roundness;
		}
		return this;
	};

	this.getBorderStyle = function()
	{
		return $(this.getComponent()).css('borderStyle');
	}
	/**
	 * Set the border style setting.
	 * @param {String} a line style
	 */
	this.setBorderStyle = function(aStyle) {
		if (this.component)
			this.component.style.borderStyle = aStyle;
		return this;
	};

	/**
	 * @returns {Number|String}
	 */
	this.getBorderWidth = function() {
		if (this.getComponent()) {
			return $(this.getComponent()).css('borderWidth'); // TODO: deal with top,bottom,left,right as some browsers only store them separately
			//$(this.component).css(['borderTopWidth','borderRightWidth','borderLeftWidth','borderBottomWidth']);
			//var cstyle = window.getComputedStyle(this.component);
			//return cstyle.getPropertyValue('borderWidth');
		}
		return border.width;
	};
	this.setBorderWidth = function(width) {
		border.width = width;
		var regex = /(\d*(px)? ?){1,3}(\d*(px)? ?)?/;
		var isValid = regex.test(width);
		if (!isValid)
		{	
			width = '0px';
			console.log("invalid width string");
		}
		if (this.component && this.getBorderWidth()!==width)
			$(this.component).css('borderWidth', width);
		return this;
	};

	this.setPadding = function(newWidth) {
		var padding = parseInt(newWidth);
		if (isNaN(padding)) padding = 0;
		if (this.component) {
			this.component.style.padding = padding+'px';
		}
		return this;
	};
	/**
	 * Set the font color setting.
	 * @param {String} a color.
	 */
	this.getFontColor = function() {
		if (this.component) {
			return $(this.component).css('color');
			//var cstyle = window.getComputedStyle(this.component);
			//return cstyle.getPropertyValue('color');
			//var cstyle = window.getComputedStyle(this.component);
			//return cstyle.getPropertyValue('color');
		}
	};
	this.setFontColor = function(color) {
		console.log('setFontColor( )');
		font.color = CTATGlobalFunctions.formatColor(color);
		if (this.component)
		{
			console.log('got comp');
			if (this.getFontColor()!==font.color) {
				$(this.component).css('color', font.color);
			}
		}
		//this.modifyCSSAttribute("color",font.color);
		return font.color;
	};

	/**
	 * Sets the font family setting.
	 * @param {String} a font name.
	 */
	this.setFontFamily = function(family) {
		if (this.component) {
			this.component.style.fontFamily = family;
		}
		return this;
	};
	
	this.getFontFamily = function()
	{
		if (this.component)
			return this.component.style.fontFamily;
		console.warn('component not found');
		return null;
	}

	/**
	 * Sets the font size.
	 * @param {Number} the size of the font.
	 */
	this.setFontSize = function(size) {
		var s = parseInt(size); // conversion code does not append units and as3 assumed pt
		if (!isNaN(s)) {
			font.size = s;
			if (this.component)
				this.component.style.fontSize = s+'pt';
		} else {
			this.component.style.fontSize = null;
		}
		return this;
	};

	this.setShowBorder = function(p_show) {
		p_show = CTATGlobalFunctions.toBoolean(p_show);
		if (this.component) {
			if (p_show) {
				this.setBorderStyle('solid');
				//this.setBorderWidth('1px');
			} else {
				this.setBorderStyle('none');
			}
		}
		return this;
	};

	/**
	 * Gets the setting for underlining text.
	 * @returns {Boolean}
	 */
	this.setUnderlined = function(p_under) {
		p_underlined = CTATGlobalFunctions.toBoolean(p_under);
		if (this.component) {
			if (p_underlined)
				this.component.style.textDecoration = "underline";
			else
				this.component.style.textDecoration = null;
		}
		return this;
	};
	/**
	 * Gets the setting for bolding text.
	 */
	this.setBolded = function(p_bold) {
		p_bold = CTATGlobalFunctions.stringToBoolean(p_bold);
		if (this.component) {
			if (p_bold)
				this.component.style.fontWeight = "bold";
			else
				this.component.style.fontWeight = null;
		}
		return this;
	};
	this.setItalicized = function(p_italicized) {
		p_italicized = CTATGlobalFunctions.toBoolean(p_italicized);
		if (this.component) {
			if (font.italicized)
				this.component.style.fontStyle = "italic";
			else
				this.component.style.fontStyle = null;
		}
		return this;
	};

	var pointer = this;
	var makeHandlerCollection = function(map_object) {
		var handlers = map_object || {};
		return {
			setHandler: function(name,handler) { handlers[name]=handler; },
			set: function(name) {
				if (handlers.hasOwnProperty(name)) {
					if (handlers[name]) {
						var args = Array.prototype.slice.call(arguments, 1);
						return handlers[name].apply(pointer, args);
					} else {
						pointer.ctatdebug("Error: NULL handler for "+name);
					}
				} else {
					pointer.ctatdebug("Error: No handler set for "+name);
				}
			},
		};
	};

	this.style_handlers = makeHandlerCollection({
			'BackgroundColor': this.setBackgroundColor,
			'BorderColor': this.setBorderColor,
			'borderRoundness': this.setBorderRoundness,
			//'disabledBackgroundColor': this.setDisabledBGColor,
			//'disabledTextColor': this.setDisabledTextColor,
			'DrawBorder': this.setShowBorder,
			'FontFace': this.setFontFamily,
			'FontSize': this.setFontSize,
			'FontBold': this.setBolded,
			'FontItalic': this.setItalicized,
			'FontUnderlined': this.setUnderlined,
			'labelText': this.setText,
			'padding': this.setPadding,
			'showBorder': this.setShowBorder,
			'TextAlign': this.setAlign,
			'TextColor': this.setFontColor,
			//'transparencyValue': this.setTransparencyValue,
	});

	this.setStyle = function(styleName,styleValue) {
		this.style_handlers.set(styleName,styleValue);
	};
	this.setStyleHandler = function(styleName,styleHandler) {
		this.style_handlers.setHandler(styleName,styleHandler);
	};

	/*----- Parameters -----*/
	this.parameter_handlers = makeHandlerCollection({
		//"ShowHintHighlight": this.setShowHintHighlight,
		//"DisableOnCorrect": this.setDisableOnCorrect, // in CTAT.Component.Base.Tutorable
		"group": this.setComponentGroup,
	});
	this.setParameter = function(paramName,paramValue) {
		this.parameter_handlers.set(paramName,paramValue);
	};
	this.setParameterHandler = function(paramName,paramHandler) {
		this.parameter_handlers.setHandler(paramName,paramHandler);
	};

	/*----- Attributes -----*/
	this.data_ctat_handlers = {};

	this.processAttributes = function() {
		// get parameters from data-ctat-* html options
		// check these first so that options from sui will take precedence
		//console.trace('Checking data-ctat');

		if (this.getDivWrap()) {
			var $div = $(this.getDivWrap());

			// Check for special attributes, like tabindex
			var tabindex = parseInt($div.attr('tabindex'), 10) || parseInt($div.attr('data-ctat-tabindex'), 10);
			if (!isNaN(tabindex)) {
				// move tabindex to child.
				this.setTabIndex(tabindex);
				$div.attr('tabindex',null);
			}
			var name = $div.attr('name');
			if (name!==undefined) {
				this.setComponentGroup(name);
			}

			for (var datum in this.data_ctat_handlers) {
				//console.log('Checking for data-ctat-'+datum);
				var param_value = $div.data("ctat-"+datum);
				//console.log('data-ctat-'+datum+'='+param_value);
				if (param_value!==undefined) {
					//console.trace('data-ctat: '+datum+'('+param_value+')');
					this.data_ctat_handlers[datum].apply(this,[param_value]);
				}
			}
		}
	};
	this.data_ctat_handlers['enabled'] = function (val) {
		this.setEnabled(CTATGlobalFunctions.toBoolean(val));
	};

	this.processParameters = function(myDescription) {
		// to be run before initialization as parameters are often used in
		// component generation.
		if (myDescription) {
			if (myDescription instanceof CTATComponentDescription) {
				pointer.setName(myDescription.name);
				var parameters = myDescription.params;
				for (var paramName in parameters) {
					var paramValue = parameters[paramName];
					this.setParameter(paramName, paramValue);
				}
			} else {
				this.ctatdebug('Error: Invalid description sent to CTAT.Components.Hierarchy.Graphical.processDescription: '+myDescription);
			}
		}
	};
	this.processStyles = function(myDescription) {
		// to be run after initialization so that style information can
		// be applied to the component.
		if (myDescription) {
			if (myDescription instanceof CTATComponentDescription) {
				var styles = myDescription.styles;
				for (var styleName in styles) {
					var styleValue = styles[styleName];
					this.setStyle(styleName, styleValue);
				}
			} else {
				this.ctatdebug('Error: Invalid description sent to CTAT.Components.Hierarchy.Graphical.processDescription: '+myDescription);
			}
		}
	};
	this.processDescription = function(myDescription) {
		this.processParameters(myDescription);
		this.processStyles(myDescription);
	};
	this.configFromDescription = function(){ // override for testing
		this.processParameters(grDescription);
	};
	this.processSerialization = function() {
		this.processStyles(grDescription);
	};

	/**
	 * Add the named class to the div wrapper's class list. This can be used to add CSS styles.
	 * @param {string} className class to add
	 */
	this.addClass = function(className) {
		if(this.getDivWrap() && this.getDivWrap() != null)
		{
			this.getDivWrap().classList.add(className);
		}
	};

	/**
	 * Remove the named class from the div wrapper's class list. This can be used to remove CSS styles.
	 * @param {string} className class to remove
	 */
	this.removeClass = function(className) {
		if(this.getDivWrap() && this.getDivWrap().classList != null)
		{
			this.getDivWrap().classList.remove(className);
		}
	};
};

CTAT.Component.Base.Graphical.prototype = Object.create(CTAT.Component.Base.Style.prototype);
CTAT.Component.Base.Graphical.prototype.constructor = CTAT.Component.Base.Graphical;
