/**-----------------------------------------------------------------------------
 $Author$
 $Date$
 $HeadURL$
 $Revision$

 -
 License:
 -
 ChangeLog:
 -
 Notes:

 */
goog.provide('CTATMessageHandler');

goog.require('CTATBase');
goog.require('CTATComponentDescription');
goog.require('CTATConfig');
goog.require('CTATGlobals');
goog.require('CTATHTMLManager');
goog.require('CTATJSON');
goog.require('CTATLMS');
goog.require('CTATMessage');
//goog.require('CTATParameter');
goog.require('CTATSAI');
goog.require('CTATShellTools');
goog.require('CTATSkillSet');
//goog.require('CTATStyle');
goog.require('CTATXML');
goog.require('CTATTutoringServiceMessageBuilder');

/**
 * @param {CTATCommShell} send as parameter instead of using global or circular requires.
 */
CTATMessageHandler = function(commShell)
{
	CTATBase.call(this, "CTATMessageHandler", "messagehandler");

	var messageHandler=null;
	var pointer = this;

	var startStateMessages=[];
	//var inStartState=false;

	var messageParser=null;

	/** To count the number of InterfaceReboot messages received. */
	var nInterfaceReboots = 0;

	if (CTATConfig.parserType_is_XML())
	{
		messageParser=new CTATXML ();
	}
	else
	{
		messageParser=new CTATJSON ();
	}

	/**
	 *
	 */
	this.assignHandler=function assignHandler (aHandler)
	{
		pointer.ctatdebug ("assignHandler ()");

		messageHandler=aHandler;
	};
	/**
	 *
	 */
	this.reset=function reset ()
	{
		pointer.ctatdebug ("reset ()");

		startStateMessages=[];
	};
	/**
	 *
	 */
	this.getInStartState=function getInStartState ()
	{
		return (CTATMessageHandler.inStartState);
	};
	/**
	 * http://api.jquery.com/category/traversing/
	 * http://www.w3schools.com/dom/dom_nodes_traverse.asp
	 */
	var disableComms=false;

	this.receiveFromTutor=function receiveFromTutor (aMessage)
	{
		this.processMessage (aMessage);
	};

	this.processMessage=function processMessage (aMessage)
	{
		//useDebugging=true;
		pointer.ctatdebug ("Incoming message: " + aMessage);
		//useDebugging=false;

		//pointer.ctatdebug ("processMessage ("+lastMessage+")");

		if (disableComms===true)
		{
			return;
		}

		if (CTATConfig.parserType_is_JSON())
		{
			if (aMessage.indexOf ("<?xml")!=-1)
			{
				alert ("Error: CTAT is configured to parse JSON but it received an XML message, disabling comm capabilities ...");
				disableComms=true;
				return;
			}
		}

		if (CTATConfig.parserType_is_XML())
		{
			if (aMessage.indexOf ("{")===0)
			{
				alert ("Error: CTAT is configured to parse XML but it received a JSON message, disabling comm capabilities ...");
				disableComms=true;
				return;
			}
		}

		var docRoot=null;

		pointer.ctatdebug ("Attempting parse ...");

		//ctatdebug (aMessage);

		docRoot=messageParser.parse (aMessage);

		if (docRoot===null)
		{
			pointer.ctatdebug ("Error parsing message: "+aMessage);
			return;
		}

		//useDebugging=true;

		this.parseElement (docRoot);

		//useDebugging=false;
	};
	/**
	 *
	 */
	this.parseElement=function parseElement (anElement)
	{
		var aName=messageParser.getElementName (anElement); // slight optimization

		pointer.ctatdebug ("parseElement ("+aName+")");

		if ((aName=="CTATResponseMessages") || (aName=="StartStateMessages") || (aName=="MessageBundle"))
		{
			this.processMessageBundle (anElement);
		}

		if (aName=="message")
		{
			this.processSingleMessage (anElement);
		}
	};
	/**
	 *
	 */
	this.processMessageBundle=function processMessageBundle (anElement)
	{
		var aName=messageParser.getElementName (anElement); // slight optimization

		pointer.ctatdebug ("processMessageBundle ("+aName+")");

		var list=messageParser.getElementChildren (anElement);

		if (list===null)
		{
			pointer.ctatdebug ("Error parsing bundle");
			return;
		}

		ctatdebug ("Processing " + list.length + " objects in bundle");

		for (var i=0;i<list.length;i++)
		{
			this.parseElement (list [i]);

			/*
			if (i==2)
			{
				return;
			}
			*/
		}
	};
	/**
	 *
	 */
	this.processSingleMessage=function processSingleMessage (anElement)
	{
		pointer.ctatdebug ("processSingleMessage ("+messageParser.getElementName (anElement)+")");

		var aMessage=new CTATMessage (anElement);
		var actor = aMessage.getProperty("subtype");
		actor = ((!actor || /tutor/i.test(actor)) ? "tutor" : actor);

		var x=messageParser.getElementChildren (anElement);

		pointer.ctatdebug ("Generated CTATMessage, now doing regular processing ...");

		for (var i=0;i<x.length;i++)
		{
			var tempElement=x [i];

			if (messageParser.getElementName (tempElement)=='properties')
			{
				pointer.ctatdebug ("Parsing properties ...");

				var messageProperties=messageParser.getElementChildren (tempElement);

				for (var t=0;t<messageProperties.length;t++)
				{
					var propNode=messageProperties [t];

					if (messageParser.getElementName (propNode)=="MessageType")
					{
						var nodeValue=messageParser.getNodeTextValue (propNode);

						//useDebugging=true;
						pointer.ctatdebug ("MessageType: " + nodeValue);
						//useDebugging=false;

						if (nodeValue=="StateGraph")
						{
							// This is a temporary patch for a bug in the Java tracer which doesn't always send a StartProblem message
							ctatdebug ("Setting inStartState to true");
							CTATMessageHandler.inStartState=true;
							commShell.setGotProblemRestoreEnd(false);

							this.processStateGraph (tempElement);

							commShell.propagateShellEvent ("StateGraph",aMessage);
						}

						if (nodeValue=="StartProblem")
						{
							pointer.ctatdebug ("Setting inStartState to true");

							CTATMessageHandler.inStartState=true;
							commShell.setGotProblemRestoreEnd(false);

							this.processStartProblem (messageProperties);

							commShell.propagateShellEvent ("StartProblem",aMessage);
						}

						if (nodeValue=="InterfaceIdentification")
						{
							this.processInterfaceIdentification (messageProperties);

							commShell.propagateShellEvent ("InterfaceIdentification",aMessage);
						}

						if (nodeValue=="InterfaceDescription")
						{
							this.processInterfaceDescription (messageProperties);

							commShell.propagateShellEvent ("InterfaceDescription",aMessage);
						}

						if (nodeValue=="GetAllInterfaceDescriptions")
						{
							//commLibrary.sendXML ((new CTATTutoringServiceMessageBuilder()).createInterfaceDescriptionMessage());

							commShell.getAllInterfaceDescriptions ();

							commShell.propagateShellEvent ("GetAllInterfaceDescriptions",aMessage);
						}

						if (nodeValue=="SendWidgetLock")
						{
							pointer.ctatdebug ("Found: SendWidgetLock");

							if (this.getInStartState()===true)
							{
								startStateMessages.push (aMessage);
							}

							commShell.propagateShellEvent ("SendWidgetLock",aMessage);
						}

						if (nodeValue=="CorrectAction")
						{
							//useDebugging=true;

							pointer.ctatdebug ("Found: CorrectAction");

							if (this.getInStartState()===true)
							{
								startStateMessages.push (aMessage);
							}
							else
							{
								messageHandler.processCorrectAction (aMessage);
							}

							//useDebugging=false;

							commShell.propagateShellEvent ("CorrectAction",aMessage);
						}

						if (nodeValue=="InCorrectAction")
						{
							//useDebugging=true;

							pointer.ctatdebug ("Found: InCorrectAction");

							if (CTATMessageHandler.inStartState===true)
							{
								startStateMessages.push (aMessage);
							}
							else
							{
								pointer.ctatdebug ("Handing incorrect message to messagehandler ...");

								messageHandler.processInCorrectAction (aMessage);
							}

							commShell.propagateShellEvent ("InCorrectAction",aMessage);

							//useDebugging=false;
						}

						if (nodeValue=="HighlightMsg")
						{
							pointer.ctatdebug ("Found: HighlightMsg");

							messageHandler.processHighlightMsg (aMessage);

							commShell.propagateShellEvent ("HighlightMsg",aMessage);
						}

						if (nodeValue=="UnHighlightMsg")
						{
							pointer.ctatdebug ("Found: UnHighlightMsg");

							messageHandler.processUnHighlightMsg (aMessage);

							commShell.propagateShellEvent ("UnHighlightMsg",aMessage);
						}

						if (nodeValue=="AssociatedRules")
						{
							//useDebugging=true;

							pointer.ctatdebug ("Found: AssociatedRules ("+messageProperties.length+")");

							var advice="";
							var indicator="";
							var stepID="";
							var logAsResult="";
							var toolSelection="";

							for (var k=0;k<messageProperties.length;k++)
							{
								var testNode=messageProperties [k];

								//pointer.ctatdebug ("testNode:" + testNode.nodeName);

								if (messageParser.getElementName (testNode)=="TutorAdvice")
								{
									advice=messageParser.getNodeTextValue (testNode);
								}

								if (messageParser.getElementName (testNode)=="Actor")
								{
									actor=messageParser.getNodeTextValue (testNode);
								}

								if (messageParser.getElementName (testNode)=="Indicator")
								{
									indicator=messageParser.getNodeTextValue (testNode);
								}

								if (messageParser.getElementName (testNode)=="StepID")
								{
									stepID=messageParser.getNodeTextValue (testNode);
								}

								if (messageParser.getElementName (testNode)=="LogAsResult")
								{
									logAsResult=messageParser.getNodeTextValue (testNode);
								}

								if (messageParser.getElementName (testNode)=="tool_selection")
								{
									toolSelection=messageParser.getNodeTextValue (testNode);
								}

								if (messageParser.getElementName (testNode)=="Skills")
								{
									pointer.ctatdebug ("Processing skills ...");

									if (CTATSkillSet.skills===null)
									{
										pointer.ctatdebug ("Interesting, there isn't a skillSet object yet. Creating ...");
										CTATSkillSet.skills=new CTATSkillSet ();
									}

									CTATSkillSet.skills.parseByValue(testNode);
								}
							}

							messageHandler.processAssociatedRules (aMessage,indicator,advice);

							commShell.propagateShellEvent ("AssociatedRules",aMessage);

							//useDebugging=false;
						}

						if (nodeValue=="BuggyMessage")
						{
							pointer.ctatdebug ("Found: BuggyMessage");

							messageHandler.processBuggyMessage (aMessage);

							commShell.propagateShellEvent ("BuggyMessage",aMessage);
						}

						if (nodeValue=="SuccessMessage")
						{
							pointer.ctatdebug ("Found: SuccessMessage");

							messageHandler.processSuccessMessage (aMessage);

							commShell.propagateShellEvent ("SuccessMessage",aMessage);
						}

						if (nodeValue.indexOf ("InterfaceAction")!=-1)
						{
							pointer.ctatdebug ("Found: InterfaceAction");
						    
							var testSAI=aMessage.getSAI();

							if (testSAI.getAction ().indexOf (":")!=-1)
							{
								pointer.ctatdebug ("Processing and storing timed interface action : " + testSAI.getAction ());

								var targetTime=parseInt (testSAI.getAction ().substring (testSAI.getAction ().indexOf (":")+1));

								pointer.ctatdebug ("Target time: " + targetTime);

								testSAI.setAction (testSAI.getAction ().substring (0,testSAI.getAction ().indexOf (":")));

								pointer.ctatdebug ("Timing ...");

								setTimeout (messageHandler.processInterfaceAction,targetTime,aMessage);
								setTimeout (commShell.propagateShellEvent,targetTime,"InterfaceAction",aMessage,actor);
							}
							else
							{
								pointer.ctatdebug ("Processing regular (non-timed) interface action");

								if (CTATMessageHandler.inStartState===true)
								{
									pointer.ctatdebug ("inStartState==true => storing for later playback ...");

									startStateMessages.push (aMessage);
								}
								else
								{
									messageHandler.processInterfaceAction (aMessage);
									commShell.propagateShellEvent ("InterfaceAction",aMessage,actor);
								}

							}
						}

						if (nodeValue.indexOf ("UntutoredAction")!=-1)
						{
							pointer.ctatdebug ("Found: UntutoredAction");
						    
							var testSAI=aMessage.getSAI();

							if (testSAI.getAction ().indexOf (":")!=-1)
							{
								pointer.ctatdebug ("Processing and storing timed interface action : " + testSAI.getAction ());

								var targetTime=parseInt (testSAI.getAction ().substring (testSAI.getAction ().indexOf (":")+1));

								pointer.ctatdebug ("Target time: " + targetTime);

								testSAI.setAction (testSAI.getAction ().substring (0,testSAI.getAction ().indexOf (":")));

								pointer.ctatdebug ("Timing ...");

								setTimeout (messageHandler.processUntutoredAction,targetTime,aMessage);
								setTimeout (commShell.propagateShellEvent,targetTime,"UntutoredAction",aMessage,actor);
							}
							else
							{
								pointer.ctatdebug ("Processing regular (non-timed) interface action");

								if (CTATMessageHandler.inStartState===true)
								{
									pointer.ctatdebug ("inStartState==true => storing for later playback ...");

									startStateMessages.push (aMessage);
								}
								else
								{
									messageHandler.processUntutoredAction (aMessage);
									commShell.propagateShellEvent ("UntutoredAction",aMessage,actor);
								}

							}
						}

						if (nodeValue=="InterfaceIdentification")
						{
							pointer.ctatdebug ("Found: InterfaceIdentification");

							//messageHandler.processInterfaceIdentification (aMessage);

							commShell.propagateShellEvent ("InterfaceIdentification",aMessage);
						}

						if (nodeValue=="AuthorModeChange")
						{
							pointer.ctatdebug ("Found: AuthorModeChange");

							//messageHandler.processAuthorModeChange (aMessage);

							messageHandler.globalReset ();

							commShell.propagateShellEvent ("AuthorModeChange",aMessage);
						}

						if (nodeValue=="ResetAction")
						{
							pointer.ctatdebug ("Found: ResetAction");

							// For now not implemented

							messageHandler.globalReset ();

							commShell.propagateShellEvent ("ResetAction",aMessage);
						}

						if (nodeValue=="ShowHintsMessage")
						{
							pointer.ctatdebug ("Found: ShowHintsMessage");

							var hintComplete=false;
							var hintArray=[];

							// Extract all the hints from the message and store them in a temporary list

							for (var p=0;p<messageProperties.length;p++)
							{
								var pNode=messageProperties [p];

								if (messageParser.getElementName (pNode)=="HintsMessage")
								{
									var aList=messageParser.getElementChildren (pNode);

									for (var w=0;w<aList.length;w++)
									{
										var hintNode=aList [w];

										if (messageParser.getElementName (hintNode)=="value")
										{
											hintArray.push (messageParser.getNodeTextValue (hintNode));

											hintComplete=true;
										}
									}
								}
							}

							// Call the commshell to handle the message together with the list of hints

							if (hintComplete===true)
							{
								messageHandler.processHintResponse (aMessage,hintArray);
							}
							else
								pointer.ctatdebug ("Error: incomplete hint message received");

							commShell.propagateShellEvent ("ShowHintsMessage",aMessage);

							// All done
						}

						if (nodeValue=="ConfirmDone")
						{
							pointer.ctatdebug ("Found: ConfirmDone");

							messageHandler.processConfirmDone (aMessage);

							commShell.propagateShellEvent ("ConfirmDone",aMessage);
						}

						if (nodeValue=="VersionInfo")
						{
							pointer.ctatdebug ("Found: VersionInfo");

							messageHandler.processVersionInfo (messageProperties);

							commShell.propagateShellEvent ("VersionInfo",aMessage);
						}

						if (nodeValue=="TutoringServiceAlert")
						{
							pointer.ctatdebug ("Found: TutoringServiceAlert");

							messageHandler.processTutoringServiceAlert (messageProperties);

							commShell.propagateShellEvent ("TutoringServiceAlert",aMessage);
						}

						if (nodeValue=="TutoringServiceError")
						{
							var action=aMessage.getProperty("Action");
							pointer.ctatdebug ("Found: TutoringServiceError - actor "+actor+", action "+action);

							var aParsed;
							if (action && (aParsed = CTATSAI.delayedActionRegExp.exec(action)) && aParsed.length > 2 && aParsed[2] > 1)
							{
								var targetTime=parseInt(aParsed[2]);
								aMessage.setProperty("Action", aParsed[1]);  // remove delay
								pointer.ctatdebug ("Delaying TutoringServiceError by "+targetTime+" ...");
								setTimeout(messageHandler.processTutoringServiceError, targetTime, aMessage);
								setTimeout(commShell.propagateShellEvent, targetTime, "TutoringServiceError", aMessage, actor);
							}
							else
							{
								messageHandler.processTutoringServiceError(aMessage);
								commShell.propagateShellEvent ("TutoringServiceError", aMessage, actor);
							}
						}

						if (nodeValue=="ProblemSummaryResponse")
						{
							pointer.ctatdebug ("Found: ProblemSummaryResponse");

							messageHandler.processProblemSummaryResponse (aMessage);

							commShell.propagateShellEvent ("ProblemSummaryResponse",aMessage);
						}

						if (nodeValue=="StartStateEnd")
						{
							pointer.ctatdebug ("Found: StartStateEnd");

							CTATShellTools.listComponents();

							if (messageHandler!==null)
							{
								messageHandler.processStartState ();
							}
							else
							{
								this.ctatdebug ("Error: no message handler object available to process start state");
							}
							try
							{
								pointer.processStartStateActions ();

							}
							catch (err)
							{
								pointer.ctatdebug ("Caught in the act: " + err.message);
							}

							CTATMessageHandler.inStartState=false;  // undo Trac #718 fix

							commShell.propagateShellEvent ("StartStateEnd",aMessage);

							//removeScrim ();
						}

						if (nodeValue=="ProblemRestoreEnd")
						{
							pointer.ctatdebug ("Found: ProblemRestoreEnd");

							messageHandler.processProblemRestoreEnd (aMessage);

							commShell.propagateShellEvent ("ProblemRestoreEnd",aMessage);
						}

						if (nodeValue=="GetURL")
						{
							pointer.ctatdebug ("Found: GetURL");

							messageHandler.processGetURL (aMessage);

							commShell.propagateShellEvent ("GetURL",aMessage);
						}

						if (nodeValue=="SetPreferences")  // occurs only when collaborating with JS tracer?
						{
							messageHandler.forwardToTutor(aMessage);
							return;
						}

						if (nodeValue=="InterfaceReboot")
						{
							nInterfaceReboots++;
							ctatdebug ("Found: InterfaceReboot #"+nInterfaceReboots+" -- href "+(location ? location.href : "(no location)"));
							if (nInterfaceReboots > 1)
							{
								if(!CTAT.ToolTutor.reboot("InterfaceReboot from CTATMessageHandler"))  // could not use location.href
								{
									//close WS connection
									let url = 'ws://'+CTATConfiguration.get('remoteSocketURL')+':'+CTATConfiguration.get('remoteSocketPort');
									ctatdebug('closing connection w/ url: '+url);
									commShell.closeWSConnection(url, function()
										{
											let myId = window.frameElement.getAttribute('id');
											if(typeof(CustomEvent) == "function")
											{
												let refreshEvent = new CustomEvent('refreshIframe', {'detail': myId});
												window.parent.document.dispatchEvent(refreshEvent);
											}
										}, 'interfaceReboot');
								}
							}
						}
						// if this message was received from a collaborator, pass it also to our tracer
						var collaborator = /student[0-9]+/i.exec(actor);
						if(collaborator && (collaborator[0] == actor))
						{
							messageHandler.forwardToTutor(aMessage);
						}
					}
				}
			}
		}
	};
	/**
	 * <message>
	 * <verb>SendNoteProperty</verb>
	 * <properties>
	 *     <MessageType>StateGraph</MessageType>
	 *     <caseInsensitive>true</caseInsensitive>
	 *     <unordered>true</unordered>
	 *     <lockWidget>true</lockWidget>
	 *     <suppressStudentFeedback>false</suppressStudentFeedback>
	 *     <highlightRightSelection>true</highlightRightSelection>
	 *     <confirmDone>false</confirmDone>
	 *     <Skills>
	 *       <value>right right=0.3=0=Right Branch</value>
	 *     </Skills>
	 *   </properties>
	 * </message>
	 */
	this.processStateGraph=function processStateGraph (aPropertyList)
	{
		pointer.ctatdebug ("processStateGraph ()");

		if ((aPropertyList===undefined) || (aPropertyList===null))
		{
			pointer.ctatdebug ("Error: state graph property list is undefined");
			return;
		}

		pointer.ctatdebug ("Processing node: " + aPropertyList.nodeName);

		if (messageParser.getElementChildren (aPropertyList)===null)
		{
			pointer.ctatdebug ("Error: state graph property list is undefined");
			return;
		}

		var messageProperties=messageParser.getElementChildren (aPropertyList);

		for (var t=0;t<messageProperties.length;t++)
		{
			var propNode=messageProperties [t];

			pointer.ctatdebug ("State graph attribute: " + messageParser.getElementName (propNode));

			if (messageParser.getElementName (propNode)=="caseInsensitive")
			{
				if (messageParser.getNodeTextValue (propNode)=='false')
					caseInsensitive=false;
				else
					caseInsensitive=true;
			}

			if (messageParser.getElementName (propNode)=="unordered")
			{
				if (messageParser.getNodeTextValue (propNode)=='false')
					unordered=false;
				else
					unordered=true;
			}

			if (messageParser.getElementName (propNode)=="lockWidget")
			{
				if (messageParser.getNodeTextValue (propNode)=='false')
					lockWidget=false;
				else
					lockWidget=true;
			}

			if (messageParser.getElementName (propNode)=="suppressStudentFeedback")
			{
				if (messageParser.getNodeTextValue (propNode)=='false')
				{
					CTATGlobals.suppressStudentFeedback=false;
				}
				else
				{
					CTATGlobals.suppressStudentFeedback=true;
				}
			}

			if (messageParser.getElementName (propNode)=="highlightRightSelection")
			{
				if (messageParser.getNodeTextValue (propNode)=='false')
					highlightRightSelection=false;
				else
					highlightRightSelection=true;
			}

			if (messageParser.getElementName (propNode)=="confirmDone")
			{
				pointer.ctatdebug ("Confirm done: " + messageParser.getNodeTextValue (propNode));
				if (messageParser.getNodeTextValue (propNode)=='true')
					CTATGlobals.confirmDone=true;
				else
					CTATGlobals.confirmDone=false;
			}

			if (messageParser.getElementName (propNode)=="Skills")
			{
				//ctatdebug ("Processing skills ...");

				if (CTATSkillSet.skills===null)
				{
					CTATSkillSet.skills=new CTATSkillSet ();
				}

				CTATSkillSet.skills.parseByValue(propNode);

				messageHandler.updateSkillWindow ();
			}
		}
	};
	/**
	 *
	 */
	this.processStartProblem=function processStartProblem (aPropertyList)
	{
		pointer.ctatdebug ("processStartProblem ()");

		messageHandler.processStartProblem ();
	};
	/**
	 *
	 */
	this.processInterfaceIdentification=function processInterfaceIdentification (aPropertyList)
	{
		//pointer.ctatdebug ("processInterfaceIdentification ()");

	};
	/**
	 *
	 */
	this.processInterfaceDescription=function processInterfaceDescription (aPropertyList)
	{
		pointer.ctatdebug ("processInterfaceDescription ("+aPropertyList.length+")");

		var aType="Unknown";
		var aName="Unknown";
		var targetSerializationElement=null;

		for (var i=0;i<aPropertyList.length;i++)
		{
			var tempElement=aPropertyList [i];

			pointer.ctatdebug ("Inspecting element: " + messageParser.getElementName (tempElement));

			if (messageParser.getElementName (tempElement)=="WidgetType")
			{
				pointer.ctatdebug ("Widget type: " + messageParser.getNodeTextValue (tempElement));

				aType=messageParser.getNodeTextValue (tempElement);
			}

			if (messageParser.getElementName (tempElement)=="CommName")
			{
				pointer.ctatdebug ("Instance name: " + messageParser.getNodeTextValue (tempElement));

				aName=messageParser.getNodeTextValue (tempElement);
			}

			if (messageParser.getElementName (tempElement)=="serialized")
			{
				pointer.ctatdebug ("Prepareing to de-serialize component ...");

				var compTest=messageParser.getElementChildren (tempElement);

				for (var j=0;j<compTest.length;j++)
				{
					var serElement=compTest [j];

					if (messageParser.getElementName (serElement).indexOf ("CTAT")!=-1) // Safety check
					{
						targetSerializationElement=serElement;
					}
				}
			}

			if (messageParser.getElementName (tempElement)=="interface")
			{
				pointer.ctatdebug ("Storing interface for post start-state reconstruction ...");

				CTATGlobals.interfaceElement=tempElement;
			}

			if (messageParser.getElementName (tempElement)=="script")
			{
				pointer.ctatdebug ("Storing and loading main javascript code as defined by the BRD ...");

				scriptElement=messageParser.getNodeTextValue (tempElement);
			}
		}

		if (targetSerializationElement!==null)
		{
			//useDebugging=true;
			this.deserializeComponent (aType,aName,targetSerializationElement);
			//useDebugging=false;
		}
		else
		{
			pointer.ctatdebug ("Error: unable to find CTAT serialization point of attachement");
		}

		pointer.ctatdebug ("processInterfaceDescription () done");
	};
	/**
	 *
	 */
	this.deserializeComponent=function deserializeComponent (aType,aName,aComponentElement)
	{
		pointer.ctatdebug ("deserializeComponent ("+aType+","+aName+")");

		if (CTATGlobals.ignoreInterfaceDescriptions===true)
		{
			pointer.ctatdebug ("ignoreInterfaceDescriptions==true");
			return;
		}

		if (messageParser.getElementAttr (aComponentElement,"x")===null)
		{
			pointer.ctatdebug ("Warning: this component does not have x,y information. Probably an older component");
			return;
		}

		//messageParser.listElementAttr (aComponentElement);

		var x=messageParser.getElementAttr (aComponentElement,"x");
		var y=messageParser.getElementAttr (aComponentElement,"y");
		var width=messageParser.getElementAttr (aComponentElement,"width");
		var height=messageParser.getElementAttr (aComponentElement,"height");
		var tabIndex=messageParser.getElementAttr (aComponentElement,"tabIndex");
		var zIndex=messageParser.getElementAttr (aComponentElement,"zIndex");

		if (tabIndex===null)
		{
			tabIndex=-1;
		}

		if (zIndex===null)
		{
			zIndex=0;
		}

		var compEntry=new CTATComponentDescription ();
		compEntry.type=aType;
		compEntry.name=aName;
		compEntry.x=Math.floor (x);
		compEntry.y=Math.floor (y);
		compEntry.tabIndex=tabIndex;
		compEntry.zIndex=zIndex;
		compEntry.width=Math.floor (width);
		compEntry.height=Math.floor (height);

		CTATShellTools.registerComponentDescription(compEntry);

		//var serializedProps=aComponentElement.childNodes;
		var serializedProps=messageParser.getElementChildren (aComponentElement);

		for (var i=0;i<serializedProps.length;i++)
		{
			var tempElement=serializedProps [i];

			//>------------------------------------------------------------------------

			//if (tempElement.nodeName=="SAIs")
			if (messageParser.getElementName (tempElement)=="SAIs")
			{
				// We currently don't do anything with this yet
			}

			//>------------------------------------------------------------------------

			//if (tempElement.nodeName=="Parameters")
			if (messageParser.getElementName (tempElement)=="Parameters")
			{
				this.ctatdebug ("Processing component parameters ...");

				//var paramProps=tempElement.childNodes [0].childNodes;
				var tempProps=messageParser.getElementChildren (tempElement);

				var tempProp=tempProps [0];

				var paramProps=messageParser.getElementChildren (tempProp);

				for (var t=0;t<paramProps.length;t++)
				{
					var paramProperty=paramProps [t];

					//if (paramProperty.nodeName=="CTATComponentParameter")
					if (messageParser.getElementName (paramProperty)=="CTATComponentParameter")
					{
						this.ctatdebug ("Processing parameter property (CTATComponentParameter) ...");

						var aParam={name:undefined,value:undefined};


						//var paramValues=paramProperty.childNodes;

						var paramValues=messageParser.getElementChildren (paramProperty);

						for (var j=0;j<paramValues.length;j++)
						{
							var paramElement=paramValues [j];

							//if (paramElement.nodeName=="name")
							if (messageParser.getElementName (paramElement)=="name")
							{
								this.ctatdebug ("Found parameter name: " + messageParser.getNodeTextValue (paramElement));
								aParam.name=messageParser.getNodeTextValue (paramElement);
							}

							//if (paramElement.nodeName=="value")
							if (messageParser.getElementName (paramElement)=="value")
							{
								this.ctatdebug ("Found parameter value: " + messageParser.getNodeTextValue (paramElement));

								aParam.value=messageParser.getNodeTextValue (paramElement).trim();
							}
						}

						this.ctatdebug ("Parameter name: " + aParam.name + ", value: " + aParam.value);
						if (aParam.name!==undefined) {// should also check for string
							compEntry.params[aParam.name] = aParam.value;
							if(aParam.name=="group")
							{
								compEntry.groupName=aParam.value;
							}
						}
					}
				}
			}

			//>------------------------------------------------------------------------

			//if (tempElement.nodeName=="Styles")
			if (messageParser.getElementName (tempElement)=="Styles")
			{
				this.ctatdebug ("Processing component styles ...");

				//var stylesProps=tempElement.childNodes [0].childNodes;

				var tmpProps=messageParser.getElementChildren (tempElement);

				var tmpProp=tmpProps [0];

				var stylesProps=messageParser.getElementChildren (tmpProp);

				for (var s=0;s<stylesProps.length;s++)
				{
					var styleProperty=stylesProps [s];

					//if (styleProperty.nodeName=="CTATStyleProperty")
					if (messageParser.getElementName (styleProperty)=="CTATStyleProperty")
					{
						this.ctatdebug ("Processing style property (CTATStyleProperty) ...");

						//alert(xml_to_string(styleProperty));

						var aStyle={name:"",value:""};

						//var styleValues=styleProperty.childNodes;

						var styleValues=messageParser.getElementChildren (styleProperty);

						for (var k=0;k<styleValues.length;k++)
						{
							var styleElement=styleValues [k];

							//alert(xml_to_string(styleElement));

							//if (styleElement.nodeName=="name")
							if (messageParser.getElementName (styleElement)=="name")
							{
								//this.ctatdebug ("Found style name: " + messageParser.getNodeTextValue (styleElement));
								aStyle.name=messageParser.getNodeTextValue (styleElement);
							}

							//if (styleElement.nodeName=="value")
							if (messageParser.getElementName (styleElement)=="value")
							{
								//this.ctatdebug ("Found style value: " + messageParser.getNodeTextValue (styleElement));

								aStyle.value=messageParser.getNodeTextValue (styleElement).trim();

								/* code was as follows, but && was ||, so "if(... || ...)" was effectively "if(true)"

								if((aStyle.name != "DisplayHTMLText") && (aStyle.name != "ProcessHTMLInHints"))
								{
									aStyle.value=messageParser.getNodeTextValue (styleElement).trim();
								}
								else
								{
									//this.ctatdebug ("Running a straight trim on incoming value ("+styleElement+") ...");

									var encoder=new CTATHTMLManager();
									aStyle.value=encoder.htmlEncode(styleElement).trim();
								}
								*/
							}
						}

						this.ctatdebug ("Style (name: " + aStyle.name + ", value: " + aStyle.value + ")");

						if (aStyle.name!=="") // checking for orphans
							compEntry.styles[aStyle.name] = aStyle.value;
					}
				}
			}

			//>------------------------------------------------------------------------
		}

		pointer.ctatdebug ("deserializeComponent ("+aType+","+aName+") done");
	};
	/**
	 *
	 */
	/*this.displayComponentList=function displayComponentList ()
	{
		pointer.ctatdebug ("displayComponentList ("+CTATShellTools.component_descriptions.length+")");

		for (var i=0;i<components.length;i++)
		{
			var aDesc=components [i];

			pointer.ctatdebug ("Component (Desc): " + aDesc.name + ", type: " + aDesc.type+", x: " + aDesc.x + ", y: " + aDesc.y + ", width: " + aDesc.width + ", height: " + aDesc.height);

			var component=aDesc.getComponentPointer ();

			if (component!==null)
			{
				pointer.ctatdebug ("Component (Pointer): " + component.name + ", type: " + component.type+", x: " + component.x + ", y: " + component.y + ", width: " + component.width + ", height: " + component.height);
			}
		}
	};*/ // DEPRICATED: use CTATShellTools.listComponents(); also this is unused.
	/**
	 *
	 * @param xml_node
	 * @returns
	 */
    function xml_to_string(xml_node)
    {
        if (xml_node.xml)
		{
            return xml_node.xml;
		}
        else if (XMLSerializer)
        {
            var xml_serializer = new XMLSerializer();
            return xml_serializer.serializeToString(xml_node);
        }
        else
        {
            alert("ERROR: Extremely old browser");
            return "";
        }
    }
    /**
     * Decide whether to lock components whose values are set in the start state.
     * If an element of the startStateMessages array is a message of type SendWidgetLock,
     * remove it and return the value of the WidgetLockFlag property.
     * @return {boolean} see above; default return is false if no lock-widgets msg found, true if found
     */
    function checkForSendWidgetLock()
    {
	var result = false, i = 0, swlMsg = [], wlFlag = "";
	for(i = startStateMessages.length-1; i >= 0; --i)  // this msg usually at end of list
	{
	    if(startStateMessages[i].getMessageType() == "SendWidgetLock")
	    {
		swlMsg = startStateMessages.splice(i, 1);  // remove: returns array
		wlFlag = swlMsg[0].getProperty("WidgetLockFlag");
		switch(String(wlFlag).toLowerCase())
		{
		case "no":
		case "off":
		case "false":
		    result = false; break;
		default:
		    result = true; break;
		}
	    }
	}
	pointer.ctatdebug("checkForSendWidgetLock() found "+swlMsg.length+" msg, wlFlag "+wlFlag+", result"+result);
	return result;
    }
    /**
     *
     */
    this.processStartStateActions=function processStartStateActions ()
    {
    	pointer.ctatdebug ("processStartStateActions ("+startStateMessages.length+")");

		//CTATMessageHandler.inProcessStartStateActions=true;

		if (startStateMessages.length===0)
		{
			pointer.ctatdebug ("No start state messages, bump");

			//CTATMessageHandler.inProcessStartStateActions=false;

			return;
		}

		if (CTATMessageHandler.startStateHandlers.length>0)
		{
			for (var i=0;i<CTATMessageHandler.startStateHandlers.length;i++)
			{
				var aHandler=CTATMessageHandler.startStateHandlers [i];

				aHandler.processStartStateActions (startStateMessages);
			}

			//CTATMessageHandler.inProcessStartStateActions=false;

			return;
		}

		var lockWidgetsSetInStartState = checkForSendWidgetLock();

		for (var j=0;j<startStateMessages.length;j++)
		{
			var aMessage=startStateMessages [j];

			pointer.ctatdebug ("Processing startstate message type: " + aMessage.getMessageType());// + "("+CTATMessageHandler.inProcessStartStateActions+")");

			switch (aMessage.getMessageType())
			{
				case "InterfaceAction":
				messageHandler.processInterfaceAction (aMessage, lockWidgetsSetInStartState);
				break;

				case "UntutoredAction":			  
				messageHandler.processUntutoredAction (aMessage, lockWidgetsSetInStartState);
				break;

				case "CorrectAction":
				messageHandler.processCorrectAction (aMessage);
				break;

				case "InCorrectAction":
				messageHandler.processInCorrectAction (aMessage);
				break;
			}
		}

		if (CTATMessageHandler.scriptElement!=="")
		{
			try
			{
				eval (CTATMessageHandler.scriptElement);
			}
			catch (err)
			{
				alert ("Error executing script from BRD: " + err.message);
			}
		}

		//CTATMessageHandler.inProcessStartStateActions=false;
    };

	/**
	*
	*/
	this.sleep=function sleep(milliseconds)
	{
		pointer.ctatdebug ("sleep ("+milliseconds+")");

		// Let's not do that for now

		/*
		var start = new Date().getTime();
		for (var i = 0; i < 1e7; i++)
		{
			if ((new Date().getTime() - start) > milliseconds)
			{
				break;
			}
		}
		*/
	};
};

CTATMessageHandler.prototype = Object.create(CTATBase.prototype);
CTATMessageHandler.prototype.constructor = CTATMessageHandler;

CTATMessageHandler.startStateHandlers = [];
CTATMessageHandler.inStartState = false;
//CTATMessageHandler.inProcessStartStateActions = false; // no functional value.
CTATMessageHandler.scriptElement = "";
