/**
* Values can be one of: 'ctat','google','undefined'
*/

var platform="ctat";/**
*
*/
function getSafeElementById(anID) 
{
    return (document.getElementById(anID));  
}
/**
* Use this tool to generate the encodings: http://webcodertools.com/imagetobase64converter/Create
*/

var imgStart="data:image/png;base64,";

var doneDefault=imgStart+
"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\
Md14hpkAAAAASUVORK5CYII=";

var doneHover=imgStart+
"iVBORw0KGg0KJiM2NTUzMzsmIzY1NTMzOyYjNjU1MzM7DQpJSERSJiM2NTUzMzsmIzY1NTMz\
OyYjNjU1MzM7QSYjNjU1MzM7JiM2NTUzMzsmIzY1NTMzO0IIAiYjNjU1MzM7JiM2NTUzMzsm\
IzY1NTMzO4cBLLwmIzY1NTMzOyYjNjU1MzM7JiM2NTUzMzsJcEhZcyYjNjU1MzM7JiM2NTUz\
MzsLEyYjNjU1MzM7JiM2NTUzMzsLEwEmIzY1NTMzO5qcGCYjNjU1MzM7JiM2NTUzMzsNCk9p\
Q0NQUGhvdG9zaG9wIElDQyBwcm9maWxlJiM2NTUzMzsmIzY1NTMzO3janVNnVFPpFj333vRC\
S4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoNCtgH5CGi\
joOjiIrK++F7o2vWvPfmzf611z7nrPOds88HwAgMlkgzUTWADKlCHhHgg8fExuHkLkCBDQok\
cCYjNjU1MzM7EAizZCFz/SMBJiM2NTUzMzv4fjw8KyLAB74mIzY1NTMzOwF40wsIJiM2NTUz\
MzvATZvAMByH/w/qQplcAYCEAcB0kThLCIAUJiM2NTUzMztAeo5CpiYjNjU1MzM7QEYBgJ2Y\
JlMmIzY1NTMzO6AEJiM2NTUzMztgy2Ni4yYjNjU1MzM7UC0mIzY1NTMzO2Anf+bTJiM2NTUz\
MzuAnfiZewEmIzY1NTMzO1uUIRUBoJEmIzY1NTMzOyATZYhEJiM2NTUzMztoOyYjNjU1MzM7\
rM9WikUmIzY1NTMzO1gwJiM2NTUzMzsUZkvEOSYjNjU1MzM72C0mIzY1NTMzOzBJV2ZIJiM2\
NTUzMzuwtyYjNjU1MzM7wM4QC7ImIzY1NTMzOwgMJiM2NTUzMzswUYiFKSYjNjU1MzM7BHsm\
IzY1NTMzO2DIIyN4JiM2NTUzMzuEmSYjNjU1MzM7FEbyVzzxK64Q5yomIzY1NTMzOyYjNjU1\
MzM7eJmyPLkkOUWBWwgtcQdXVy4eKM5JFysUNmECYZpALsJ5mRkygTQP4PPMJiM2NTUzMzsm\
IzY1NTMzO6CRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAmIzY1NTMzOyYjNjU1\
MzM74XR+0f4sL7MagDsGgG3+oiXuBGheC6B194tmsg9AtSYjNjU1MzM7oOnaV/Nw+H48PEWh\
kLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc\
5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUmIzY1NTMz\
O7BqPgF7kS2oXWMD9ksnEFh0wOL3JiM2NTUzMzsmIzY1NTMzO/K7b8HUKAgDgGiD4c93/+8/\
/UegJSYjNjU1MzM7gGZJknEmIzY1NTMzOyYjNjU1MzM7XkQkLlTKsz/HCCYjNjU1MzM7JiM2\
NTUzMztEoIEqsEEb9MEYLMAGHMEF3MEL/GA2hEIkxMJCEEINCmSAHHJgKayCQiiGzbAdKmAv\
1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKL\
JCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yCYjNjU1MzM7MoL8hrxHMZSBslE91Ay1\
Q7moNxqERqIL0GR0MZqPFqCb0HK0Gj2MNqHn0KtoD9qPPkPHMMDoGAczxGwwLsbDQrE4LAmT\
Y8uxIqwMq8YasFasA7uJ9WPPsXcEEoFFwAk2BHdCIGEeQUhYTFhO2EioIBwkNBHaCTcJA4RR\
wicik6hLtCa6EfnEGGIyMYdYSCwj1hKPEy8Qe4hDxDckEolDMie5kAJJsaRU0hLSRtJuUiPp\
LKmbNEgaI5PJ2mRrsgc5lCwgK8iF5J3kw+Qz5BvkIfJbDQqdYkBxpPhT4ihSympKGeUQ5TTl\
BmWYMkFVo5pS3aihVBE1j1pCraG2Uq9Rh6gTNHWaOc2DFklLpa2ildMaaBdo92mv6HS6Ed2V\
Hk6X0FfSy+lH6JfoA/R3DA0KhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lv\
VVgqtip8FZHKDQqVSpUmlRsqL1Spqqaq3qoLVfNVy1SPqV5Tfa5GVTNT46kJ1JarVaqdUOtT\
G1NnqTuoh6pnqG9UP6R+Wf2JBlnDTMNPQ6RRoLFf47zGIAtjGbN4LCFrDQqrhnWBNcQmsc3Z\
fHYqu5j9HbuLPaqpoTlDM0ozV7NS85RmPwfjmHH4nHROCecop5fzforeFO8p4ikbpjRMuTFl\
XGuqlpeWWKtIq1GrR+u9Nq7tp52mvUW7WfuBDkHHSidcJ0dnj84FnedT2VPdpw0KpxZNPTr1\
ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVx\
bzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppS\
TbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5\
WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wu\
w+6TvZN9un2N/T0HDQqH2Q6rHVodfnO0chQ6Vjrems6c7j99xfSW6S9nWM8Qz9gz47YTyynE\
aZ1Tm9NHZxdnuXOD84iLiUuCyy6XPi6bG8bdyL3kSnT1cV3hetL1nZuzm8LtqNuv7jbuae6H\
3J/MNJ8pnlkzc9DDyEPgUeXRPwuflTBr36x+T0NPgWe15yMvYy+RV63XsLeld6r3Ye8XPvY+\
cp/jPuM8N94y3llfzDfAt8i3y0/Db55fhd9DfyP/ZP96/9EmIzY1NTMzO6eAJQFnA4mBQYFb\
Avv4enwhv44/Ottl9rLZ7UGMoLlBFUGPgq2C5cGtIWjI7JCtIffnmM6RzmkOhVB+6NbQB2Hm\
YYvDfgwnhYeFV4Y/jnCIWBrRMZc1d9HcQ3PfRPpElkTem2cxTzmvLUo1Kj6qLmo82je6NLo/\
xi5mWczVWJ1YSWxLHDkuKq42bmy+3/zt84fineIL43sXmC/IXXB5oc7C9IWnFqkuEiw6lkBM\
iE44lPBBECqoFowl8hN3JY4NCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5\
hCepkLxMDQpM3Zs6nhaadiBtMj06vTGDkpGQcUKqIU2TtmfqZ+ZmdsusZYWy/sVui7cvHpUH\
yWuzkKwFWS0NCrZCpuhUWijXKgeyZ2VXZr/Nico5lqueK83tzLPK25A3nO+f/+0SwhLhkral\
hktXLR1Y5r2sajmyPHF52w0K4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr\
6wtVDQrlhX3r3NftXU9YL1nftWH6hp0bPhWJiq4U2xeXFX/YKNx45RuHb8q/mdyUtKmrxLlk\
z2bSZunm3i2eWw6Wqpfmlw5uDQrZ2rQNCt9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07\
P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4\
lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NCjYNClWNnMbiI3BE\
eeTp9wnf9x4NCjradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0\
PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4\
dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWe\
OT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89Hc\
R/cGhYPP/pH1jw9DBY+Zj8uGDQqG6544Pjk54j9y/en8p0PPZM8mnhf+ov7LrhcWL3741evX\
ztGY0aGX8peTv218pf3qwOsZr9vGwsYevsl4MzFe9Fb77cF33Hcd76PfD0/kfCB/KP9o+bH1\
U9Cn+5MZk5P/BAOY8/xjMy3bJiM2NTUzMzsmIzY1NTMzOyYjNjU1MzM7IGNIUk0mIzY1NTMz\
OyYjNjU1MzM7eiUmIzY1NTMzOyYjNjU1MzM7gIMmIzY1NTMzOyYjNjU1MzM7+f8mIzY1NTMz\
OyYjNjU1MzM7gOkmIzY1NTMzOyYjNjU1MzM7dTAmIzY1NTMzOyYjNjU1MzM76mAmIzY1NTMz\
OyYjNjU1MzM7OpgmIzY1NTMzOyYjNjU1MzM7F2+SX8VGJiM2NTUzMzsmIzY1NTMzOwh7SURB\
VHja7JprcFXVFcf/a+19zr03b0hIAonhEYiAIghEpIgyFUVpcajTx9iOr2kdS1t1dFpHp6PT\
x1j9oDO17Tgt7ThaO2prrY5tx6laaxVREDBFhaIBkRBDAnlAbnLvPWfvtfohAarTD2aS4L3T\
7Nkfzoc9+5zfXo+9Hoe273pv4wvPHDjUmTEq4iYjNjU1MzM7CEBKBKMBqYuRl0OtLY5pdsWU\
6y67nJbd+p35c92ClGNrDMmJNaqkICbNTwYP1sjvGDQf7i22riReXaVJzUUwhJNfPPREyNOh\
oDDwk4rDX3UOWBiwRg4QIv4fS/N0CMgpQnVqLKOgBxGAAmcmIzY1NTMzO6jQGYbMteDlMMHw\
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";

var doneClick=imgStart+
"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";

var doneDisabled=imgStart+
"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\
gg==";

var hintDefault=imgStart+
"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";

var hintClick=imgStart+
"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\
v5vbo9CD1RCDKLqxXoWyVMZ+owERgibR6894/m03fMZo8evflq2vnb/4ov3vufqvW16x+5LLD6RS\
v/U1XH/j3rnZ8jUX7/jwtkMJgTB/RH3FI89DyVzYK0Lzotc8AFRty4LEvfeV52wchWXqGT145bAU\
q2Lnn2fefOWGV740u/k71Vuu3PmLX45cfnmjGnr8DZ/a/7M7nlHL28E6HkdirZXZcWQIcAi7VftV\
Fz6hlqyXtBbS578063TQ6AoH3CkmGpdN5C98VSefnzzj9G60dP+DqlwomBvQyKaCtICaC9UToMeP\
Qb1bxRrNL9yqCiGMbN9+R0g0IDoNbkkI6dOzmvlQVTcpQ70jZBXcvA6kSohUd0jUMmjkI2qyj+Ye\
SKJ6gLkw005IQ4EKh0bS8iTuiNEAT6UzkSFZ1ejXoztIwHw6OVNEmc+XbGsiY0hqx5UhqUnMBUSq\
S8ypbZM8Wa4egLxkHp0ac1CDezKtCHFnLKJbcorWRoezmdnePbvW7Xugbt6AICQeV4YIbdbTaWtH\
FKWbJDFA1q3gmtVq3hf0T3/c+KrlhNdXjPuGx+QUEZZFxvWrR1aOgN4497x09oaxl2/56Y3Xdi1E\
hllUY8fVt8ZSvTHdaq9v1vZlqVmq5qnXT7UyrzXtYJSadddxZHfWnayk5TKq1vKszZjNpdXDuj/T\
jJUbmx0J6rGGjqSGZQti/80V4z/51sX33scljsF7jcHGowwnDgNhZFpKX+1QuIJIkMT/i/d8FIBy\
1PerAwgCLg6HIMHdl2oKYkwlQm/orLD311WzVNRBoy+BhHjogxHmPDzcK57JamFn96+3hN69QPvh\
pxRLoBAZTFLlRVU7ZWj1lr8NANYHQ8VQtDRgAAAAAElFTkSuQmCC";

var hintHover=imgStart+
"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\
RK5CYII=";

var hintDisabled=imgStart+
"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";

var hintNextDefault=imgStart+
"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\
AHLRv3KUoBHQAAAAAElFTkSuQmCC";

var hintNextHover=imgStart+
"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";

var hintNextDisabled=imgStart+
"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";

var hintPreviousDefault=imgStart+
"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";

var hintPreviousHover=imgStart+
"iVBORw0KGgoAAAANSUhEUgAAAFMAAAAVCAIAAAC10UUmAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAABS9JREFUeNrkV2tsVEUUPve53UfZtrtbtvS1rSWklbQoEAGV2lAEKlEQLFoLGjBQ0JIQQKyCQpCkaZSENEJUCMYQEZqIRsUiRUQCwYQqhT7oIwvtbp9u93n33r2vGX9sW0tfFCJ/2pNJ7sydMzPnm/OYcwiEfID84DkBai9MBqLMYMwHOppASjtRNxtYGVjtpEAuCRAi0ePXaPD/DCQPsTNh8lBPI+GtIEG8DbopMKlIowOplQTAozFgFbsdnBJSJiB4jMjRplQJvVZQZ37iZsa8GlWcaOAxAD3KjeC9u1pOVfkBoNkhejp5s228HqEI8u5378gqpkhY9LR+0cqpdATzcPKdPnJ3yUqL0ap/FOBH1vnJz1o//toV7s9J15qSIse/oyKh45XezetNWzaar1ULOXl1GOGHE27WbEOEjn5EaieHu3n1he7X93aE++Yo+rvPbbxbCLr4wY13CxiPikfDEKlZMbZM04dlaU0OiXeHnPXeypPO6qruog23Rb8k+qUDu5qzF9W8V9wkeEXA+OBHLf6uYHh5V5P3RPkdALh2NSBwCgAIXqFka9OzOTf27miWeRkABI/wyZ6WMH+gh/+yzA4AMi+XljTn5Na8uqburwvdY9v7UJ231XoWrrszMHR5laSFDYYZN4Y0/fS/16+rh/vpUgxIIQlr9HR7m7B6p/PipcCbrxgJEhavqF+9KvrShazliw0vrrmNMVhM1OFDneFVuw90JCdpAOCrs/6AR8Iqzl3Z+Mxc7a9n0jPSmOWrGjDCIq9+8aMvzB/0yUd/8gPA+zvsaSnMb+ezjpanSCJ6AGtHMsottPMhNB5rOfMHp4TkEad8HPp0n720pCUzu7aiLJ7WMgDwxtKoHfvT5i2Nc3cKLh+iSGi57rJOYy/f5FVJWVVoLT/jUUVF4qSq68H5SywDu7nbA/4gemFtojZKk19ka2yTOJcwcnpGE5VX+K5mr8bAzMuLG1v+e7yIZMgfjiRlrWiRlft7Zt58fRjScGJpIue5SK2W3LozXhfTlxpSVN+s3yPLKq69yYeH3x6IJ2lKF8Msmau/ddXt6pHeeTl6cFAM+uXYqP/kNBspnpM1Gmr4uftLUyqOtReXOKsbQ/s3mQuLbeNFDgDp8y1ny8Xnt7SFvTg2hr5yKnX4MRRNWFNHjfbaCOLJbAvJjBw+p9l0IRHl5VtZAwsAqqSQFAkAe7ZPfXt3u8unnjs5fTC/JdHQ0CpKQYnVszIvO11KzFSdGJQDPAKMgSAEvu/RJWmioNhWUAzBXsE0s+bBkANAbn5C2a3QzsM9ANDjVo4e7y0tn/E/BlVDrG7fW+ZZ2bVFLxm73ervNfzlqkySIm2ZMfaOu9MT2egEwz33aNSUbjYvWFy3aYXx0GnvsT1WRs/QEXS8mS7a0Bhvpir/7AuNWzY2pcQxC57SfX+O+2CtaWwxCNSxjRAqICppyHteWFD/zfm+EOKtzTLGjfdRxSrudQRMyVMIYlCZwEkir0TG6gb++LuC9gbOEEklZxgZXZ9tcz08RRPafgfxOjmDOYKOoAGgt81/t1lInaEfuBclpDRWe0yxrDlRH3CFohMMSEatdR53r5L8mHasBMTnQMwyAnVuI/ihyMNGmLOs9vIN3hJFO2tmhS1zgpDPgZhlo+YJFEtf/GVmZ0vAkqifULD7jX2sDIli6YSM6IlasJHApoLIT64qVRSAthJIshO35oCeAu3kqNJFDjhZTb9CIOTFchfxz0GQHIAB+rNxPMHcuv+LWSs2bwfW+u8AGLFZkjQMdD8AAAAASUVORK5CYII=";

var hintPreviousDisabled=imgStart+
"iVBORw0KGgoAAAANSUhEUgAAAFMAAAAVCAIAAAC10UUmAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAABGdJREFUeNrkWE1P8koU7kxLKy0gIChWE19UElGjRkOU6MKEhSH+Wt35jQslGiQSiSYaNVE0gIDItJa2085dTEKMr/iVexdXz6qdTqfnmfOcc54psG2bENJsNgkhzC8wCKEgCAzDcISQYrFICIEQ/gbktm0zDBMKhTjDMGzbFkWR+TWmaZqu69CyLJZlmd9kLMtalgXfJ0atVjNN80fi59o9wBhvb28jhDiOW15e5jjuVyC3bXtvbw8hRLegXq8HAoFPrmgYRjqdpp3C5/NFo1Ge57/nXCaTiUQinZ2d/0mRf3P06OioUqnQa0EQ/H7/51fEGNdqtcHBweHh4aenp42NDVpOv2GBQODbu/ZxzP9u4+fn5zc3N63uNz09rarqqzkAAEmSAADteqYsyxzHybK8srKiqqqqqqVSyel0FgqFeDxO44kQkiQpFos5nc79/f3x8XEa3lKpdHNzE4vFyuWy1+t1Op2qqmYyGUVR3G737OysIAiqqh4fH8/PzzMM02g0Tk9P5+bmdF0/PDykGRoOhyORSDvYhJDXbL+7u8vn8y9pn06n33y5s7MzkUi0A0+NCiRBEO7v7y8vL3t6enp7ewEAW1tbY2NjAwMDZ2dnqVQqmUzyPH9ycrKwsMAwTD6fD4VCDMNUKpX+/n6Px5NKpfr6+mKx2Onp6fb29tLSkmmaLVZqmlatVhmGSafTbrd7YWFBUZRCofCFPLcsK5PJfFLMIYRM03yTjZZlHRwcEEKq1erQ0BCd4/V6aYhKpZJlWQCA29tbSZI0TcMYR6PRzc1NjDHGWFGUl+F6fHy0bXtychIAMDMzs7q6qijKmy4BAOr1OmVKNBr9AnKWZScmJrLZ7GeQS5LkcDjaeRAMBh0Ox9TUlMvlag22QkQ3hd6Gw2EIoSRJLpfr+vpa07RX6d1sNlmWpa8DAFiW1XX9zU/H4/FcLpfL5TRNk2U5Fot9obaHw2GE0MXFRStjZ2Zm/m5pEMJgMPhOng8ODrZrhF1dXYSQ0dHRjo4OWhEhhACAkZGRfD6PMabUaJnP5zMMQ9d1QRB0XccYezwewzAIIYQQAEBLcUAIKVpFUdbW1r6GnGGYiYkJhFCxWKR5fnV1tbi4+C8WVbfbLcvy+vp6IBAwTVNRlGQyCQCQZTmbzfI87/V6X84XRVGW5Y2NjUAg8PDw8OfPH0EQHA4Hx3E7OzsOh6PRaNCZu7u7PM/7/f5yudzd3f2+GwAhhBCix5eXpW9zc7O1YiKReOXNh8qvq6vrJSOazaZhGB6PpzXy9PRULpd5ng+FQq2vI4Qo8+ltvV6nOUUIqdVq1Wo1GAx6vV66smmahUJBFEW/368ois/nwxgXi8Xn52e/3/+OADEMQxRFoChKo9F4hZyScG1trdlsQgiTySRl5s+wD5BT8A8PD7Sj/iTdahiGJEnvqXGO43p7e3/wLwr4bXX5PzXLsiCEnCAIhBBN037eaawdbCorAb16fn7GGNOq/oNhUyEkiiKE8J8BADgZS0hqI3g5AAAAAElFTkSuQmCC";

var rotatingLoad = "data:image/gif;base64,"+
"R0lGODlhQABAAPZAAIeHh4mJiY+Pj5ubm5ycnKCgoKKioq6urrKysre3t7m5ubq6ur29vcDAwMHB\
wcPDw8TExMXFxcbGxszMzNDQ0NLS0tTU1NXV1dbW1tfX19jY2NnZ2dra2tvb29zc3N3d3d7e3uDg\
4OHh4eLi4uPj4+Tk5OXl5ebm5ufn5+jo6Onp6erq6uvr6+zs7O3t7e7u7u/v7/Dw8PHx8fLy8vPz\
8/T09PX19fb29vf39/j4+Pn5+fr6+vv7+/z8/P39/f7+/v///////wAAAAAAAAAAAAAAAAAAAAAA\
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5\
BAUKAEEAIf8LTkVUU0NBUEUyLjADAQAAACwAAAAAQABAAAAH/oBAgoOEhYaHiImKi4yNjo+QkZKT\
lJWWl5iZmpucnZ6foKGio6SlpqeoqaqrrK2ur7Cxij+0tba3uLemPz69vr/Awb4/u8LGx8SlvMc+\
tMzNxcHLOx0svDzGyaTLwC0yQC8CDkA4KTjC2qPcvT88Bwg5LQALPykZNevs0fo+EAEVLQIomKGB\
BI8ePYClE7XuBQoeNQwQCFHAwQoONXakIIFv2L4eEggsOEEhwYscPG7UgNHBQggbvxaGathgQAET\
Cdn5KNFhhQ6F+3wA2QEiAo18OGzgwKEjJzRlvmp82MABhFNfPURowOBhxjKZoL6qeMCAwYSrvlyg\
KLECpj6opb1S2qghI0ewHClo9FgH9lM+Hi46mAhWg8OFEzdiBr0xAkMHGDXO+cBhIgaNERlweoTb\
ywaJEzlodEjRYoRoDzogun27DVjCHiY0zEihAUcLCyh8oO3rKV9nDCV40L6hQ0Tw3UF94bXx4+K5\
pAiBcgZ20IcNGNiaoUsuzbf01s/C8+7kPfx3dbnSqx8vq7379/Djy59Pv779+/jz69/Pv7///6ME\
AgAh+QQFCgBDACwPAA8AIgAiAIZ+fn6BgYGOjo6SkpKTk5OXl5ebm5ulpaWoqKivr6+1tbW6urq8\
vLy9vb2/v7/AwMDBwcHCwsLGxsbIyMjLy8vMzMzNzc3Q0NDS0tLU1NTV1dXW1tbY2NjZ2dna2trc\
3Nzd3d3e3t7f39/g4ODh4eHi4uLj4+Pk5OTl5eXm5ubn5+fo6Ojp6enq6urr6+vs7Ozt7e3u7u7v\
7+/w8PDx8fHy8vLz8/P09PT19fX29vb39/f4+Pj5+fn6+vr7+/v8/Pz9/f3+/v7///////8AAAAA\
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\
AAAAAAAH/oBCgoOEgkBBhYmKi4VBQI+MkZKPlEGIkpiGlJtAmYmWoI6cm6Gll5+jqaqVi6Krr6yK\
rqqztK2poD4gL4eWuLecPic0Qi4EFkI2FCy1h8CVNwkKOywCEUIQARlCto2cQT8TBRgqAw7VBjdA\
Oj2/hLM3KzwzBwgiCBUNABo5LCE2q95VMsFgAosNF3Tk2KFCQgsPHEbw6KaJEo8RDxaQ6NXLhQgY\
PppBGtQsSI0OM2r9uMHyxo9ap2rheNFiRQwfo3qMyLChg4xRhEbR8LBhg4h2wWawSNECx6xT3Ebh\
qGHjBtJNOlbkOAR0EC0fMkKs4EppxgYOLK6OFCQSSI8ShBs+wICRo4cPHy5g0PjAAQapoKpwhECR\
w8YGFTFE3BDRQccPGltjkUz1w7GPERxyuNBwI4aGFC+/KaJFY8NYFhlq/DDxQccoqAJH6WjR7oUH\
dT1q4BQti9YjHTR8/FgFezIsIMOJPzuuvDfzV8XZmgIFvZQnb6muS/L1Vzsmyd63d5IUCAAh+QQF\
CgBFACwPAA8AIgAiAIZ+fn6Li4uMjIyRkZGSkpKXl5ebm5ucnJydnZ2hoaGkpKSurq6zs7O4uLi/\
v7/AwMDBwcHFxcXGxsbHx8fIyMjKysrLy8vOzs7Pz8/Q0NDS0tLU1NTV1dXW1tbX19fY2NjZ2dna\
2trb29vd3d3e3t7g4ODh4eHi4uLj4+Pk5OTl5eXm5ubn5+fo6Ojp6enq6urr6+vs7Ozt7e3u7u7v\
7+/w8PDx8fHy8vLz8/P09PT19fX29vb39/f4+Pj5+fn6+vr7+/v8/Pz9/f3+/v7///////8AAAAA\
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH\
/oBEgoOEgkJDhURDQomNjoKLQoyDkoePl5SVh5GViJiOmqGhn5BDpqaiqZunnomcqrCarYWvsbGz\
hLWpuqG4g7ynOhcyirC+kKk1NkQsCBhENRUwu66qQBkTOysGFkMOAii8lsipQUQpDSImBRQnBAs/\
QzxB1LA5NEA/Fg8lESQNA0zogKAghThxMzyUsAHjww56LDxsOAAgQQxgxXr9WOGhwwxZQRgEkKAj\
4yhDohbhcJGjlwwUynDM65VJU48XL1rUKLeiA4gPMUQREkXjQ4cPKYCkxBEjhgwfQmtW6pHjBo4a\
PWrhSHEjCEYiqob8ePFBBb1KQWx44JCCBy+ThKF2kOCwUAaOIEF8qKiRo4QHGMBg8TghIwiODitu\
oLARYoQPIDd0wIKrid6PEh1yvNhw44WGF+LGoUx148OKIDE42AhiAsXZqLRS8aDxQ0jCG/J4UGsU\
mp6PGD1uOQptS9bw4sWPUUaecjgr4rKekwKLfHqjXrWUk+I0VJL26aJ/TboUCAAh+QQFCgBCACwW\
ABYAFAAUAIaHh4eJiYmPj4+bm5ucnJygoKCioqKurq6zs7O2tra4uLi6urq7u7u9vb3AwMDBwcHC\
wsLDw8PFxcXGxsbMzMzQ0NDS0tLU1NTV1dXW1tbX19fY2NjZ2dna2trb29vc3Nzd3d3e3t7g4ODh\
4eHi4uLj4+Pk5OTl5eXm5ubn5+fo6Ojp6enq6urr6+vs7Ozt7e3u7u7v7+/w8PDx8fHy8vLz8/P0\
9PT19fX29vb39/f4+Pj5+fn6+vr7+/v8/Pz9/f3+/v7///////8AAAAAAAAAAAAAAAAAAAAAAAAA\
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH/oA/goOD\
QECEiIiHPz0rNoI+iYg3OD84ECBBMBMwi4k+JCU9Nw0cPQ4EKUGehT8oGS82DR0hAws8jIg6Nz06\
Hh4zFCESBSc1EQcuiz4qGSc2MSY5PT41JxUGAQgzgz44Jhsej4U+CQQWOqxAPTUplYgwIi0uMLiW\
LCoqLpI6BQEAAjysisFhwwYSkno8UMDgQYtDPXLgyFEjh6IcLGj4WEVohwsPKBLZ6KBBhcVBOUZc\
+BDDho4fPnSYkGGjRMkeg26YULGjBgcVL0bc8PCBx6iTkHD2IIGBBgoNGC+o+MEK0g8bGk74MJEh\
xw4RJCJJ+nHjBA4gLD68xDFuLExBCTg0Cqrq1pDbQAAh+QQFCgBDACwQAA8AIQAiAIaBgYGDg4OL\
i4uNjY2Pj4+RkZGYmJiioqKjo6OoqKirq6u3t7e4uLi7u7u8vLy/v7/ExMTFxcXHx8fJycnLy8vN\
zc3R0dHS0tLT09PU1NTV1dXW1tbX19fY2NjZ2dna2trb29vd3d3e3t7f39/g4ODi4uLj4+Pk5OTl\
5eXm5ubn5+fo6Ojp6enq6urr6+vs7Ozt7e3u7u7v7+/w8PDx8fHy8vLz8/P09PT19fX29vb39/f4\
+Pj5+fn6+vr7+/v8/Pz9/f3+/v7///////8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH/oBCgoOEQkBAhUJBiImNjouHhIdA\
QY6WkpOUkJOVl46ZoKCegkGlpqGomqadhZupr5mshK6wsLKDtLWpt6S1Mzc/to25Pzc8QDkeLUA8\
Izeprak6IyQ9NRssQSINK6WonbmHiysbMTYbKzQPEzw+ND3f4cgyPjohITckMR/cLhAKJuSlerFB\
xIwYLHwotHECAwIDC2jIC9ejxYdyoIJgULBhhyJUgnbpYJGD1o4QJU6ggJcxJCgdLVasgMEy044E\
BAYUAEFrUKgaHzRsGFFz0o4LESRYgBGqV6YfP3DYwHHDR8YUDFJUylUJVTAfMEIsi1UBgAAHNqB9\
62Eiw4cYgTJy+Ojxo4XFAwEohJNnI8QKHTQ2qJgh4sYIDzh0eHDxKpyPHUB+gOCQowWGGzE6rEC0\
12moIDQ6LFuhwYYPEyJ0QIsWSkcMqy4+3Aji40ZRccN2HcoxI1jj3La8/U4kUBcn4MaHt1pVPBbz\
UYaMQ2+UkRav6ZswUZr+idei64QCAQAh+QQFCgBEACwPAA8AIgAbAIZ8fHyNjY2Pj4+RkZGUlJSW\
lpaYmJiZmZmbm5ulpaWpqamqqqqwsLC0tLS2tra4uLi/v7/AwMDExMTGxsbLy8vMzMzNzc3Q0NDR\
0dHS0tLV1dXW1tbX19fY2NjZ2dna2trc3Nzd3d3e3t7f39/g4ODh4eHi4uLj4+Pk5OTl5eXm5ubn\
5+fo6Ojp6enq6urr6+vs7Ozt7e3u7u7v7+/w8PDx8fHy8vLz8/P09PT19fX29vb39/f4+Pj5+fn6\
+vr7+/v8/Pz9/f3+/v7///////8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH/oBDgoOEgkFBhUOHQomNjkNCh4iDkoyPl4aSQUKR\
mpaYjZqioqCCnKedo6OonI6pqrCrrrG0op+Fr7Wxt4S5i4c8MDubu46wODhCNxwuQT0vOLCJvodA\
JSE9NhsvQCgdNEDUlpyqnTIaLDceLDYcJz9CPUDl1Ic5NDzW3yo2LBw3PEZUoFGv3gwOImrYaOFj\
3j0WEx5UiCZtFRAfLDpoiEFMUgcJJnxAUmUqVg4WOUbtGPEBxIgasjJp0uGCxQqYqiIUMIDgwihC\
o2B42LABxTxRQEZgyLABp6ZBvnogw4HvlRAUDEKIVGRLpi0fKjqk8OSjAwEBDWBwJVVPx4gMYiRs\
yKgh5IeMBRlYOBhgoV4sHipm/LChIYUNFCgCHLjho8WMeiNhCfEhYgOOFxtoUAAA4VQ5qLFqdFgR\
5IUHGzoSKOgheZqqHTJ6CInRAccQGS8+NxJHzoeMYeRiutZV61YgACH5BAUKAEEALBYAFgAUABQA\
AAf+gD6Cg4M/P4SIiIc+PDA2Pj08iYM9PTY4PjgcKz82KTmTkDwlIjo3GimjGI+TPT4oFi04qDMa\
Jq6uhDY1PDoeHTQjLSnAOSckrJAmGSM0MSaYmTUwHRgjN4Q3JxccNYkmHS6ShD89NJ+JOTI1Njfj\
NislKC6tEwwMDyqGMx4YGiK5CPUAwWHDB2+QdODAcUkRjQggdgBBpGNFhxI+FikrMKDBC10hLHSA\
UcNdjhcJKJxYQEBCrh81SKTYUWOTgwIhCBjgheKjwEgkNMxQEKBFhQAQfADRWKhGhhQ/FgBokQPB\
AR5MCeFIgQOIAwEvgMhoEWqQpB8sOuwQlLWsobICgQAAIfkEBQoAQAAsFgAWABQAFACGgICAg4OD\
i4uLj4+PkpKSmZmZn5+foKCgpKSkq6urra2ttra2vLy8vb29wcHBxMTEx8fHysrKzMzMzs7O0NDQ\
0tLS1NTU1dXV1tbW19fX2NjY2dnZ2tra29vb3Nzc3d3d3t7e39/f4ODg4eHh4uLi4+Pj5eXl5ubm\
5+fn6Ojo6enp6urq6+vr7Ozs7e3t7u7u7+/v8PDw8fHx8vLy9PT09fX19vb29/f3+Pj4+fn5+vr6\
+/v7/Pz8/f39/v7+////////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB/6APYKDgjyEh4iCPjw8MjaKiYON\
OT02HCo8OiuPkTgfIjo0Fyg9KxkwPompKhYtNqM3HCA7lYaDNzE7OB0eNCMuKhiOJx80gz4xGhww\
Lys6Ozo3zB4XI5SDOy0bFy+EqSsgMDyphzib5Ng0MzLGqTUqJykvOog7IhgYGzGCMhwYFiB0oBO0\
A8YKFi1qkKtBg+GOgT5mZIjhY9GxHS5AqOhRseOJBg064CCkQ0QGDi0ekLhBA0cFCi0kMABBqEaI\
FbEALJiAwIMCAy12sDA2SMfIGwcEoIAwYASHAg7GDeT4o0OABj8iCCixg0ECGVMVvZgw44cFAiZ+\
1DBBL1JHZAkhdPyoGElV3UAAIfkEBQoARAAsFwAWABMAFACGfX19hoaGkJCQkZGRlZWVmZmZnJyc\
nZ2do6OjqKior6+vsbGxs7Ozt7e3u7u7vb29v7+/xMTExcXFycnJzs7Oz8/P0dHR09PT1NTU1dXV\
1tbW19fX2NjY2dnZ2tra29vb3Nzc3d3d3t7e39/f4ODg4eHh4uLi4+Pj5OTk5eXl5ubm5+fn6Ojo\
6enp6urq6+vr7Ozs7e3t7u7u7+/v8PDw8fHx8vLy8/Pz9PT09fX19vb29/f3+Pj4+fn5+vr6+/v7\
/Pz8/f39/v7+////////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\
AAAAAAAAAAAAAAAAAAAAAAAAAAAAB/6AQYKDhIJAhYVCgjwsOkGHiIQ5OEI4Gy5BPTA5kYIpIT04\
GS1AKho1iIpCMxcpoiyWJD5CPpIyPD8mGzUrNiwbNz4uIzeDMhogNDcttUI7NDUiGSSOQbQtHBgy\
iC0eMD+Kgoo6LTiJPtAzNI48LiwsNJFAKBwaGjFBMx4eGiqQhTdgyIjRIwiPSTZGpAg3CEcKGkAY\
CqkBIUCCgoOA1KhXgocqGAYAIOhQIcQPHzla5UjB4YWqGAsm8DAxgAEIByIiSOARxAanQT+G9FAw\
4EQFAh9ONAjBkJCQFQIeCLFQgMQPChQwJqqh4caQDQdODNFRrJMQIUOG4NDws2knawRuCQUCACH5\
BAUKAEIALBYAFgAUABMAhoeHh4mJiY+Pj5ubm5ycnKCgoKKioq6urrOzs7a2tri4uLq6uru7u729\
vcDAwMHBwcLCwsPDw8XFxcbGxszMzNDQ0NLS0tTU1NXV1dbW1tfX19jY2NnZ2dra2tvb29zc3N3d\
3d7e3uDg4OHh4eLi4uPj4+Tk5OXl5ebm5ufn5+jo6Onp6erq6uvr6+zs7O3t7e7u7u/v7/Dw8PHx\
8fLy8vPz8/T09PX19fb29vf39/j4+Pn5+fr6+vv7+/z8/P39/f7+/v///////wAAAAAAAAAAAAAA\
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\
AAf+gD+Cg4NAQISIiIc/PjQ4gj6JiDaPOh8sQDgnN5KQJCI7ORkmPicaNoyJhyoXLDkaKDQYJD0/\
PZGDOTc9PB8eNyMvKhw1OyomnII9KholNjImOpE6NjEfFyM5hDnMHaiIKB4uO4RAQY2ui7k1OTg5\
tUAtDwwKD7WJJBsbHDHmHgIAAhTQIcmFChUsHv3gAcNFCxEwEuFIUaOHuh9AdFggkMDHRRseNpjA\
gevHDAQBDFQ4UcNHjxwmYtg4kUEFLiAuDkSocaKAhBAUZnjwoKPHDYKEavFYMCBEhwY2XmRAgVFV\
kBQEHPTg0GBXCRIlFcGYACMICAiPcCTrlOqHjRUF9y7+CAQAIfkEBQoAQgAsFgAWABQAEwCGfn5+\
g4ODjY2NkJCQlZWVl5eXmpqao6OjpKSkqqqqrq6uuLi4vLy8vb29w8PDxMTEy8vLzMzMzc3Nz8/P\
0dHR0tLS09PT1NTU1dXV1tbW19fX2NjY2dnZ2tra29vb3Nzc3d3d3t7e39/f4ODg4eHh4uLi4+Pj\
5OTk5eXl5ubm5+fn6Ojo6enp6urq6+vr7Ozs7e3t7u7u7+/v8PDw8fHx8/Pz9PT09fX19vb29/f3\
+Pj4+fn5+vr6+/v7/Pz8/f39/v7+////////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB/6AP4KDhECEh4iDMzaChomC\
PTU7QDgdKz89MTiPPzsiIz04GSg+Lhoyj0FALRsvOBgqORwcPT85tY0wGTY6HiA3IzEtGTM5Kh80\
g0AVAQYWLi09PD05MjEdFyU7hDgPAwAPP46CLyEwtT6Nqi0NJeOCPjY2NTc9PkAxEw8OEjnvmCQw\
YOgwQxwJAgIGILiBiIeMFixabMK0IkUKEBMJ5VjBkFCQIDoyJIiAaEYGDiu2NbKxoMABCiVmSOvR\
4kWNERlYKFuh4MELFwwyxAhhQ4SHGz5odIRUw0cPCA1muMhAg0aGE/cQAQEC9AOQF8R8mACRgxMO\
EjqAwODAiIeNdAicHOGYARdRIAAh+QQFCgBDACwXABYAEwAUAIZ+fn6EhISMjIyOjo6WlpaYmJiZ\
mZmcnJygoKCnp6esrKy1tbW4uLi7u7vAwMDExMTGxsbIyMjJycnKysrMzMzOzs7Pz8/S0tLT09PU\
1NTV1dXW1tbX19fY2NjZ2dna2trb29vd3d3e3t7f39/h4eHi4uLj4+Pk5OTl5eXm5ubn5+fo6Ojp\
6enq6urr6+vs7Ozt7e3u7u7v7+/w8PDx8fHy8vLz8/P09PT19fX29vb39/f4+Pj5+fn6+vr7+/v8\
/Pz9/f3+/v7///////8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH/oBAgoNAP4SHiEFBQDsuOoOLiIIpKEE4Hi2MLjeSQD4K\
BTM2HixAKxsziUFCFAANNRssNxwjPUE+kDAjODsJASErNac2PS8lOIJBGQIJIB0LMD+WNDQiF7uC\
QjcPBAMW0oQrHyw+kUJCQCoNJ4g9MzTvjzIVERAdhogpGRkcpRwIBww0wHfohgsYMXYA0bECRYkR\
NiINunGihiFDinaEcHCB0KIZHTSU2IHvhgQGE1rEqOGJBwoZOEx0eJHsBgYTPWxsSFGjxIwPIXj4\
sPFoUDkfJjjQcNGhRgwNpRQhquHhxA8YqHyQGIFLko4YPYDAUBpER45OyRa5UwhEItq3A4ICAQA7";function CTATCanvasComponent(aName)
{
	var pointer=this;

	var shapes=new Array();
	var componentName=aName || "__undefined__";

	this.addShape=function addShape(aShape)
	{
		shapes.push(aShape);
	};
	
	this.hideShape=function hideShape(aShapeName)
	{
		for(var i=0; i<shapes.length; i++)
		{
			if(shapes[i].getName()==aShapeName)
			{
				shapes[i].modifyCanvasCSS("visibility", "hidden");
				break;
			}
		}
	};
	
	this.showShape=function showShape(aShapeName)
	{
		for(var i=0; i<shapes.length; i++)
		{
			if(shapes[i].getName()==aShapeName)
			{
				shapes[i].modifyCanvasCSS("visibility", "visible");
				break;
			}
		}
	};
	
	this.hideComponent=function hideComponent()
	{
		for(var i=0; i<shapes.length; i++)
		{
			shapes[i].modifyCanvasCSS("visibility", "hidden");
		}
	};
	
	this.showComponent=function showComponent()
	{
		for(var i=0; i<shapes.length; i++)
		{
			shapes[i].modifyCanvasCSS("visibility", "visible");
		}
	};
	
	this.moveShape=function moveShape(aShapeName, toX, toY)
	{
		for(var i=0; i<shapes.length; i++)
		{
			if(shapes[i].getName()==aShapeName)
			{
				shapes[i].modifyCanvasCSS("left", toX+"px");
				shapes[i].modifyCanvasCSS("top", toY+"px");
				break;
			}
		}
	};
	
	this.moveComponent=function moveComponent(toX, toY)
	{
		for(var i=0; i<shapes.length; i++)
		{
			shapes[i].modifyCanvasCSS("left", toX+"px");
			shapes[i].modifyCanvasCSS("top", toY+"px");
		}
	};
	
	this.removeShape=function removeShape(aShapeName)
	{
		var removeIndex=0;
		
		for(var i=0; i<shapes.length; i++)
		{
			if(shapes[i].getName()==aShapeName)
			{
				removeIndex=i;
				break;
			}
		}
		shapes[removeIndex].detatchCanvas();
		shapes.splice(removeIndex, 1);
	};
	
	this.removeComponent=function removeComponent()
	{
		while(shapes.length > 0) 
		{
			pointer.removeShape(shapes[0].getName());
		}
	}
}/**------------------------------------------------------------------------------------
 $Author$ 
 $Date$ 
 $Header$ 
 $Name$ 
 $Locker$ 
 $Log$
 
 -
 License:
 -
 ChangeLog:
 -
 Notes:
 
*/

/**
 *  
 */
function CTATContextData ()
{
	CTATBase.call(this, "CTATContextData", "__undefined__");
	
	var pointer=this;
	
}	

CTATContextData.prototype = Object.create(CTATBase.prototype);
CTATContextData.prototype.constructor = CTATContextData;
/**------------------------------------------------------------------------------------
 $Author$ 
 $Date$ 
 $Header$ 
 $Name$ 
 $Locker$ 
 $Log$
 
 -
 License:
 -
 ChangeLog:
 -
 Notes:
 
*/

/**
 * 
 */
function CTATCSS() 
{
	var currPair=0;
	var attributeValuePairs=[];
	
	var currSelector=0;
	var selectorAttributes=new Array();
	
	var currStr=0;
	var cssStringArray=[];
	
	this.resetSelectors=function resetSelectors ()
	{
		currSelector=0;
		selectorAttributes=new Array();
		selectorAttributes[currSelector]=new Array();		
	};
	
	this.resetCSSStringArray=function resetCSSStringArray()
	{
		cssStringArray=[];
		currStr=0;
	};
	
	this.clearCSS=function clearCSS()
	{
		this.resetSelectors();
		this.resetCSSStringArray();
		attributeValuePairs=new Array();
		currPair=0;
	};
	
	this.addStringCSS=function addStringCSS(str)
	{
		cssStringArray[currStr]=str;
		currStr++;
	};

	this.addCSSAttribute=function addCSSAttribute(attribute, value) 
	{
		attributeValuePairs[currPair]=attribute;
		attributeValuePairs[currPair+1]=value;
		
		currPair+=2;
	};
	
	this.removeStringCSS=function removeStringCSS(str)
	{
		var index=cssStringArray.indexOf(str);
		cssStringArray.splice(index, 1);
	};
	
	this.removeCSSAttribute=function removeCSSAttribute(attribute)
		{ 
		var index=attributeValuePairs.indexOf(attribute);
		attributeValuePairs.splice(index, 2);
	};
	
	this.modifyCSSAttribute=function modifyCSSAttribute(attribute, value)
	{
		var attribIndex=attributeValuePairs.indexOf(attribute);
		
		if(attribIndex==-1) 
		{
			this.addCSSAttribute(attribute, value);
			return; 
		}
		
		attributeValuePairs[attribIndex+1]=value;
	};	
	
	this.addSelector=function addSelector(selector)
	{
		selectorAttributes[currSelector]=new Array();
		selectorAttributes[currSelector][0]=selector;
		currSelector++;
	};
	
	function getSelectorIndex(sel)
	{
	
		//Return 0 since we never added any selectors
		if(currSelector==0)
		{
			return 0;
		}
	
		for(var i=0; i<selectorAttributes.length; i++)
		{
			//This means that what we are looking for does not exist 
			if(selectorAttributes[i][0]==null)
			{
				return -1;
			}
			
			//We found the selector we were looking for
			if(selectorAttributes[i][0]==sel)
			{
				return i;
			}
		}
		
		return -1;
	}

	this.addSelectorAttribute=function addSelectorAttribute(selector, attribute, value)
	{
		var j=1;
		var selectorIndex=getSelectorIndex(selector);
		
		while(selectorAttributes[selectorIndex][j] != undefined) { j++; }
		
		selectorAttributes[selectorIndex][j]=attribute;
		selectorAttributes[selectorIndex][j+1]=value;
	};
		
	this.toCSSString=function toCSSString()
	{
		var cssString="";
		var doesNeedPixels=false;
		
		for(var i=0; i<selectorAttributes.length; i++)
		{
			cssString+=selectorAttributes[i][0]+" { ";
			for(var j=1; j<selectorAttributes[i].length; j++)
			{
				cssString+=selectorAttributes[i][j];
			
				if(j%2==0)
				{
					cssString+="; ";
				}
				
				else
				{
					cssString+=": ";
				}
			}
			
			cssString+=" }; ";
		}
		
		
		for(var i=0; i<attributeValuePairs.length; i++)
		{
			cssString+=attributeValuePairs[i];
		
			if(i%2==0)
			{
				cssString+=": ";
			}
			
			else
			{
				cssString+="; ";
			}
		}
		
		for(var i=0; i<cssStringArray.length; i++)
		{
			cssString+=cssStringArray[i]+" ";
		}
		
		return cssString;
	};
}
/*
 * Date Format 1.2.3
 * (c) 2007-2009 Steven Levithan <stevenlevithan.com>
 * MIT license
 *
 * Includes enhancements by Scott Trenda <scott.trenda.net>
 * and Kris Kowal <cixar.com/~kris.kowal/>
 *
 * Accepts a date, a mask, or a date and a mask.
 * Returns a formatted version of the given date.
 * The date defaults to the current date/time.
 * The mask defaults to dateFormat.masks.default.
 */

var dateFormat = function () 
{
	var	token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZ]|"[^"]*"|'[^']*'/g,
		timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g,
		timezoneClip = /[^-+\dA-Z]/g,
		
	pad = function (val, len) 
	{
		val = String(val);
		len = len || 2;
		while (val.length < len) val = "0" + val;
		return val;
	};

	/**
	 * Regexes and supporting functions are cached through closure
	 */
	return function (date, mask, utc) 
	{
		var dF = dateFormat;

		// You can't provide utc if you skip other args (use the "UTC:" mask prefix)
		if (arguments.length == 1 && Object.prototype.toString.call(date) == "[object String]" && !/\d/.test(date)) {
			mask = date;
			date = undefined;
		}

		// Passing date through Date applies Date.parse, if necessary
		date = date ? new Date(date) : new Date;
		if (isNaN(date)) throw SyntaxError("invalid date");

		mask = String(dF.masks[mask] || mask || dF.masks["default"]);

		// Allow setting the utc argument via the mask
		if (mask.slice(0, 4) == "UTC:") {
			mask = mask.slice(4);
			utc = true;
		}

		var	_ = utc ? "getUTC" : "get",
			d = date[_ + "Date"](),
			D = date[_ + "Day"](),
			m = date[_ + "Month"](),
			y = date[_ + "FullYear"](),
			H = date[_ + "Hours"](),
			M = date[_ + "Minutes"](),
			s = date[_ + "Seconds"](),
			L = date[_ + "Milliseconds"](),
			o = utc ? 0 : date.getTimezoneOffset(),
			flags = {
				d:    d,
				dd:   pad(d),
				ddd:  dF.i18n.dayNames[D],
				dddd: dF.i18n.dayNames[D + 7],
				m:    m + 1,
				mm:   pad(m + 1),
				mmm:  dF.i18n.monthNames[m],
				mmmm: dF.i18n.monthNames[m + 12],
				yy:   String(y).slice(2),
				yyyy: y,
				h:    H % 12 || 12,
				hh:   pad(H % 12 || 12),
				H:    H,
				HH:   pad(H),
				M:    M,
				MM:   pad(M),
				s:    s,
				ss:   pad(s),
				l:    pad(L, 3),
				L:    pad(L > 99 ? Math.round(L / 10) : L),
				t:    H < 12 ? "a"  : "p",
				tt:   H < 12 ? "am" : "pm",
				T:    H < 12 ? "A"  : "P",
				TT:   H < 12 ? "AM" : "PM",
				Z:    utc ? "UTC" : (String(date).match(timezone) || [""]).pop().replace(timezoneClip, ""),
				o:    (o > 0 ? "-" : "+") + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4),
				S:    ["th", "st", "nd", "rd"][d % 10 > 3 ? 0 : (d % 100 - d % 10 != 10) * d % 10]
			};

		return mask.replace(token, function ($0) {
			return $0 in flags ? flags[$0] : $0.slice(1, $0.length - 1);
		});
	};
}();

// Some common format strings
dateFormat.masks = 
{
	"default":      "ddd mmm dd yyyy HH:MM:ss",
	shortDate:      "m/d/yy",
	mediumDate:     "mmm d, yyyy",
	longDate:       "mmmm d, yyyy",
	fullDate:       "dddd, mmmm d, yyyy",
	shortTime:      "h:MM TT",
	mediumTime:     "h:MM:ss TT",
	longTime:       "h:MM:ss TT Z",
	isoDate:        "yyyy-mm-dd",
	isoTime:        "HH:MM:ss",
	isoDateTime:    "yyyy-mm-dd'T'HH:MM:ss",
	isoUtcDateTime: "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'"
};

// Internationalization strings
dateFormat.i18n = 
{
	dayNames: [
		"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat",
		"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"
	],
	monthNames: [
		"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
		"January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"
	]
};

// For convenience...
Date.prototype.format = function (mask, utc) 
{
	return dateFormat(this, mask, utc);
};


function getTimeStamp ()
{
	var d = new Date();
	var n = d.getTime(); 
		
	return (n);
}
function CTATDialogBox(aX, aY, aWidth, aHeight)
{
	var x=aX;
	var y=aY;
	var width=aWidth;
	var height=aHeight;
	var borderRoundness=5;
	var dialogBorderColor="#CCCCCC";
	
	var dialog=null;
	var scrimMessage=null;
}/**------------------------------------------------------------------------------------
 $Author$ 
 $Date$ 
 $Header$ 
 $Name$ 
 $Locker$ 
 $Log$
 
 -
 License:
 -
 ChangeLog:
 -
 Notes:
 
*/

/**
 *  
 */
function CTATFlashVars ()
{
	CTATBase.call (this, "CTATFlashVars", "flashvars");
	
	var pointer=this;
	var raw=null;
	
	/**
	 * 
	 * @param aData
	 */
	this.assignRawFlashVars=function assignRawFlashVars (aData)
	{
		this.raw=aData;
	};
	
	/**
	 * 
	 */
	this.getRawFlashVars=function getRawFlashVars ()
	{
		return (this.raw);
	};
	
	/**
	 * <b>[Required]</b> The local time zone name. 
	 * <p>Datashop prefers the use of tz database time zones, such as one from the "TZ" column in this <a href="http://en.wikipedia.org/wiki/List_of_zoneinfo_time_zones">List of zoneinfo time zones</a>. 
	 * Three-letter time zone abbreviations such as "EST" and "PST" are still valid, but are deprecated. If the field is not assigned
	 * the default value of "America/New_York" will be used.</p>
	 */
	this.setTimeZone=function setTimeZone (zone) 
	{
		var getDebugger = new CTATBase("CTATFlashVars", "");

		getDebugger.debug ("setTimeZone ("+zone+")");		
		
		var timeZone="";
	
		if ((zone==null) || (zone=="") || (zone==undefined)) 
		{
		    var tz = jstz.determine(); // Determines the time zone of the browser client
		    			
		    getDebugger.debug ("Assigning detected timezone: " + tz.name ());
		    
			timeZone = tz.name(); // Returns the name of the time zone eg "Europe/Berlin"
		}
		else 
		{
			if (zone.length > 50)
				zone = zone.substr(0, 50);
			
			if (zone.length == 3 || zone.length == 4)
			{
				getDebugger.debug("3 and 4 letter time zone abbreviations are deprecated. See list of tz database zone names for better options");
			}	
			
			timeZone = zone;
		}
		
		if (this.raw!=null)
		{
			this.raw ['timezone']=timeZone;
		}	
	};
	
	/**
	 * 
	 * @returns
	 */
	this.getTimeZone=function getTimeZone() 
	{
		if (this.raw!=null)
		{
			return (this.raw ['timezone']);
		}
		
		return "";
	};
}	

CTATFlashVars.prototype = Object.create(CTATBase.prototype);
CTATFlashVars.prototype.constructor = CTATFlashVars;

/**
 * 
 */
function noenter(e) 
{
	//debug ("noenter ()");
	
	if (platform=="google")
	{
		return (0);
	}
	
    e = e || window.event;
    var key = e.keyCode || e.charCode;
	
    return (key !== 13); 
}

/**
 * 
 * @param str
 * @returns {Boolean}
 */
function isEmpty(str) 
{
    return (!str || 0 === str.length);
}

/**
 * 
 */
function isBlank(str) 
{
    return (!str || /^\s*$/.test(str));
}

/**
 * 
 * @param c
 * @returns
 */
function componentToHex(c) 
{
    var hex = c.toString(16);
    return hex.length == 1 ? "0" + hex : hex;
}

/**
 * 
 * @param r
 * @param g
 * @param b
 * @returns {String}
 */
function rgbToHex(r, g, b) 
{
    return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
}

/**
 * 
 * @param hex
 * @returns
 */
function hexToRgb(hex) 
{
    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    
    return result ? 
	{    	
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
    } : null;
}

/**
 * 
 * @param filename
 * @param filetype
 */
function loadjscssfile(filename, filetype)
{
	if (filetype=="js")
	{
		//if filename is a external JavaScript file
		var fileref=document.createElement('script');
		fileref.setAttribute("type","text/javascript");
		fileref.setAttribute("src", filename);
	}
	else if (filetype=="css")
	{ 
		//if filename is an external CSS file
		var fileref=document.createElement("link");
		fileref.setAttribute("rel", "stylesheet");
		fileref.setAttribute("type", "text/css");
		fileref.setAttribute("href", filename);
	}
	
	if (typeof fileref!="undefined")
	{
		getSafeElementsByTagName("head")[0].appendChild(fileref);
	}	
}

/**
*
*/
function parseQueryString () 
{
	debug ("parseQueryString ()");
		
	var str = location.search;
		
	var query = str.charAt(0) == '?' ? str.substring(1) : str;
	var args = new Object();

	if (query) 
	{
		var fields = query.split('&');

		for (var f = 0; f < fields.length; f++) 
		{
			var field = fields[f].split('=');
			args[unescape(field[0].replace(/\+/g, ' '))] = unescape(field[1].replace(/\+/g, ' '));
		}
	}
	
	return args;
}

/**
*
*/
function parseQueryStringArgs (aQuerySet) 
{
	var str = aQuerySet;
		
	var query = str.charAt(0) == '?' ? str.substring(1) : str;
	var args = new Object();

	if (query) 
	{
		var fields = query.split('&');

		for (var f = 0; f < fields.length; f++) 
		{
			var field = fields[f].split('=');
			args[unescape(field[0].replace(/\+/g, ' '))] = unescape(field[1].replace(/\+/g, ' '));
		}
	}
	
	return args;
}

/**
*
*/
function tutorPrep (aVars)
{
	debug ("tutorPrep ()");

	var args = new Array ();
	
	if (platform=="ctat")
	{
		args=parseQueryString ();
	}
	
	var generated=false;

	for (var arg in args) 
	{
		switch(arg) 
		{
			case "GENERATED":
								if (args [arg]=="on")
								{
									var generator=new CTATGuid ();
									aVars ['session_id']=generator.guid();
									generated=true;
								}
								break;
			case "BRD": 
								aVars ['question_file']=args[arg];
								break;								
			case "BRMODE": 
								aVars ['BehaviorRecorderMode']=args[arg];
								break;								
			case "PROBLEM": 									
								aVars ['problem_name']=args[arg];
								break;								
			case "DATASET": 
								aVars ['dataset_name']=args[arg];
								break;								
			case "LEVEL1": 									
								aVars ['dataset_level_name1']=args[arg];
								break;								
			case "TYPE1": 									
								aVars ['dataset_level_type1']=args[arg];
								break;								
			case "USER": 
								aVars ['user_guid']=args[arg];
								break;								
			case "SESSION": 								
								if (generated==false)
								{
									aVars ['session_id']=args[arg];
								}	
								break;								
			case "SOURCE": 									
								aVars ['source_id']=args[arg];
								break;								
			case "LOGTYPE": 
								aVars ['Logging']=args[arg];
								break;								
			case "PORT": 
								aVars ['remoteSocketPort']=args[arg];
								break;								
			case "REMOTEURL": 
								aVars ['remoteSocketURL']=args[arg];
								break;								
			case "DISKDIR": 
								aVars ['log_to_disk_directory']=args[arg];
								break;								
			case "USEOLI": 
								aVars ['DeliverUsingOLI']=args[arg];
								break;								
			case "URL": 
								aVars ['log_service_url']=args[arg];
								break;
			case "CONNECTION": 
								aVars ['connection']=args[arg];
								break;								
			case "SUI": 
								aVars ['sui']=args[arg];
								break;
			case "VAR1": 
								aVars ['var1']=args[arg];
								break;								
			case "VAL1": 
								aVars ['val1']=args[arg];
								break;								
			case "VAR2": 
								aVars ['var2']=args[arg];
								break;								
			case "VAL2": 
								aVars ['val2']=args[arg];
								break;								
			case "VAR3": 
								aVars ['var3']=args[arg];
								break;								
			case "VAL3": 
								aVars ['val3']=args[arg];
								break;								
			case "VAR4": 
								aVars ['var4']=args[arg];
								break;								
			case "VAL4": 
								aVars ['val4']=args[arg];
								break;								
								
			case "KEYBOARDGROUP": 
								if (args[arg]=='Disabled')
									aVars ['keyboard']='disabled';
										
								if (args[arg]=='Auto')
									aVars ['keyboard']='auto';

								if (args[arg]=='On')
									aVars ['keyboard']='on';

								break;																

			/*						
			case "CSS": 
								if (args[arg]!="")
								{
									// For some reason this doesn't work
									
									//loadjscssfile(args[arg], "css") // dynamically load and add this .css file
								}
								break;					
			*/					
		}
	}	
	
	return (aVars);
}

function raiseInitialScrim(aMessage) 
{
	var mainCanvas=getSafeElementById("main-canvas");
	mainCanvas.setAttribute('style', "background-color: rgba(0,0,0,0.2);");
	
	ctx=mainCanvas.getContext("2d");
	
	var scrimGraphics=new CTATGraphicsTools(ctx);

	scrimGraphics.setLineColor("dark grey");
	scrimGraphics.setFillColor("white");
	
	var x=mainCanvas.width * 1/8;
	var y=mainCanvas.height * 3/8;
	
	var w=mainCanvas.width * 6/8;
	var h=mainCanvas.height * 3/8;
	
	scrimGraphics.drawRoundedRectFilled(x, y, w, h, 5);
	
	scrimGraphics.setLineColor("black");
	scrimGraphics.drawText(x, y, aMessage);
}

function clearInitialScrim()
{
	var mainCanvas=getSafeElementById("main-canvas");
	mainCanvas.setAttribute('style', "background-color: rgb(255,255,255);");
}

/**
 * 
 */
 /*
$(window).bind('orientationchange', function(event) 
{		
	if (event.orientation==undefined)
	{
		debug ("Warning: the orientation object is undefined, probably an old browser, compensating ...");
		setOrientation (window.orientation);
	
	}
	else
	{
		debug ("orientationchange ("+event.orientation+")");				
		setOrientation (event.orientation);
	}	
});
*/

/**
 * 
 * @param anOrientation
 */
function setOrientation(anOrientation)
{
	debug ("setOrientation ("+anOrientation+")");		
	
	switch (anOrientation) 
	{  
		case -90:
		case 90:
					orientation='landscape';
			
					/*
					var orImg=getSafeElementById("pageor");
					if (orImg!=null)
					{
						orImg.src="/skindata/landscape.png";
					}
					else
						alert ("Can't find orientation image object");
					*/	
			
					if (mobileAPI!=null)
					{
						mobileAPI.processOrientationChange (orientation);
					}
					
					break;
		case 180:
		default:    	
					orientation='portrait';

					/*
					var orImg=getSafeElementById("pageor");
					if (orImg!=null)
					{
						orImg.src="/skindata/portrait.png";
					}
					else
						alert ("Can't find orientation image object");					
					*/	
			
					if (mobileAPI!=null)
					{
						mobileAPI.processOrientationChange (orientation);
					}
					
					break;
	}	
}

/**
 * In order to provide support to older browsers, here is an implementation of the Object.create
 * method. Source: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create
 */
 if (!Object.create) 
 {
    Object.create = (function()
	{
        function F(){}

        return function(o)
		{
            if (arguments.length != 1) 
			{
                throw new Error('Object.create implementation only accepts one parameter.');
            }
			
            F.prototype = o;
            return new F();
        }
    })();
}

function centerTutor(tutorWidth, tutorHeight)
{
	var td=getSafeElementById("table element");
	
	var leftMargin=-1*(tutorWidth/2);
	var topMargin=-1*(tutorHeight/2);
	
	td.setAttribute("style", "position: absolute; top: 50%; left: 50%; margin: "+topMargin+"px 0 0 "+leftMargin+"px;");
}

/**
*
*/
function thisMovie(movieName) 
{
    if (navigator.appName.indexOf("Microsoft") != -1) 
	{
		return window[movieName];
	} 
	else 
	{
		return document[movieName];
	}
}

/**
* Introspects an object.
* http://www.syger.it/Tutorials/JavaScriptIntrospector.html
* 
* @param name the object name.
* @param obj the object to introspect.
* @param indent the indentation (optional, defaults to "").
* @param levels the introspection nesting level (defaults to 1).
* @returns a plain text analysis of the object.
*/
function introspect (name, obj, indent, levels) 
{
	indent = indent || "";
 
	if (this.typeOf(levels) !== "number") levels = 1;
	var objType = this.typeOf(obj);
	var result = [indent, name, " ", objType, " :"].join('');
	
	if (objType === "object") 
	{
		if (level > 0) 
		{
			indent = [indent, "  "].join('');
			
			for (prop in obj) 
			{
				var prop = this.introspect(prop, obj[prop], indent, level - 1);
				result = [result, "\n", prop].join('');
			}
			
			return result;
		}
		else 
		{
			return [result, " ..."].join('');
		}
	}
	else if (objType === "null") 
	{
		return [result, " null"].join('');
	}
	
	return [result, " ", obj].join('');
}

/**
*
*/
function findPointOfAttachment (anInstance)
{
	debug ("findPointOfAttachment ("+anInstance+")");

	for (var t=0;t<movieclips.length;t++)
	{
		var aMovieClip=movieclips [t];
		
		debug ("Examining: " + aMovieClip.getName () + "...");
		
		if (aMovieClip.isRegistered (anInstance)==true)
		{
			return (aMovieClip);
		}
	}
	
	return (null);
}

/**
*
*/
function findMovieClip (anInstance)
{
	debug ("findMovieClip ("+anInstance+")");

	for (var t=0;t<movieclips.length;t++)
	{
		var aMovieClip=movieclips [t];
		
		debug ("Examining: " + aMovieClip.getName () + "...");
		
		if (aMovieClip.getName ()==anInstance)
		{
			return (aMovieClip);
		}
	}
	
	return (null);
}

/**
*
*/
function findComponentByName (anInstance)
{	
	debug ("findComponentByName ("+anInstance+")");
	
	for (var i=0;i<componentReferences.length;i++)
	{
		var ref=componentReferences [i];
	
		if (ref.getName ()==anInstance)
			return (ref);
	}
	
	return (null);
}	

/**
*
*/
function findComponentByClass (anInstance)
{
	debug ("findComponentByClass ("+anInstance+")");

	var results=new Array ();
	
	for (var i=0;i<componentReferences.length;i++)
	{
		var ref=componentReferences [i];
	
		if (ref.getClassName ()==anInstance)
		{
			results.add (ref);
		}		
	}

	return (results);	
}
/**
*
*/
function findComponent (aName)
{
	for (var j=0;j<components.length;j++)
	{
		var subRef=components [j];
					
		var subComponent=subRef.getComponentPointer ();
		
		if (subComponent!=null)
		{
			if (subComponent.getName()==aName)
			{
				//debug ("Found sub component, returning ...");
				return (subComponent);
			}	
		}
	}	
	
	return (null);
}

/**
 * 
 */
function listComponentReferences ()
{
	debug ("listComponentReferences ("+componentReferences.length+")");
	
	for (var i=0;i<componentReferences.length;i++)
	{
		var ref=componentReferences [i];

		debug ("Component: " + ref.getElement ().getName () + ", with div: " + ref.getDiv ().id);
	}
}

/**
 * 
 */
function colName(n) {
    var s = "";
    while(n >= 0) {
        s = String.fromCharCode(n % 26 + 97) + s;
        n = Math.floor(n / 26) - 1;
    }
    return s;
}

/**
 * 
 */
/*
function selectText(containerid)
{
	if (document.selection) 
	{
		var range = document.body.createTextRange();
		range.moveToElementText(document.getElementById(containerid));
		range.select();
	}
	else if (window.getSelection)
	{
		var range = document.createRange();
		range.selectNode(document.getElementById(containerid));
		window.getSelection().addRange(range);
	}
}
*/

function selectText(target)
{
    //document.getElementById(target).focus();
    //document.getElementById(target).select();
}/**------------------------------------------------------------------------------------
 $Author$ 
 $Date$ 
 $Header$ 
 $Name$ 
 $Locker$ 
 $Log$
 
 -
 License:
 -
 ChangeLog:
 -
 Notes:
 
*/

var tutorRunning=false;

var useDebugging=false;
var useDebuggingBasic=false;
var debugPointer=null;
var globalCommDisabled=false;

var customconsole=null;

var lastMessage=false;

var version="3.2.0";
var contextGUID="";
var orientation="portrait";
var ctatcanvas=null;
var ctx =null;	
var lineCounter=0;
var canvasWidth=600;
var canvasHeight=500;
var windowPadding=4;
var currentZIndex=2;
var currentIDIndex=1;
var currentComponentPointer=null;
var movieclips=new Array ();
var components=new Array();
var componentReferences=new Array ();
var feedbackComponents=new Array ();
var oldComponentFocus=null;
var globalDebugger=null;

// Global component settings ...

var correctColor="#00cc00";
var incorrectColor="#ff0000";
var highlightColor="#ffff00";
var hintColor="#ffff00";

var canvasCalibrate=5;

// Support class instances and global data structures ...
 
var scriptElement="";
var flashVars=null;
var commShell=null; // Nice to have but don't rely on it too much!
var mobileAPI=null; // Pointer to a CTATMobileTutorHandler object
var skillSet=null;
var aVars=null;
var interfaceElement=null; // Pointer to the DOM element holding the serialized low level interface
var commLibrary=null;
var commLMSService=null;
var commMessageBuilder=null;
var commMessageHandler=null;
var commLogMessageBuilder=null;
var commLoggingLibrary=null;
var selectedTextInput=null;
var nameTranslator=null;

// Specific hint support

var hints=new Array ();
var hintIndex=0;

// StateGraph variables

var caseInsensitive=true;
var unordered=true;
var lockWidget=true;
var suppressStudentFeedback=false;
var highlightRightSelection=true;
var confirmDone=false;

// Constants and visual defaults ...

var globalBackgroundColor="#ffffff";
var globalBorderColor="#cccccc";	
var globalFontColor="#000000";
var globalFontFamily="Verdana";
var globalFontSize=9;
var globalShowBorder=false;
var globalAlign='left';	
var globalBorderString="1px solid";
var globalGlowString="-webkit-box-shadow: 0px 0px 15px 5px rgba(255, 255, 190, 1.0); -moz-box-shadow: 0px 0px 15px 5px rgba(255, 255, 190, 1.0); box-shadow: 0px 0px 15px 5px rgba(255, 255, 190, 1.0); ";

var dialogDiv=null;

var incompatibleBrowserMessage="Your browser does not support CTAT. Please update or replace your browser.";
/**------------------------------------------------------------------------------------
 $Author$ 
 $Date$ 
 $Header$ 
 $Name$ 
 $Locker$ 
 $Log$
 
 -
 License:
 -
 ChangeLog:
 -
 Notes:
 
*/

function CTATGraphicsTools(aCanvasCtx, aBorderWidth, aLineColor, aFillColor, aFillShape, allowAA)
{

	CTATBase.call(this, "CTATGraphicsTools", "__undefined__");

	var borderWidth=aBorderWidth || 1;
	var lineColor=aLineColor || "#000000";
	var fillColor=aFillColor || "#EEEEEE";
	var fillShape=aFillShape || false;
	var textFont="Arial";
	var textSize=12;
	var canvasCtx=aCanvasCtx || null;
	var allowAntiAliasing=allowAA || false;
	var aliasingOffset=0;
	
	var pointer=this;
	
	if(canvasCtx == null)
	{
		pointer.debug("--- Error: Must pass a canvas context. ---");
		return -1;
	}
	
	if(allowAntiAliasing==false)
	{
		aliasingOffset=0.5;
	}
	
	/**
	 * 
	 */
	this.getGraphicBorderWidth=function getGraphicBorderWidth()
	{
		return (borderWidth);
	};
	
	/**
	 * 
	 */
	this.setGraphicBorderWidth=function setGraphicBorderWidth(aWidth)
	{
		borderWidth=aWidth;
	};
	
	this.setFont=function setFont(aFont)
	{
		textFont=aFont;
	};
	
	this.setFontSize=function setFontSize(aSize)
	{
		fontSize=aSize;
	};

	/**
	 * 
	 */
	this.getLineColor=function getLineColor()
	{
		return (lineColor);
	};
	
	/**
	 * 
	 */
	this.getFillColor=function getFillColor()
	{
		return (fillColor);
	};
	
	/**
	 * 
	 */
	this.getFillShape=function getFillShape()
	{
		return (fillShape);
	};
	
	/**
	 * 
	 */
	this.setLineColor=function setLineColor(aColor)
	{
		lineColor=aColor;
	};
	
	/**
	 * 
	 */
	this.setFillColor=function setFillColor(aColor)
	{
		fillColor=aColor;
	};
	
	/**
	 * 
	 */
	this.setFillShape=function setFillShape(aValue)
	{
		fillShape=aValue;
	};
	
	/**
	 * 
	 */
	this.getFont=function getFont()
	{
		return (textFont);
	};
	
	/**
	 * 
	 */
	this.getFontSize=function getFontSize()
	{
		return (fontSize);
	};
	
	/**
	 * 
	 */
	this.magicTrigFunctionX=function magicTrigFunctionX(pointRatio)
	{
		return Math.cos(pointRatio*2*Math.PI);
	};
	
	/**
	 * 
	 */
	this.magicTrigFunctionY=function magicTrigFunctionY(pointRatio)
	{
		return Math.sin(pointRatio*2*Math.PI);
	};
	
	/**------------------------------------------------------------------------------------
	* drawLine(x1,y1,x2,y2,c,w):void
	* @param x1: the x-coordinate of the first point
	* @param y1: the y-coordinate of the first point
	* @param x2: the x-coordinate of the second point
	* @param y2: the y-coordinate of the second point
	* @param c: color of the line (May not be correct comment)
	* @param w: width of the line (May not be correct comment)
	* Draws a line
	**------------------------------------------------------------------------------------*/
	this.drawLine=function drawLine(x1, y1, x2, y2, aColor, aWidth)
	{
		if(canvasCtx==null)
		{
			pointer.debug("Error: canvas canvasCtx is NULL in drawLine");
		}	
		
		var finalX1=x1+aliasingOffset;
		var finalX2=x2+aliasingOffset;
		var finalY1=y1+aliasingOffset;
		var finalY2=y2+aliasingOffset;	
		
		canvasCtx.lineWidth=aWidth;
		canvasCtx.strokeStyle=aColor;
		
		canvasCtx.beginPath();
		canvasCtx.moveTo(finalX1, finalY1);
		canvasCtx.lineTo(finalX2, finalY2);
		canvasCtx.stroke();
	};
	
	/**------------------------------------------------------------------------------------
	* drawCircle(centerX, centerY, radius, sides):void
	* @param centerX: the x-coordinate of the center
	* @param centerY: the y-coordinate of the center
	* @param radius: the radius of the circle
	* @param sides: the number of sides
	* NOTE: Due to restrictions, drawCircle is drawing an n-gon with 'sides' sides
	* Draws a circle
	**------------------------------------------------------------------------------------*/
	this.drawCircle=function drawCircle(x, y, radius)
	{
		if(canvasCtx==null)
		{
			pointer.debug("Error: canvas canvasCtx is NULL in drawCircle");
		}
		
		var finalX=x+aliasingOffset;
		var finalY=y+aliasingOffset;
	
		canvasCtx.strokeStyle=lineColor;
		canvasCtx.lineWidth=borderWidth;
		
		canvasCtx.beginPath();
		canvasCtx.arc(finalX, finalY, radius, 0, 2*Math.PI);
		canvasCtx.stroke();
	};
	
	/**------------------------------------------------------------------------------------
	* drawCircleFilled(centerX:Number, centerY:Number, radius:Number, sides:Number):void
	* @param centerX: the x-coordinate of the center
	* @param centerY: the y-coordinate of the center
	* @param radius: the radius of the circle
	* @param sides: the number of sides
	* NOTE: Due to restrictions, drawCircle is drawing an n-gon with 'sides' sides
	* Draws a filled circle
	**------------------------------------------------------------------------------------*/
	this.drawCircleFilled=function drawCircleFilled(x, y, radius)
	{
		if(canvasCtx==null)
		{
			pointer.debug("Error: canvas canvasCtx is NULL in drawCircleFilled");
		}
		
		var finalX=x+aliasingOffset;
		var finalY=y+aliasingOffset;
		
		canvasCtx.fillStyle=fillColor;
		
		canvasCtx.beginPath();
		canvasCtx.arc(finalX, finalY, radius, 0, 2*Math.PI);
		canvasCtx.fill();
	};
	
	/**------------------------------------------------------------------------------------
	* drawRectangle (x:Number,y:Number,w:Number,h:Number)
	* @param x: the x-coordinate of the top left corner of the rectangle
	* @param y: the y-coordinate of the top left corner of the rectangle
	* @param w: the width of th rectangle
	* @param h: the height of the rectangle
	* Draws a rectangle
	**------------------------------------------------------------------------------------*/
	this.drawRectangle=function drawRectangle(x, y, aWidth, aHeight)
	{
		if(canvasCtx==null)
		{
			pointer.debug("Error: canvas canvasCtx is NULL in drawRectangle");
		}
	
		var finalX=x+aliasingOffset;
		var finalY=y+aliasingOffset;
		
		canvasCtx.lineWidth=borderWidth;
		
		if(fillShape==true)
		{
			canvasCtx.fillStyle=fillColor;
			canvasCtx.fillRect(finalX, finalY, aWidth, aHeight);
		}
		
		else
		{
			canvasCtx.strokeStyle=lineColor;
			canvasCtx.beginPath();
			canvasCtx.rect(finalX, finalY, aWidth, aHeight);
			canvasCtx.stroke();
		}
	};
	
	
	/**------------------------------------------------------------------------------------
	* drawRectangleFilled(x:Number,y:Number,w:Number,h:Number)
	* @param x: the x-coordinate of the top left corner of the rectangle
	* @param y: the y-coordinate of the top left corner of the rectangle
	* @param w: the width of th rectangle
	* @param h: the height of the rectangle
	* Draws a filled rectangle
	**------------------------------------------------------------------------------------*/
	this.drawRectangleFilled=function drawRectangleFilled(x, y, aWidth, aHeight)
	{
		if(canvasCtx==null)
		{
			pointer.debug("Error: canvas canvasCtx is NULL in drawRectangleFilled");
		}
		
		var finalX=x+aliasingOffset;
		var finalY=y+aliasingOffset;
		
		canvasCtx.fillStyle=fillColor;
		canvasCtx.fillRect(finalX, finalY, aWidth, aHeight);
	};
	
	/**
	 * 
	 * @param canvasCtx
	 * @param x
	 * @param y
	 * @param width
	 * @param height
	 * @param radius
	 */
	this.drawRoundedRect=function drawRoundedRect (x,y,aWidth,aHeight,radius)
	{		
		var finalX=x+aliasingOffset;
		var finalY=y+aliasingOffset;
		
		//pointer.debug ("drawRoundedRect ("+finalX+","+finalY+","+aWidth+","+aHeight+","+radius+")");
		
		if (canvasCtx==null)
			return;
		
		canvasCtx.strokeStyle=lineColor;
		canvasCtx.lineWidth=borderWidth;
		
		canvasCtx.beginPath();
		canvasCtx.moveTo(finalX,finalY+radius);
		canvasCtx.lineTo(finalX,finalY+aHeight-radius);
		canvasCtx.quadraticCurveTo(finalX,finalY+aHeight,finalX+radius,finalY+aHeight);
		canvasCtx.lineTo(finalX+aWidth-radius,finalY+aHeight);
		canvasCtx.quadraticCurveTo(finalX+aWidth,finalY+aHeight,finalX+aWidth,finalY+aHeight-radius);
		canvasCtx.lineTo(finalX+aWidth,finalY+radius);
		canvasCtx.quadraticCurveTo(finalX+aWidth,finalY,finalX+aWidth-radius,finalY);
		canvasCtx.lineTo(finalX+radius,finalY);
		canvasCtx.quadraticCurveTo(finalX,finalY,finalX,finalY+radius);
		canvasCtx.stroke();
	};
	
	/**
	 * 
	 * @param grcanvasCtx
	 * @param x
	 * @param y
	 * @param width
	 * @param height
	 * @param radius
	 */
	this.drawRoundedRectFilled=function drawRoundedRectFilled (x,y,aWidth,aHeight,radius)
	{		
		var finalX=x+aliasingOffset;
		var finalY=y+aliasingOffset;

		//pointer.debug ("drawRoundedRect ("+finalX+","+finalY+","+aWidth+","+aHeight+","+radius+")");
		
		if (canvasCtx==null)
			return;
		
		// Draw outline ...
		
		canvasCtx.strokeStyle=lineColor;
		canvasCtx.lineWidth=borderWidth;

		canvasCtx.beginPath();
		canvasCtx.moveTo(finalX,finalY+radius);
		canvasCtx.lineTo(finalX,finalY+aHeight-radius);
		canvasCtx.quadraticCurveTo(finalX,finalY+aHeight,finalX+radius,finalY+aHeight);
		canvasCtx.lineTo(finalX+aWidth-radius,finalY+aHeight);
		canvasCtx.quadraticCurveTo(finalX+aWidth,finalY+aHeight,finalX+aWidth,finalY+aHeight-radius);
		canvasCtx.lineTo(finalX+aWidth,finalY+radius);
		canvasCtx.quadraticCurveTo(finalX+aWidth,finalY,finalX+aWidth-radius,finalY);
		canvasCtx.lineTo(finalX+radius,finalY);
		canvasCtx.quadraticCurveTo(finalX,finalY,finalX,finalY+radius);
		canvasCtx.stroke();
		
		//fill ...
		canvasCtx.fillStyle=fillColor;
	
		canvasCtx.beginPath();
		canvasCtx.moveTo(finalX,finalY+radius);
		canvasCtx.lineTo(finalX,finalY+aHeight-radius);
		canvasCtx.quadraticCurveTo(finalX,finalY+aHeight,finalX+radius,finalY+aHeight);
		canvasCtx.lineTo(finalX+aWidth-radius,finalY+aHeight);
		canvasCtx.quadraticCurveTo(finalX+aWidth,finalY+aHeight,finalX+aWidth,finalY+aHeight-radius);
		canvasCtx.lineTo(finalX+aWidth,finalY+radius);
		canvasCtx.quadraticCurveTo(finalX+aWidth,finalY,finalX+aWidth-radius,finalY);
		canvasCtx.lineTo(finalX+radius,finalY);
		canvasCtx.quadraticCurveTo(finalX,finalY,finalX,finalY+radius);	
		canvasCtx.fill();
	};
	
	/**
	 * Text is placed from a top left anchor.
	 * @param x
	 * @param y
	 * @param aText
	 */
	this.drawText=function drawText (x,y,aText)
	{				
		//pointer.debug ("drawText ("+anX+","+anY+","+aText+")");
		
		if (canvasCtx==null)
			return;		
		
		var finalX=x+aliasingOffset;
		var finalY=y+aliasingOffset;
		
		try
		{
			canvasCtx.fillStyle=lineColor;
			canvasCtx.font=(textFont+" "+textSize+"pt");
			canvasCtx.fillText (aText,finalX,finalY);
		}
		
		catch (e)
		{
			alert (incompatibleBrowserMessage);
			throw new Error ("Browser does not support fillText");
		}
	};
	
	/**------------------------------------------------------------------------------------
	* drawTriangle(x1,y1,x2,y2,x3,y3)
	* @param x1: the x-coordinate of the point1
	* @param y1: the y-coordinate of the point1
	* @param x2: the x-coordinate of the point2
	* @param y2: the y-coordinate of the point2
	* @param x3: the x-coordinate of the point3
	* @param y3: the y-coordinate of the point3
	* Draws a triangle (Three points define a triangle)
	**------------------------------------------------------------------------------------*/
	this.drawTriangle=function drawTriangle(x1, y1, x2, y2, x3, y3)
	{
		if(canvasCtx==null)
		{
			pointer.debug("Error: canvas canvasCtx is NULL in drawTriangle");
		}
		
		var finalX1=x1+aliasingOffset;
		var finalX2=x2+aliasingOffset;
		var finalX3=x3+aliasingOffset;
		var finalY1=y1+aliasingOffset;
		var finalY2=y2+aliasingOffset;
		var finalY3=y3+aliasingOffset;
		
		canvasCtx.fillStyle=lineColor;
		canvasCtx.lineWidth=borderWidth;
		
		canvasCtx.beginPath();
		canvasCtx.moveTo(finalX1, finalY1);
		canvasCtx.lineTo(finalX2, finalY2);
		canvasCtx.lineTo(finalX3, finalY3);
		canvasCtx.lineTo(finalX1, finalY1);
		canvasCtx.stroke();
	};
	
	/**------------------------------------------------------------------------------------
	* drawTriangleFilled(x1:Number,y1:Number,x2:Number,y2:Number,x3:Number,y3:Number)
	* @param x1: the x-coordinate of the point1
	* @param y1: the y-coordinate of the point1
	* @param x2: the x-coordinate of the point2
	* @param y2: the y-coordinate of the point2
	* @param x3: the x-coordinate of the point3
	* @param y3: the y-coordinate of the point3
	* Draws a filled triangle (Three points define a triangle)
	**------------------------------------------------------------------------------------*/
	
	this.drawTriangleFilled=function drawTriangleFilled(x1, y1, x2, y2, x3, y3)
	{
		if(canvasCtx==null)
		{
			pointer.debug("Error: canvas canvasCtx is NULL in drawTriangleFilled");
		}
		
		var finalX1=x1+aliasingOffset;
		var finalX2=x2+aliasingOffset;
		var finalX3=x3+aliasingOffset;
		var finalY1=y1+aliasingOffset;
		var finalY2=y2+aliasingOffset;
		var finalY3=y3+aliasingOffset;
		
		canvasCtx.fillStyle=fillColor;
		canvasCtx.lineWidth=borderWidth;
		
		canvasCtx.beginPath();
		canvasCtx.moveTo(finalX1, finalY1);
		canvasCtx.lineTo(finalX2, finalY2);
		canvasCtx.lineTo(finalX3, finalY3);
		canvasCtx.lineTo(finalX1, finalY1);
		canvasCtx.fill();
	};
	
	
	//Wrapper function for save
	this.save=function save()
	{
		canvasCtx.save();
	};
	
	
	//Wrapper function for restore
	this.restore=function restore()
	{
		canvasCtx.restore();
	};
	
	
	//Wrapper function for clip
	this.clip=function clip()
	{
		canvasCtx.clip();
	};
	
	/**
	 * Paints a white rectangle over the given region.
	 */
	this.clearCanvas=function clearCanvas(x, y, width, height)
	{
		if (platform=="ctat")
		{
			canvasCtx.clearRect(x, y, width, height);
		}	
	};
}

CTATGraphicsTools.prototype = Object.create(CTATBase.prototype);
CTATGraphicsTools.prototype.constructor = CTATGraphicsTools;/**
 $Author$ 
 $Date$ 
 $Header$ 
 $Name$ 
 $Locker$ 
 $Log$
 $RCSfile$ 
 $Revision: 18954 $ 
 $Source$ 
 $State$ 

 -
 License:
 -
 ChangeLog:
 -
 Notes:
 
*/

/**
*
*/
function CTATHTMLManager ()
{	
	//CTATBase.call(this, "CTATHTMLManager","htmlManager");
	
	var aryEntities=null;
	var temper="";
	var singleQuoteEscape=true;
	var maxEntities=50;

	this.urldecode=function urldecode(str) 
	{
	   return decodeURIComponent((str+'').replace(/\+/g, '%20'));
	};
	/**
	*	
	*/
	this.showEntities=function showEntities ()
	{
		debug ("showEntities ()");

		//for (var entity:String in aryEntities)
		for (var i=0;i<aryEntities.length;i++)
		{
			entity=aryEntities [i];
			
			debug (entity);
		}
	};
	/**
	*	
	*/
	this.initEntities=function initEntities ()
	{
		if (aryEntities==null)
		{
			aryEntities=new Array();

			aryEntities["&amp;"]   = "*!*"; // non-breaking space
			aryEntities["&nbsp;"]   = "\u00A0"; // non-breaking space
			aryEntities["&iexcl;"]  = "\u00A1"; // inverted exclamation mark
			aryEntities["&cent;"]   = "\u00A2"; // cent sign
			aryEntities["&pound;"]  = "\u00A3"; // pound sign
			aryEntities["&curren;"] = "\u00A4"; // currency sign
			aryEntities["&yen;"]    = "\u00A5"; // yen sign
			aryEntities["&brvbar;"] = "\u00A6"; // broken vertical bar (|)
			aryEntities["&sect;"]   = "\u00A7"; // section sign
			aryEntities["&uml;"]    = "\u00A8"; // diaeresis
			aryEntities["&copy;"]   = "\u00A9"; // copyright sign
			aryEntities["&reg;"]    = "\u00AE"; // registered sign
			aryEntities["&deg;"]    = "\u00B0"; // degree sign
			aryEntities["&plusmn;"] = "\u00B1"; // plus-minus sign
			aryEntities["&sup1;"]   = "\u00B9"; // superscript one
			aryEntities["&sup2;"]   = "\u00B2"; // superscript two
			aryEntities["&sup3;"]   = "\u00B3"; // superscript three
			aryEntities["&acute;"]  = "\u00B4"; // acute accent
			aryEntities["&micro;"]  = "\u00B5"; // micro sign
		   	aryEntities["&frac14;"] = "\u00BC"; // vulgar fraction one quarter
		   	aryEntities["&frac12;"] = "\u00BD"; // vulgar fraction one half
		   	aryEntities["&frac34;"] = "\u00BE"; // vulgar fraction three quarters
		   	aryEntities["&iquest;"] = "\u00BF"; // inverted question mark
		   	aryEntities["&Agrave;"] = "\u00C0"; // Latin capital letter A with grave
		   	aryEntities["&Aacute;"] = "\u00C1"; // Latin capital letter A with acute
		   	aryEntities["&Acirc;"]  = "\u00C2"; // Latin capital letter A with circumflex
		   	aryEntities["&Atilde;"] = "\u00C3"; // Latin capital letter A with tilde
		   	aryEntities["&Auml;"]   = "\u00C4"; // Latin capital letter A with diaeresis
		   	aryEntities["&Aring;"]  = "\u00C5"; // Latin capital letter A with ring above
		   	aryEntities["&AElig;"]  = "\u00C6"; // Latin capital letter AE
		   	aryEntities["&Ccedil;"] = "\u00C7"; // Latin capital letter C with cedilla
		   	aryEntities["&Egrave;"] = "\u00C8"; // Latin capital letter E with grave
		   	aryEntities["&Eacute;"] = "\u00C9"; // Latin capital letter E with acute
		   	aryEntities["&Ecirc;"]  = "\u00CA"; // Latin capital letter E with circumflex
		   	aryEntities["&Euml;"]   = "\u00CB"; // Latin capital letter E with diaeresis
		   	aryEntities["&Igrave;"] = "\u00CC"; // Latin capital letter I with grave
		   	aryEntities["&Iacute;"] = "\u00CD"; // Latin capital letter I with acute
		   	aryEntities["&Icirc;"]  = "\u00CE"; // Latin capital letter I with circumflex
		   	aryEntities["&Iuml;"]   = "\u00CF"; // Latin capital letter I with diaeresis
		   	aryEntities["&ETH;"]    = "\u00D0"; // Latin capital letter ETH
		   	aryEntities["&Ntilde;"] = "\u00D1"; // Latin capital letter N with tilde
		   	aryEntities["&Ograve;"] = "\u00D2"; // Latin capital letter O with grave
		   	aryEntities["&Oacute;"] = "\u00D3"; // Latin capital letter O with acute
		   	aryEntities["&Ocirc;"]  = "\u00D4"; // Latin capital letter O with circumflex
		   	aryEntities["&Otilde;"] = "\u00D5"; // Latin capital letter O with tilde
		   	aryEntities["&Ouml;"]   = "\u00D6"; // Latin capital letter O with diaeresis
		   	aryEntities["&Oslash;"] = "\u00D8"; // Latin capital letter O with stroke
		   	aryEntities["&Ugrave;"] = "\u00D9"; // Latin capital letter U with grave
		   	aryEntities["&Uacute;"] = "\u00DA"; // Latin capital letter U with acute
		   	aryEntities["&Ucirc;"]  = "\u00DB"; // Latin capital letter U with circumflex
		   	aryEntities["&Uuml;"]   = "\u00DC"; // Latin capital letter U with diaeresis
		   	aryEntities["&Yacute;"] = "\u00DD"; // Latin capital letter Y with acute
		   	aryEntities["&THORN;"]  = "\u00DE"; // Latin capital letter THORN
		   	aryEntities["&szlig;"]  = "\u00DF"; // Latin small letter sharp s = ess-zed
		   	aryEntities["&agrave;"] = "\u00E0"; // Latin small letter a with grave
		   	aryEntities["&aacute;"] = "\u00E1"; // Latin small letter a with acute
		   	aryEntities["&acirc;"]  = "\u00E2"; // Latin small letter a with circumflex
		   	aryEntities["&atilde;"] = "\u00E3"; // Latin small letter a with tilde
		   	aryEntities["&auml;"]   = "\u00E4"; // Latin small letter a with diaeresis
		   	aryEntities["&aring;"]  = "\u00E5"; // Latin small letter a with ring above
		   	aryEntities["&aelig;"]  = "\u00E6"; // Latin small letter ae
		   	aryEntities["&ccedil;"] = "\u00E7"; // Latin small letter c with cedilla
		   	aryEntities["&egrave;"] = "\u00E8"; // Latin small letter e with grave
		   	aryEntities["&eacute;"] = "\u00E9"; // Latin small letter e with acute
		   	aryEntities["&ecirc;"]  = "\u00EA"; // Latin small letter e with circumflex
		   	aryEntities["&euml;"]   = "\u00EB"; // Latin small letter e with diaeresis
		   	aryEntities["&igrave;"] = "\u00EC"; // Latin small letter i with grave
		   	aryEntities["&iacute;"] = "\u00ED"; // Latin small letter i with acute
		   	aryEntities["&icirc;"]  = "\u00EE"; // Latin small letter i with circumflex
		   	aryEntities["&iuml;"]   = "\u00EF"; // Latin small letter i with diaeresis
		   	aryEntities["&eth;"]    = "\u00F0"; // Latin small letter eth
		   	aryEntities["&ntilde;"] = "\u00F1"; // Latin small letter n with tilde
		   	aryEntities["&ograve;"] = "\u00F2"; // Latin small letter o with grave
		   	aryEntities["&oacute;"] = "\u00F3"; // Latin small letter o with acute
		   	aryEntities["&ocirc;"]  = "\u00F4"; // Latin small letter o with circumflex
		   	aryEntities["&otilde;"] = "\u00F5"; // Latin small letter o with tilde
		   	aryEntities["&ouml;"]   = "\u00F6"; // Latin small letter o with diaeresis
		   	aryEntities["&oslash;"] = "\u00F8"; // Latin small letter o with stroke
		   	aryEntities["&ugrave;"] = "\u00F9"; // Latin small letter u with grave
		   	aryEntities["&uacute;"] = "\u00FA"; // Latin small letter u with acute
		   	aryEntities["&ucirc;"]  = "\u00FB"; // Latin small letter u with circumflex
		   	aryEntities["&uuml;"]   = "\u00FC"; // Latin small letter u with diaeresis
		   	aryEntities["&yacute;"] = "\u00FD"; // Latin small letter y with acute
		   	aryEntities["&thorn;"]  = "\u00FE"; // Latin small letter thorn
		   	aryEntities["&yuml;"]   = "\u00FF"; // Latin small letter y with diaeresis
		
		   	aryEntities["&gt;"]     = ">"; // Latin small letter thorn
		   	aryEntities["&lt;"]     = "<"; // Latin small letter y with diaeresis
		
		   	aryEntities["&#61;"]    = "="; // Why oh why did we skip this?
		   	aryEntities["&361;"]    = "="; // Why oh why did we skip this?
		
		   	aryEntities["&quot;"]   = "\u0022"; //
		}

		if (singleQuoteEscape==true)
		{
			debug ("(singleQuoteEscape==true) Replacing &apos; with: \\\'");
			aryEntities["&apos;"]   = "\\\'"; // 
		}
		else
		{
			debug ("(singleQuoteEscape==false) Replacing &apos; with: \'");
			aryEntities["&apos;"]   = "\'"; // 
		}
	};
	/**
	*	
	*/
	this.entitiesConvert=function entitiesConvert (str) 
 	{
		debug ("entitiesConvert ()");
 
		/*
		this.initEntities ();

		if (str=="&")
		{
			temper="&amp;";
			return (temper);
		}

		temper=str;
  
		if (temper==null)
		{
 			debug ("Internal error: provided string is undefined or null");
  			return ("");
		}
		
		debug ("Making the string javascript safe ...");
			
		while (temper.indexOf ("\'")!=-1)
		{
			temper=replaceString (temper,"\'","&apos;");
		}

		debug ("Javascript safe: " + temper);
  
		debug ("First pass replacing ...");

		var found=false;
		var breakout=false;

		var countEntities=0;

		while ((temper.indexOf ('&')!=-1) && (breakout==false))
		{
			found=false;
 
			//for (var entity:String in aryEntities)
			for (var i=0;i<aryEntities.length;i++)
			{
				entity=aryEntities [i];
				
  				temper=replaceString (temper,entity,aryEntities [entity]);
    				
  				found=true;
			}

			if (found==false)
			{
  				debug ("Error: unknown code found!");
  				breakout=true;
   				return temper;
			}  
 
			countEntities++;

			if (countEntities>maxEntities)
			{
  				debug ("Possible endless loop detected, aborting");
  				breakout=true;
			}
		}

		debug ("Intermediate result: " + temper);

		debug ("Final pass replacing ...");

		while (temper.indexOf ('*!*')!=-1)
		{
			temper=replaceString (temper,"*!*","&");
		}
			
		return (temper);
		
		*/
		
		return (this.urldecode (unescape (str)));
 	};
 	/**
	*	
	*/
	this.entitiesGenerate=function entitiesGenerate (str) 
 	{
		temper=str;

		return (temper);
 	};
 	
 	this.htmlEncode=function htmlEncode (value)
 	{
 		//create a in-memory div, set it's inner text(which jQuery automatically encodes)
 		//then grab the encoded contents back out.  The div never exists on the page.
		
 		//return $('<div/>').text(value).html();
		
		return value;
 	};

 	this.htmlDecode=function htmlDecode (value)
 	{
 		return $('<div/>').html(value).text();
 	}; 	
}

/*
CTATHTMLManager.prototype = Object.create(CTATBase.prototype);
CTATHTMLManager.prototype.constructor = CTATHTMLManager;
*/
/**------------------------------------------------------------------------------------
 $Author$ 
 $Date$ 
 $Header$ 
 $Name$ 
 $Locker$ 
 $Log$
 
 -
 License:
 -
 ChangeLog:
 -
 Notes:
 
*/


// In JavaScript we don't use the LinkData mechanism. Instead you will find the
// same information in CTATGlobals as globally available data./**------------------------------------------------------------------------------------
 $Author$ 
 $Date$ 
 $Header$ 
 $Name$ 
 $Locker$ 
 $Log$
 
 -
 License:
 -
 ChangeLog:
 -
 Notes:
 
*/

/**
*
*/
var stringInput = "";
var swfObjName="SWF";
var mode="disabled";

function CTATMobileTutorHandler(aName,aMode)
{
	CTATBase.call(this, "CTATMobileTutorHandler","mobiletutorhandler");
	
	this.debug ("CTATMobileTutorHandler ()");
	this.debug ("Edit moved sI");
	
	var swfObjName=aName;
	var mode=aMode;
	var onDevice=false;
	
	if( /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ) 
	{
		onDevice=true;
	}
	
	/**
	*
	*/	
	this.error=function error (aMessage)
	{
		this.debug (aMessage);
		
		alert (aMessage);
	}
		
	/**
	 * 
	 * @param aComponent One of 'landscape' or 'portrait'
	 */
	this.processOrientationChange=function processOrientationChange (orientation)
	{
		this.debug ("processOrientationChange ("+orientation+")");
		
	}	
	
	/**
	*
	*/
	this.getEnabled=function getEnabled ()
	{
		if (mode=="disabled")
		{
			return (false);
		}

		if ((mode=="auto") && (onDevice==false))
		{
			return (false);
		}		
		
		return (true);
	}
	
	/**
	 * The argument will be a component with a className of either one of:
	 * CTATTextInput, CTATTextField, CTATTextArea
	 * 
	 * @param aComponent
	 */
	this.processTextFocus=function processTextFocus (x,y,width,height,componentText)
	{
		this.debug ("processTextFocus ("+x+","+y+","+width+","+height+","+componentText+")");

		if (mode=="disabled")
		{
			return;
		}

		if ((mode=="auto") && (onDevice==false))
		{
			return;
		}
		
		stringInput = "";
		
		this.manipulateKeyboard();

		//this.setText ("Hello: " + Math.random());
	}	
	
	/**
	*
	*/
	function removeFocus ()
	{
		this.debug ("removeFocus ()");
		
	}	
	
	/**
	*
	*/
	this.processEnter=function processEnter ()
	{
		this.debug ("processEnter ()");
		
		if (mode=="disabled")
		{
			return;
		}
		
		if ((mode=="auto") && (onDevice==false))
		{
			return;
		}		
		
		var swfObject=getSafeElementById (swfObjName);			
			
		if (swfObject!=null)
		{												
			try
			{
				swfObject.processExternalEnter ();

				this.debug ("Successfully called AS3 method");
			}
			catch(err)
			{
				this.debug ("Error description: " + err.message);
			}					
		}
		else
			this.debug ("Error: unable to obtain reference to swf object");							
	}
	
	/**
	 * Called by any outside code to push a new string into the currently
	 * selected text input component
	 */
	this.setText=function setText (aString)
	{	
		this.debug ("setText ("+aString+")");
		
		if (mode=="disabled")
		{
			return;
		}
		
		if ((mode=="auto") && (onDevice==false))
		{
			return;
		}		
		
		if (selectedTextInput!=null)
		{
			this.debug ("Attempting to call HTML5 method on text object ...");
			
			var previousString=selectedTextInput.getText ();
			
			selectedTextInput.setText (previousString+aString);
		}
		else
		{	
			this.debug ("Attempting to call AS3 method ...");
			
			var swfObject=getSafeElementById(swfObjName);
			
			if (swfObject!=null)
			{												
				try
				{
					stringInput = stringInput + aString;
					this.debug (stringInput);
					swfObject.processExternalKeyboard(stringInput);

					this.debug ("Successfully called AS3 method");
				}
				catch(err)
				{
					this.debug ("Error description: " + err.message);
				}					
			}
			else
				this.debug ("Error: unable to obtain reference to swf object");										
		}
	}
	
	/**
	*
	*/
	this.manipulateKeyboard=function manipulateKeyboard()
	{		
		this.debug ("manipulateKeyboard()");
		
		if (mode=="disabled")
		{
			return;
		}
		
		if ((mode=="auto") && (onDevice==false))
		{
			return;
		}		
		
		this.hideKeyboard ();
		
		getSafeElementById("keyboardUI").style.visibility="visible";				
	};
	/**
	*
	*/
	this.hideKeyboard=function hideKeyboard () 
	{
		document.activeElement.blur();
		getSafeElementById("input").blur();
		//$("input").blur();
	};
	/**
	*
	*/	
	this.hideCustomKeyboard=function hideCustomKeyboard ()
	{
		getSafeElementById("keyboardUI").style.visibility="visible";
	}
}

CTATMobileTutorHandler.prototype = Object.create(CTATBase.prototype);
CTATMobileTutorHandler.prototype.constructor = CTATMobileTutorHandler;

/**
*
*/
function processTextFocus (x,y,width,height,componentText)
{
	mobileAPI.processTextFocus (x,y,width,height,componentText);
}
/**
*
*/
function processFocusOut ()
{
	closeK ();
}
/**------------------------------------------------------------------------------------
 $Author$ 
 $Date$ 
 $Header$ 
 $Name$ 
 $Locker$ 
 $Log$
 
 -
 License:
 -
 ChangeLog:
 -
 Notes:
 
The scrim. Modeled after the scrim in ActionScript 3.0.

At the moment, a global variable called ctatscrim (CTATGlobals.js) should be used as the scrim.

Here are is a list of the different methods:
	- scrimUp(aMessage) : Pulls up a scrim with a dialog that displays a message aMessage.
	- waitScrimUp() : Pulls up the wait scrim.
	- OKScrimUp(aMessage, aFunction) : Pulls up a scrim with a dialog message of aMessage, and executes aFunction when the ok button is clicked.
	- confirmScrimUp(prompt, onYes, onNo) : Pulls up a scrim with a prompt message, and function handlers for clicking on yes/no buttons.
	- errorScrimUp(aMessage) : Pulls up a non-removable scrim displaying an error message aMessage.
	- warningScrimUp(aMessage) : Pulls up scrim displaying a warning message aMessage, and may only be closed when the close button is clicked.
	- scrimDown() : Pulls down the scrim if it is in a state that allows it to be pulled down.
	- resizeScrim(newWidth, newHeight) : Resizes the scrim, and sets the width and height to newWidth and newHeight.

If the wait scrim is up, and you wish to pull up another scrim, you should pull down the wait scrim first for the time
being.

*/

function CTATScrim()
{
	CTATBase.call(this, "CTATScrim", "__undefined__");

	var scrimIsUp=false;
	var errorScrim=false;
	var waitScrim=true;
	var warnScrim=false;
	var connectionScrim=false;
	
	var authorTimeSet=true;
	var inAuthorTime=true;
	
	//Need an array of messages in the event the message is too long and
	//flows over the dialog box.
	var messageList=new Array();
	
	//The recursion in fitToDialogX gives us the message backwards. This is
	//used with messageList reverse that.
	var tempList=new Array();
	
	//Padding between text if it overflows
	var padding=1;
	
	var message="";
	
	var hasYesButton=false;
	var hasNoButton=false;
	var hasCloseButton=false;
	
	//Used to grab the handlers passed into the confirmScrim function
	var yesPtr=null;
	var noPtr=null;
	
	var padding=4;
	
	var scrimComponent=new CTATCanvasComponent("CTAT Scrim");
	var scrim=null;
	var dialog=null;
	var scrimMessage=null;
	
	var errorsAndWarnings=new Array();
	
	//See fitTextToDialogX method implementation for more info.
	var estPointToPixel=0;

	var scrimColor="rgba(0, 0, 0, 0.25)";
	var errorColor="rgb(255, 0, 0)";
	var warningColor="rgb(255, 255, 0)";
	var defaultColor="#CCCCCC";
	
	var scrimBorderColor=defaultColor;

	var dialogWidthRatio=6/8;
	var dialogHeightRatio=2/8;
	
	//Used to support placing scrim objects over the relatively positioned canvas
	var mainLeft=0;
	
	//The different HTML elements we use in the dialog box:
	var img=null;
	var yesButton=null;
	var noButton=null;
	var closeButton=null;
	var okButton=null;

	var scrimBorderWidth=5;

	var pointer=this;
	
	//Handler for the close button
	function closeFunction() 
	{
		warnScrim=false;
		pointer.scrimDown();
	}
	
	function clearScrim()
	{
		scrimComponent.removeComponent();
		removeHTMLElements();
	}
	
	/**
	 * Inspects the input dialog text to see if it flows over the
	 * dialog box or not. If it does, then the message is split
	 * up into multiple messages that will instead be placed from
	 * top to bottom. This must be called before fitTextToDialogY.
	 */
	function fitTextToDialogX(dialogText, rightMargin, leftMargin)
	{
		var separatedMessage="";
		
		/**
		 * Converts font points to pixels. No *real* reason why this equation
		 * is the way it is, but it seems to work ok. Only an estimate.
		 */
		var fontPoint=scrimMessage[0].getTextSize();
		estPointToPixel=((fontPoint / 2) + 1);
		
		var textLength = leftMargin+(dialogText.length * estPointToPixel);
		
		if(textLength > rightMargin)
		{
			var textArray=dialogText.split(" ");
			
			for(var i=0; i<textArray.length;i++)
			{
				if(textArray[i]=="")
				{
					textArray.splice(i, (textArray.length-i));
				}
			}
			
			//If the dialogText.split() call returns one element, it is because what is left is
			//just one long token. We need to handle this case differently.
			if(textArray.length==1)
			{
				var t=textArray[0];
				
				for(var i=0; i < t.length; i++)
				{
					textArray[i]=t[i];
				}
			}
			
			
			//Find out where we get cut off, then say the new message is everything
			//after the cutoff point. Call this function again to check if the
			//new message will be able to fit in the dialog box or not.
			
			var textSizeSum=leftMargin;
			var temp="";

			for(var i=0; i < textArray.length; i++)
			{
				textSizeSum += (textArray[i].length * estPointToPixel);

				if((textSizeSum > rightMargin) || (textArray[i]=="\n"))
				{
					//Do not count the newline char, or you will get stack overflow
					if(textArray[i]=="\n") 
					{
						i++;
					}
					
					for(var j=i; j < textArray.length; j++)
					{
						separatedMessage += textArray[j] + " ";
					}

					textArray.splice(i, textArray.length);
					fitTextToDialogX(separatedMessage, rightMargin, leftMargin);
				}

				else
				{
					temp += (textArray[i] + " ");
				}
			}

			tempList.push(temp);
		}
		else
		{
			tempList.push(dialogText);
		}
	}
	
	/**
	 * Stretches the dialog box to fit the entire message, if necessary.
	 * Must call fitTextToDialogX first. Returns the new height.
	 */
	function fitTextToDialogY(y, botMargin, marginSize)
	{
		//How much space the text uses up
		var textSize=y+((estPointToPixel+padding) * (messageList.length+1));
		
		if(textSize > botMargin)
		{
			return (textSize+marginSize);
		}
		
		return (dialog.getHeight()+marginSize);
	}
	/**
	*
	*/	
	function displayDialog(aX, aY, aWidth, aHeight)
	{
		if (platform=="google")
		{
			// This is not available for now when we're in this environment
			return;
		}	
	
		/**
		 * This should really be left alone. It seems that changing it messes up
		 * the dialog box. If it is crucial that the margin size be changed, it
		 * is probably necessary to re-write this function to be margin-sensitive.
		 */
		var marginRatio=1/8;
		
		var dialogLeftMargin=(aX+(aWidth * marginRatio));
		var dialogRightMargin=(aX+(aWidth-(aWidth * marginRatio)));
		
		var yMarginSize=(aHeight * marginRatio);
		
		var dialogTopMargin=(aY+yMarginSize);
		var dialogBottomMargin=(aY+(aHeight-yMarginSize));

		dialog=new CTATShape("container", 
							 "scrim dialog",
							 aX,
							 aY,
							 aWidth,
							 aHeight);
							 
		dialog.addPoint(0, 0);

		dialog.modifyCanvasCSS("z-index", "998");

		scrimMessage=new Array();
    
    	scrimComponent.addShape(dialog);
    	
       /**
    	* We need the text size to do text wrapping. Since the text uses the same font
    	* for all messages, we can just use a dummy object to extract this.
		*/
		scrimMessage[0]=new CTATShape("container", " ", [0], [0], 0, 0);
		 
		fitTextToDialogX(message, dialogRightMargin, dialogLeftMargin);
		
		scrimMessage[0].detatchCanvas();

		for(var i=tempList.length-1; i >= 0; i--)
		{
			messageList.push(tempList[i]);
		}
		
		dialog.setHeight(fitTextToDialogY(aY, dialogBottomMargin, yMarginSize));

		//If the text was bigger than the box, then the dialog box will need re-centered
		var mainCanvas=getSafeElementById("main-canvas");
		var newY=((mainCanvas.height/2)-(dialog.getHeight()/2));
		scrimComponent.moveShape(dialog.getName(), dialog.getXOffset(), newY);

		dialogTopMargin=(newY+(dialog.getHeight() * marginRatio));
		
		dialog.setLineColor(scrimBorderColor);
		dialog.setFillColor("white");
		dialog.setDrawWidth(scrimBorderWidth);
		dialog.setRadius(5);
		dialog.drawRoundedRectFilled();

		for(var i=0; i < messageList.length; i++)
		{
			var y=(dialogTopMargin+((estPointToPixel+padding)*(i+1)));
		
			scrimMessage[i]=new CTATShape("container", 
							 	   		  ("scrim message "+i),
							 	  		  dialogLeftMargin,
							       		  y,
							       		  aWidth,
							       		  aHeight);
							       		  
			scrimMessage[i].addPoint(0, 0);
		
			scrimMessage[i].modifyCanvasCSS("z-index", "999");       
			scrimMessage[i].setColor("black");
			scrimMessage[i].setTextFont("Verdana");
			scrimMessage[i].setTextSize(14);
			scrimMessage[i].setData(messageList[i]);
			scrimMessage[i].drawText();
			scrimComponent.addShape(scrimMessage[i]);
		}
							 
		if(hasCloseButton==true)
		{
			var buttonSizeY=20;
			var buttonSizeX=40;

			var lastMessage=scrimMessage[messageList.length-1];
			var spaceUsedUp=lastMessage.getYOffset()+lastMessage.getTextSize()+padding;
			
			if((spaceUsedUp + buttonSizeY) > dialogBottomMargin) 
			{
				yMarginSize=((spaceUsedUp+buttonSizeY) * marginRatio);
				dialog.setHeight(spaceUsedUp+buttonSizeY+yMarginSize+scrimBorderWidth);
				var placement = ((mainCanvas.height/2) - (dialog.getHeight()/2));
				
				scrimComponent.moveShape(dialog.getName(), dialog.getXOffset(), placement);
				
				dialog.setLineColor(scrimBorderColor);
				dialog.setFillColor("white");
				dialog.setDrawWidth(scrimBorderWidth);
				dialog.setRadius(5);
				dialog.drawRoundedRectFilled();
			}
			
			closeButton=makeHTMLButton(closeFunction, (aX+(dialog.getWidth()/2)-(buttonSizeX/2)), 
			                           spaceUsedUp, "close");
		}
		
		if(hasYesButton==true)
		{
			var buttonSizeY=20;
			var buttonSizeX=40;

			var lastMessage=scrimMessage[messageList.length-1];
			var spaceUsedUp=lastMessage.getYOffset()+lastMessage.getTextSize()+padding;
			
			if((spaceUsedUp + buttonSizeY) > dialogBottomMargin) 
			{
				yMarginSize=((spaceUsedUp+buttonSizeY) * marginRatio);
				dialog.setHeight(spaceUsedUp+buttonSizeY+yMarginSize+scrimBorderWidth);
				var placement = ((mainCanvas.height/2) - (dialog.getHeight()/2));
				
				scrimComponent.moveShape(dialog.getName(), dialog.getXOffset(), placement);
				
				dialog.setLineColor(scrimBorderColor);
				dialog.setFillColor("white");
				dialog.setDrawWidth(scrimBorderWidth);
				dialog.setRadius(5);
				dialog.drawRoundedRectFilled();
			}
			
			yesButton=makeHTMLButton(yesPtr, (aX+(dialog.getWidth()/2)-buttonSizeX), 
			                         spaceUsedUp, "yes");
		}
		
		if(hasNoButton==true)
		{
			var buttonSizeY=20;
			var buttonSizeX=40;

			var lastMessage=scrimMessage[messageList.length-1];
			var spaceUsedUp=lastMessage.getYOffset()+lastMessage.getTextSize()+padding;
			
			if((spaceUsedUp + buttonSizeY) > dialogBottomMargin) 
			{
				yMarginSize=((spaceUsedUp+buttonSizeY) * marginRatio);
				dialog.setHeight(spaceUsedUp+buttonSizeY+yMarginSize+scrimBorderWidth);
				var placement = ((mainCanvas.height/2) - (dialog.getHeight()/2));
				
				scrimComponent.moveShape(dialog.getName(), dialog.getXOffset(), placement);
				
				dialog.setLineColor(scrimBorderColor);
				dialog.setFillColor("white");
				dialog.setDrawWidth(scrimBorderWidth);
				dialog.setRadius(5);
				dialog.drawRoundedRectFilled();
			}
			
			noButton=makeHTMLButton(noPtr, (aX+(dialog.getWidth()/2)), 
			                        spaceUsedUp, "no");
		}
		
		if(waitScrim==true)
		{
			var spaceUsedUp=(newY+((messageList.length+1) * (estPointToPixel + padding)));
		
			//The gif we use is 64x64
			var waitGIFsize=64;
			var gifMid=(aX+(dialog.getWidth()/2)-(waitGIFsize/2));
			
			//If the gif is too big, re-size and re-position
			if((spaceUsedUp+waitGIFsize) > dialogBottomMargin)
			{
				yMarginSize=((spaceUsedUp+waitGIFsize) * marginRatio);
				dialog.setHeight(spaceUsedUp+waitGIFsize+yMarginSize);
				var placement = ((mainCanvas.height/2) - (dialog.getHeight()/2));
				
				scrimComponent.moveShape(dialog.getName(), dialog.getXOffset(), placement);
				
				dialog.setLineColor(scrimBorderColor);
				dialog.setFillColor("white");
				dialog.setRadius(5);
				dialog.drawRoundedRectFilled();
			}
		
			makeHTMLImage(rotatingLoad, gifMid, (spaceUsedUp+dialog.getTextSize()+padding));
		}
	}
	/**
	*
	*/	
	function drawScrim()
	{
		if (platform=="google")
		{
			// This is not available for now when we're in this environment
			return;
		}	
		
		//Needed to adjust the scrim over a relatively positioned canvas
		var mainCanvas=getSafeElementById("main-canvas");

		scrim=new CTATShape("container", 
							"scrim",
							0,
							0,
							mainCanvas.width+1,
							mainCanvas.height+1);
							
		scrim.addPoint(0, 0);

		scrim.modifyCanvasCSS("z-index", "998");

		scrimComponent.addShape(scrim);
		
		scrim.setColor(scrimColor);
		scrim.drawRectangleFilled();
		
		var dialogWidth=mainCanvas.width * dialogWidthRatio;
		var dialogHeight=mainCanvas.height * dialogHeightRatio;
		
		var dialogX=((mainCanvas.width/2)-(dialogWidth/2));
		var dialogY=((mainCanvas.height/2)-(dialogHeight/2));

		displayDialog(dialogX, dialogY, dialogWidth, dialogHeight);
	}
	/**
	*
	*/	
	this.scrimUp=function scrimUp(aMessage)
	{
		if (platform=="google")
		{
			// This is not available for now when we're in this environment
			return;
		}	
		
		pointer.debug("scrimUp ()");
		pointer.debug("Message: " + aMessage);

		if(scrimIsUp==true)
		{
			if(waitScrim==true)
			{
				message=aMessage;
			}
			
			else
			{
				message += " \n " + aMessage;
			}
			
			//Only need one scrim up at a time
			scrimComponent.removeComponent();
			messageList=new Array();
			tempList=new Array();
			removeHTMLElements();
		}
		
		else
		{
			message=aMessage;
			scrimIsUp=true;
		}
		
		drawScrim();
	};
	/**
	*
	*/	
	this.waitScrimUp=function waitScrimUp()
	{
		if (platform=="google")
		{
			// This is not available for now when we're in this environment
			return;
		}	
		
		pointer.debug("waitScrimUp ()");
	
		waitScrimUp=true;
		scrimBorderColor=defaultColor;
	
		pointer.scrimUp("Please wait while the tutor is being loaded");
	};
	/**
	*
	*/	
	this.nextProblemScrimUp=function nextProblemScrimUp()
	{
		if (platform=="google")
		{
			// This is not available for now when we're in this environment
			return;
		}		
	
		pointer.debug("nextProblemScrimUp ()");
	
		waitScrimUp=true;
		scrimBorderColor=defaultColor;
	
		pointer.scrimUp("Retrieving the Next Problem...");
	};	
	/**
	*
	*/	
	this.OKScrimUp=function OKScrimUp(aMessage, aFunction)
	{
		if (platform=="google")
		{
			// This is not available for now when we're in this environment
			return;
		}	
		
		pointer.debug("OKScrimUp ("+aMessage+","+aFunction+")");
	
		scrimBorderColor="black";
		pointer.scrimUp(aMessage);
		
		var buttonSizeY=10;
		var buttonSizeX=20;
		
		var marginRatio=1/8;
		var yMarginSize=(dialog.getHeight() * marginRatio);
		var dialogBottomMargin=(dialog.getYOffset()+(dialog.getHeight()-yMarginSize));

		var lastMessage=scrimMessage[messageList.length-1];
		var spaceUsedUp=lastMessage.getYOffset(0)+lastMessage.getTextSize()+padding;
		
		var x=(dialog.getXOffset()+(dialog.getWidth()/2)-(buttonSizeX/2));
			
		if((spaceUsedUp + buttonSizeY) > dialogBottomMargin) 
		{
			yMarginSize=((spaceUsedUp+buttonSizeY) * marginRatio);
			dialog.setHeight(spaceUsedUp+buttonSizeY+yMarginSize+scrimBorderWidth);
			var placement=((mainCanvas.height/2) - (dialog.getHeight()/2));
				
			scrimComponent.moveShape(dialog.getName(), dialog.getXOffset(), placement);
				
			dialog.setLineColor(scrimBorderColor);
			dialog.setFillColor("white");
			dialog.setDrawWidth(scrimBorderWidth);
			dialog.setRadius(5);
			dialog.drawRoundedRectFilled();
		}
			
		okButton=makeHTMLButton(aFunction, x, spaceUsedUp, "OK");
	};
	/**
	*
	*/	
	this.confirmScrimUp=function confirmScrimUp(prompt, onYes, onNo)
	{
		if (platform=="google")
		{
			// This is not available for now when we're in this environment
			return;
		}	
		
		pointer.debug("confirmScrimUp ("+prompt+","+onYes+","+onNo+")");
	
		scrimBorderColor=defaultColor;
		
		hasYesButton=true;
		hasNoButton=true;
		noPtr=onNo;
		yesPtr=onYes;
		
		pointer.scrimUp(prompt);
	};
	/**
	*
	*/	
	function errScrimUp(aMessage)
	{
		if (platform=="google")
		{
			// This is not available for now when we're in this environment
			return;
		}	
		
		pointer.debug("errScrimUp ("+aMessage+")");
	
		if(errorScrim==true)
		{
			scrimBorderColor=errorColor;
			
			if(hasCloseButton==true)
			{
				hasCloseButton=false;
				getSafeElementById("container").removeChild(closeButton);
			}
		}
		
		else if(warnScrim==true)
		{
			scrimBorderColor=warningColor;
			hasCloseButton=true;
		}

		pointer.scrimUp(aMessage);
	};
	/**
	*
	*/	
	this.errorScrimUp=function errorScrimUp(aMessage)
	{
		if (platform=="google")
		{
			// This is not available for now when we're in this environment
			return;
		}	
		
		if(authorTimeSet==false)
		{
			pointer.debug("we don't know if we're in authorTime or not yet so we're just going to hold onto the messasge");
			errorsAndWarnings.push("ERROR: "+aMessage);
			errorScrim=true;
			return;
		}
		
		else if(inAuthorTime==false)
		{
			pointer.debug("We're not in authorTime, student's don't need to see our design mistakes");
			// *** some kind of comm shell action goes here ***
			return;
		}
		
		errorScrim=true;
		errScrimUp("ERROR: "+aMessage);
	};
	/**
	*
	*/	
	this.warningScrimUp=function warningScrimUp(aMessage)
	{
		if (platform=="google")
		{
			// This is not available for now when we're in this environment
			return;
		}	
		
		if(authorTimeSet==false)
		{
			pointer.debug("we don't know if we're in authorTime or not yet so we're just going to hold onto the messasge");
			errorsAndWarnings.push("WARNING: "+aMessage);
			warnScrim=true;
			return;
		}
		
		else if(inAuthorTime==false)
		{
			pointer.debug("We're not in authorTime, student's don't need to see our design mistakes");
			// *** some kind of comm shell action goes here ***
			return;
		}
		
		warnScrim=true;
		errScrimUp("WARNING: "+aMessage);
	};
	/**
	*
	*/	
	this.handleTSDisconnect=function handleTSDisconnect()
	{
		connectionScrim=true;
		pointer.scrimUp("The tutor has disconnected. Please refresh the page.");
	};
	/**
	*
	*/	
	function removeHTMLElements()
	{
		var topDiv=getSafeElementById('container');

		if(img != null)
		{
			topDiv.removeChild(img);
			img=null;
		}
		
		if(yesButton != null)
		{
			topDiv.removeChild(yesButton);
			yesButton=null;
		}
		
		if(noButton != null)
		{
			topDiv.removeChild(noButton);
			noButton=null;
		}
		
		if(closeButton != null)
		{
			topDiv.removeChild(closeButton);
			closeButton=null;
		}
		
		if(okButton != null)
		{
			topDiv.removeChild(okButton);
			okButton=null;
		}
	}
	/**
	*
	*/
	this.scrimDown=function scrimDown()
	{
		if (platform=="google")
		{
			// This is not available for now when we're in this environment
			return;
		}
		
		if (scrimIsUp==false) 
		{
			pointer.debug("The scrim isn't up, returning");
			return;
		}
			
		if (errorScrim==true) 
		{
			pointer.debug("The scrim is up to describe errors to the user, leave it up!");
			return;
		}
			
		if (warnScrim==true) 
		{
			pointer.debug("The scrim is up to display warnings to the user, leave it up!");
			return;
		}
			
		if (connectionScrim==true) 
		{
			pointer.debug("The scrim is up for a connection issue leave it up!");
			return;
		}
		/*
		if (waitForClick) 
		{
			pointer.debug("The scrim is waiting on user input, leave it up!");
			return;
		}*/
		
		scrimComponent.removeComponent();
		removeHTMLElements();
		scrimIsUp=false;
		waitScrim=false;
		message="";
		messageList=new Array();
		tempList=new Array();
	};
	
	//At the moment, calling this assumes the start state was read in.
	this.resizeScrim=function resizeScrim(newWidth, newHeight)
	{
		if (platform=="google")
		{
			// This is not available for now when we're in this environment
			return;
		}	
		
		scrimComponent.removeComponent();
		removeHTMLElements();
		
		//Since we are re-rendering, we need to re-fit the message to the dialog
		messageList=new Array();
		tempList=new Array();

		drawScrim();
	};
	
	function makeHTMLImage(anImage, aX, aY)
	{
		if (platform=="google")
		{
			// This is not available for now when we're in this environment
			return;
		}	
		
		img=new Image();
		img.src=anImage;
		img.id='load gif';
		img.setAttribute('style', "left: "+aX+"px; top: "+aY+"px; z-index: 999; position: absolute;");
		
		getSafeElementById("container").appendChild(img);
	}
	
	/**
	*
	*/
	this.defaultClickHandler=function defaultClickHandler ()
	{
		pointer.debug("defaultClickHandler ()");
		pointer.scrimDown();
	};	
	
	/**
	*
	*/	
	function makeHTMLButton(clickHandle, aX, aY, btnType)
	{
		pointer.debug("makeHTMLButton ()");
	
		btn=document.createElement('input');
		btn.type='button';				
		btn.value=btnType;
		
		if (clickHandle!=null)
		{
			pointer.debug("clickHandle!=null");
		
			btn.onclick=clickHandle;
		}
		else
		{
			pointer.debug("clickHandle==null");
		
			btn.onclick=pointer.defaultClickHandler;
		}
				
		//Is it a yes, no, play, etc button
		btn.id=btnType;
		
		btn.setAttribute('style', "left: "+aX+"px; top: "+aY+"px; z-index: 999; position: absolute;");
		
		getSafeElementById("container").appendChild(btn);
		
		return (btn);
	}
		
	/**
	*
	*/	
	this.setInAuthorTime=function setInAuthorTime(theValue)
	{
		pointer.debug("setting inAuthorTime = " +theValue);
		
		authorTimeSet=true;
		authorTime=theValue;
		
		if (!theValue) 
		{
			errorScrim=false;
			warnScrim=false;
			
			if(hasCloseButton)
			{
				scrim.removeChild(closeButton);
			}
			
			scrimBorderColor=defaultColour;
		}
		
		else 
		{
			if(errorScrim || warnScrim) 
			{
				for(var mess in errorsAndWarnings) 
				{
					errScrimUp(mess);
				}
			}
		}
	};
	
	this.getInAuthorTime=function getInAuthorTime()
	{
		return (inAuthorTime);
	};
}

CTATScrim.prototype = Object.create(CTATBase.prototype);
CTATScrim.prototype.constructor = CTATScrim;/**------------------------------------------------------------------------------------
 $Author$ 
 $Date$ 
 $Header$ 
 $Name$ 
 $Locker$ 
 $Log$
 
 -
 License:
 -
 ChangeLog:
 -
 Notes:
 
 This is best used for dynamic objects. If you are simply painting something "static" (rounded rect for
 the Skill and Hint Windows for example), just use the CTATGraphicsTools code to paint.
 
 Use this with CTATCanvasComponent to create aggregates of shapes, or a "whole component" made
 of shapes. For instance, a CTATNumberLine would consist of many CTATShapes (many lines
 drawn), that will represent tick marks.
 
 The constructor takes six arguments:
 	1. anID    - ID of the div you want to add the canvas to.
 	2. aName   - The name of this shape.
 	3. startX  - The x coordinate of the canvas to be drawn on.
 	4. startY  - The y coordinate of the canvas to be drawn on.
 	5. aWidth  - The width of the canvas and the shape.
 	6. aHeight - The height of the canvas and the shape.
 	
The startX and startY coordinates are absolutely positioned. Once set, you must then call
addPoints which will set an (x, y) coordinate local to the shape's canvas.

*/

function CTATShape(anID, aName, startX, startY, aWidth, aHeight)
{
	var pointer=this;

	if((anID==undefined) || (anID==null))
	{
		pointer.debug("--- Error: Must pass a valid ID. ---");
		return null;
	}

	//Holds an array of x or y coordinates to support draw methods.
	var x=new Array();
	var y=new Array();

	var width=aWidth;
	var height=aHeight;
	var shapeName=aName;
	
	var canvasX=startX;
	var canvasY=startY;
	
	//If you want to pair up some data with a particular shape.
	//*note: this is used to hold the text for draw text
	var data=undefined;
	
	var lineColor="black";
	var fillColor="black";
	
	var textFont="Arial";
	var textSize=12;
	
	var eventHandlerList=new Array();
	
	//This is the width of the line to be drawn. Not applicable to fill methods.
	var shapeLineWidth=1;
	
	var radius=5;
		
	var canvasObject=document.createElement('canvas');
	canvasObject.id=shapeName;
	canvasObject.width=width;
	canvasObject.height=height;
		
	var canvasStyles=new CTATCSS();

	canvasStyles.addCSSAttribute("position", "absolute");
	canvasStyles.addCSSAttribute("left", canvasX+"px");
	canvasStyles.addCSSAttribute("top", canvasY+"px");
		
	//Lets us see what we draw on the canvas...
	canvasStyles.addCSSAttribute("visibility", "visible");
	
	//...without making us see the canvas itself *needs IE support
	canvasStyles.addCSSAttribute("background-color", "rgba(0, 0, 0, 0)");
	canvasStyles.addCSSAttribute("border-style", "none");	
		
	//Set the style of the canvas object to the CSS attributes set thus far
	canvasObject.setAttribute('style', canvasStyles.toCSSString());
	
	if(anID=="container")
	{
		getSafeElementById(anID).appendChild(canvasObject);
	}
	
	else
	{
		getSafeElementById('ctatdiv'+anID).appendChild(canvasObject);
	}

	var graphicTools=new CTATGraphicsTools(canvasObject.getContext("2d"));
	graphicTools.setGraphicBorderWidth(shapeLineWidth);
	graphicTools.setLineColor(lineColor);
	graphicTools.setFillColor(fillColor);
	
	/*
	this.addListener=function addListener(eventName, handler)
	{
		eventHandlerList.push([eventName, handler]);
		canvasObject.addEventListener(eventName, handler);
	};
	*/
	
	/**
	 * The get offset methods are primarily used in situations where you want to place
	 * one shape's canvas over another. Since a shape's coordinates are represented locally
	 * to its own canvas, this is needed to get the absolute positioning of its canvas.
	 */
	this.getXOffset=function getXOffset()
	{
		return (startX + x[0]);
	};
	
	
	this.getYOffset=function getYOffset()
	{
		return (startY + y[0]);
	};
	
	this.addPoint=function addPoint(addX, addY)
	{
		x.push(addX);
		y.push(addY);
	};
	
	this.getName=function getName()
	{
		return (shapeName);
	};
	
	this.getXPoint=function getXPoint(index)
	{
		return (x[index]);
	};
	
	this.getYPoint=function getYPoint(index)
	{
		return (y[index]);
	};
	
	this.getWidth=function getWidth()
	{
		return (width);
	};
	
	this.getHeight=function getHeight()
	{
		return (height);
	};
	
	this.getName=function getName()
	{
		return (shapeName);
	};
	
	this.getData=function getData()
	{
		return (data);
	};
	
	this.getColor=function getColor()
	{
		return (color);
	};
	
	this.getRadius=function getRadius()
	{
		return (radius);
	};
	
	this.getTextFont=function getTextFont()
	{
		return (textFont);
	};
	
	this.getTextSize=function getTextSize()
	{
		return (textSize);
	};
	
	this.getLineColor=function getLineColor()
	{
		return (lineColor);
	};
	
	this.getFillColor=function getFillColor()
	{
		return (fillColor);
	};
	
	this.setXPoints=function setXPoints(xPoints)
	{
		x=xPoints;
		canvasStyles.modifyCSSAttribute("left", x[0]+"px");
		canvasObject.setAttribute('style', canvasStyles.toCSSString());
	};
	
	this.setYPoints=function setYPoints(yPoints)
	{
		y=yPoints;
		canvasStyles.modifyCSSAttribute("top", y[0]+"px");
		canvasObject.setAttribute('style', canvasStyles.toCSSString());
	};
	
	this.setWidth=function setWidth(aWidth)
	{
		width=aWidth;
		
		if(anID != "main-canvas")
		{
			canvasObject.width=width;
		}
	};
	
	this.setHeight=function setHeight(aHeight)
	{
		height=aHeight;
		
		if(anID != "main-canvas")
		{
			canvasObject.height=height;
		}
	};
	
	this.setName=function setName(aName)
	{
		shapeName=aName;
	};
	
	this.setData=function setData(aData)
	{
		data=aData;
	};
	
	this.setFillColor=function setFillColor(aColor)
	{
		fillColor=aColor;
		graphicTools.setFillColor(aColor);
	};
	
	this.setLineColor=function setLineColor(aColor)
	{
		lineColor=aColor;
		graphicTools.setLineColor(aColor);
	};
	
	this.setDrawWidth=function setDrawWidth(aDrawWidth)
	{
		shapeLineWidth=aDrawWidth;
		graphicTools.setGraphicBorderWidth(shapeLineWidth);
	};
	
	this.setRadius=function setRadius(aRadius)
	{
		radius=aRadius;
	};
	
	this.setColor=function setColor(aColor)
	{
		lineColor=aColor;
		fillColor=aColor;
		
		graphicTools.setLineColor(lineColor);
		graphicTools.setFillColor(fillColor);
	};
	
	this.setTextFont=function setTextFont(aFont)
	{
		textFont=aFont;
		graphicTools.setFont(textFont);
	};
	
	this.setTextSize=function setTextSize(aSize)
	{
		textSize=aSize;
		graphicTools.setFontSize(textSize);
	};

	this.modifyCanvasCSS=function modifyCanvasCSS(attrib, value)
	{
		canvasStyles.modifyCSSAttribute(attrib, value);
		canvasObject.setAttribute('style', canvasStyles.toCSSString());
	};
	
	this.detatchCanvas=function detatchCanvas()
	{
		if(anID=="container")
		{
			getSafeElementById(anID).removeChild(canvasObject);
		}
	
		else
		{
			getSafeElementById('ctatdiv'+anID).removeChild(canvasObject);
		}
	};
	
	this.shapeMagicTrigFunctionX=function shapeMagicTrigFunctionX(pointRatio)
	{
		graphicTools.magicTrigFunctionX(pointRatio);
	};

	this.shapeMagicTrigFunctionY=function shapeMagicTrigFunctionY(pointRatio)
	{
		graphicTools.magicTrigFunctionY(pointRatio);
	};
	
	this.drawLine=function drawLine()
	{
		graphicTools.drawLine(x[0]+shapeLineWidth, y[0]+shapeLineWidth, x[1], y[1], color, shapeLineWidth);
	};

	/**
	 * The draw circle methods require us to begin at (initial+radius) because HTML5 assumes
	 * that (0, 0) is at the center of the circle, rather than at the corner.
	 */
	this.drawCircle=function drawCircle()
	{
		graphicTools.drawCircle(x[0]+radius, y[0]+radius, radius);
	};

	this.drawCircleFilled=function drawCircleFilled()
	{
		graphicTools.drawCircleFilled(x[0]+radius, y[0]+radius, radius-1);
	};

	this.drawRectangle=function drawRectangle(x, y, aWidth, aHeight)
	{
		graphicTools.drawRectangle(x[0]+shapeLineWidth, y[0]+shapeLineWidth, width-shapeLineWidth, height-shapeLineWidth);
	};

	this.drawRectangleFilled=function drawRectangleFilled()
	{
		graphicTools.drawRectangleFilled(x[0], y[0], width, height);
	};
	
	this.drawRoundedRect=function drawRoundedRect ()
	{		
		graphicTools.drawRoundedRect(x[0]+shapeLineWidth, y[0]+shapeLineWidth, width-radius-shapeLineWidth, height-radius-shapeLineWidth, radius);
	};
	
	this.drawRoundedRectFilled=function drawRoundedRectFilled ()
	{
		graphicTools.drawRoundedRectFilled(x[0]+shapeLineWidth, y[0]+shapeLineWidth, width-radius-shapeLineWidth, height-radius-shapeLineWidth, radius);
	};
	
	this.drawText=function drawText ()
	{				
		graphicTools.drawText((textSize/2), (textSize/2), data);
	};
	
	this.drawTriangle=function drawTriangle()
	{
		graphicTools.drawTriangle(x[0]+shapeLineWidth, y[0]+shapeLineWidth, x[1], y[1], x[2], y[2]);
	};

	this.drawTriangleFilled=function drawTriangleFilled()
	{
		graphicTools.drawTriangleFilled(x[0], y[0], x[1], y[1], x[2], y[2]);
	};

	this.save=function save()
	{
		graphicTools.save();
	};

	this.restore=function restore()
	{
		graphicTools.restore();
	};

	this.clip=function clip()
	{
		graphicTools.clip();
	};
	
	/**
	 * Gives you a new canvas to draw on, but is situated in the same
	 * spot as the last one. Doing so effectively "erases" the painted object.
	 */
	this.erase=function erase()
	{
		pointer.detatchCanvas();
		x=new Array();
		y=new Array();
	
		canvasObject=document.createElement('canvas');
		canvasObject.id=shapeName;
		canvasObject.width=width;
		canvasObject.height=height;
		
		canvasStyles=new CTATCSS();

		canvasStyles.addCSSAttribute("position", "absolute");
		canvasStyles.addCSSAttribute("left", canvasX+"px");
		canvasStyles.addCSSAttribute("top", canvasY+"px");
		
		canvasStyles.addCSSAttribute("visibility", "visible");
		canvasStyles.addCSSAttribute("background-color", "rgba(0, 0, 0, 0)");
		canvasStyles.addCSSAttribute("border-style", "none");	
		
		canvasObject.setAttribute('style', canvasStyles.toCSSString());
		
		if(anID=="container")
		{
			getSafeElementById(anID).appendChild(canvasObject);
		}
	
		else
		{
			getSafeElementById('ctatdiv'+anID).appendChild(canvasObject);
		}
		
		//Add the event listeners from the last canvas
		for(var i=0; i < eventHandlerList.length; i++)
		{
			canvasObject.addEventListener(eventHandlerList[i][0], eventHandlerList[i][1]);
		}
	};	
}
/**------------------------------------------------------------------------------------
 $Author$ 
 $Date$ 
 $Header$ 
 $Name$ 
 $Locker$ 
 $Log$
 
 -
 License:
 -
 ChangeLog:
 -
 Notes:
 
*/

/**
*
*/
function CTATStringUtil ()
{	
	/**
	* Apparently AS3 expects a direct conversion between a string and a boolean to only
	* happen when the string is '0' or '1' for every other case we have to test manually.
	* So this method pretty much catches all varieties.
	*/	
	this.String2Boolean=function String2Boolean (aString)
	{
		switch(aString) 
		{     
			case "1":     
			case "true":     
			case "yes":     
			case "TRUE":     
			case "YES":
			case "Yes":					
						return true;     
			case "0":     
			case "false":     
			case "no":
			case "FALSE":     
			case "NO":
			case "No":
						return false;						
		}
	
		return (true);		
	}
	/**
	*	
	*/
	this.replaceString=function replaceString (thisStr,searchStr,replaceStr) 
	{	
		return (thisStr.replace(searchStr,replaceStr));
	};	
}
function CTATStyle()
{
	this.styleName="";
	this.styleValue="";
}/**------------------------------------------------------------------------------------
 $Author$ 
 $Date$ 
 $Header$ 
 $Name$ 
 $Locker$ 
 $Log$
 
 -
 License:
 -
 ChangeLog:
 -
 Notes:
 
*/

/**
 * 
 */
function s4() 
{
  return Math.floor((1 + Math.random()) * 0x10000)
             .toString(16)
             .substring(1);
};

/** 
 * @returns {String}
 */
function guid() 
{
  return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
         s4() + '-' + s4() + s4() + s4();
}

/**
*
*/
/*
Object.size = function(obj) 
{
    var size = 0, key;
    
    for (key in obj) 
    {
        if (obj.hasOwnProperty(key)) size++;
    }
    return size;
};
*/

/**
*
*/
function htmlEscape(str) 
{
    return String(str)
            .replace(/&/g, '&amp;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#39;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');
}

/**
*
*/
function htmlUnescape(value)
{
    return String(value)
        .replace(/&quot;/g, '"')
        .replace(/&#39;/g, "'")
        .replace(/&lt;/g, '<')
        .replace(/&gt;/g, '>')
        .replace(/&amp;/g, '&');
}

/**
*
*/
function isBlank(str) 
{
	return (!str || /^\s*$/.test(str));
}

/**
* http://quocity.com/colresizable/
*/	
function tableCreate()
{
    var body = document.body;
	var tbl  = document.createElement('table');
    tbl.style.width='100%';
    tbl.style.border = "1px solid black";

    for(var i = 0; i < 3; i++)
	{
        var tr = tbl.insertRow();
		
        for(var j = 0; j < 2; j++)
		{
            if(i==2 && j==1)
			{
                    break
            } 
			else 
			{
                var td = tr.insertCell();
				
                td.appendChild(document.createTextNode('\u0020'))
				
                if(i==1&&j==1)
				{
                    td.setAttribute('rowSpan','2');
                }
            }
        }
    }
	
    body.appendChild(tbl);
	
	return (tbl1);
}
/**------------------------------------------------------------------------------------
 $Author$ 
 $Date$ 
 $Header$ 
 $Name$ 
 $Locker$ 
 $Log$
 
 -
 License:
 -
 ChangeLog:
 -
 Notes:
 
 http://mottie.github.io/tablesorter/docs/example-widget-resizable.html
 
*/

var hintWindowWidth=350;
var hintWindowHeight=100;
var component=null;
var drawing=false;
var onMobile=false;

var ctatscrim=new CTATScrim();
var parser=new CTATXML ();

/**
*
*/
function assignNameTranslator (aTranslator)
{
	nameTranslator=aTranslator;
}
/**
 * 
 */
function clear ()
{
	debug ("clear ()");
				
	if (platform=="ctat")
	{	
		ctx.clearRect(0,0,canvasWidth,canvasHeight);
	}	
}
/**
 * 
 */
function drawTutor ()
{
	//debug ("drawTutor ()");
	
	if (drawing==true)
	{
		return;
	}	
	
	drawing=true;
	
	/*
	if (commShell!=null)
	{
		var mHandler=commShell.getMessageHandler ();
		
		if (mHandler!=null)
		{
			mHandler.displayComponentList ();
		}
		else
			debug ("Error: can't get pointer to message handler");
	}
	*/	
	
	clear ();
		
	for (var i=0;i<components.length;i++)
	{
		var aDesc=components [i];
		
		//debug ("Drawing component: " + i);
		
		var component=aDesc.getComponentPointer ();
		
		if (component!=null)
		{
			//debug ("Drawing component: " + aDesc.name);
			
			component.drawComponent ();
		}			
	}
	drawing=false;
}
/**
 * 
 */
function getComponentFromDescription (aDescription)
{
	var result=null;
	
	return (result);
}
/**
 * 
 */
function getComponentDescriptionFromComponent (aComponent)
{
	var result=null;
	
	return (result);
}
/**
 * 
 */
function addComponent (aComponent)
{
	debug ("addComponent ()");
	
	// We should already have the component description in the list
	// and a pointer to the component is already assigned to the
	// description in the component's constructor

	aComponent.init ();
	aComponent.processSerialization ();
	aComponent.render ();
}
/**
 * 
 */
function addTextInput (anX,anY,aWidth,aHeight)
{
	debug ("addTextInput ("+anX+","+anY+")");
	
	var textBox=new CTATTextField (canvas,ctx,anX,anY,aWidth,aHeight);
	textBox.init ();	
}
/**
 * 
 */
function createTextComponent (anX,anY,aWidth,aHeight)
{
	var inp=new CTATTextField (canvas,ctx,null,anX,anY,aWidth,aHeight);
	inp.fontFamily="Arial";	
	inp.fontSize=20;	
	inp.showBorder=true;
	inp.enabled=true;
	inp.align='center';
	
	addComponent (inp4);
	
	return (inp);
}
/**
*
*/
function createSidebarInterface (aCanvasWidth,aCanvasHeight)
{
	debug ("createSidebarInterface ("+aCanvasWidth+","+aCanvasHeight+")");
	
	var tutorWidth=aCanvasWidth-4; // assume a 2 pixel margin
	var tutorHeight=aCanvasHeight-4; // assume a 2 pixel margin
	
	var dummyDescription=new Object ();
	
	//>------------------------------------------------------
	
	debug ("Creating (CTATSkillWindow)...");
	
	dummyDescription.name="skillwindow";
	dummyDescription.type="CTATSkillWindow";
	dummyDescription.x=5;
	dummyDescription.y=5;
	dummyDescription.width=tutorWidth-10;
	dummyDescription.height=100;
	
	var skillWindow=new CTATSkillWindow (dummyDescription,5,5,tutorWidth-10,100);
	skillWindow.setName ("skillwindow");
		
	addComponent (skillWindow);
		
	//>------------------------------------------------------

	debug ("Creating (CTATHintButton)...");
	
	dummyDescription.name="hint";
	dummyDescription.type="CTATHintButton";
	dummyDescription.x=5;
	dummyDescription.y=tutorHeight-61-5;
	dummyDescription.width=61;
	dummyDescription.height=61;	
	
	var hint=new CTATImageButton (dummyDescription,5,tutorHeight-61,61,61);
	hint.setName ("hint");
	hint.setClassName ("CTATHintButton");
	//hint.assignImages (hintDefault,hintHover,hintClick,hintDisabled);
	
	hint.assignImages ("https://qa.pact.cs.cmu.edu/images/skindata/Hint-Default.png",
					   "https://qa.pact.cs.cmu.edu/images/skindata/Hint-Hover.png",
					   "https://qa.pact.cs.cmu.edu/images/skindata/Hint-Click.png",
					   "https://qa.pact.cs.cmu.edu/images/skindata/Hint-Disabled.png");
		
	addComponent (hint);

	//pointer.addSafeEventListener ('click',hint.processClick,hint);

	//>------------------------------------------------------

	debug ("Creating (CTATDoneButton)...");

	dummyDescription.name="done";
	dummyDescription.type="CTATDoneButton";
	dummyDescription.x=tutorWidth-61-5;
	dummyDescription.y=tutorHeight-61-5;
	dummyDescription.width=61;
	dummyDescription.height=61;		
	
	var done=new CTATImageButton (dummyDescription,tutorWidth-61,tutorHeight-61,61,61);
	done.setName("done");
	done.setClassName ("CTATDoneButton");
	//done.assignImages (doneDefault,doneHover,doneClick,doneDisabled);
	done.assignImages ("https://qa.pact.cs.cmu.edu/images/skindata/Done-Default.png",
					   "https://qa.pact.cs.cmu.edu/images/skindata/Done-Hover.png",
					   "https://qa.pact.cs.cmu.edu/images/skindata/Done-Click.png",
					   "https://qa.pact.cs.cmu.edu/images/skindata/Done-Disabled.png");
		
	addComponent (done);			

	//pointer.addSafeEventListener ('click',done.processClick,done);

	//>------------------------------------------------------
	
	debug ("Creating (CTATHintWindow)...");
	
	dummyDescription.name="done";
	dummyDescription.type="CTATDoneButton";
	dummyDescription.x=5;
	dummyDescription.y=115;
	dummyDescription.width=tutorWidth-10;
	dummyDescription.height=tutorHeight-61-25-100;		
		
	var hintWindow=new CTATHintWindow (dummyDescription,5,115,tutorWidth-10,tutorHeight-61-25-100);
	hintWindow.setName ("hintwindow");
		
	addComponent (hintWindow);	
	
	//>------------------------------------------------------			
}
/**
*
*/	
function initialize() 
{			
	var useragent = navigator.userAgent.toLowerCase();
	
	//alert ("User-agent header sent: " + navigator.userAgent);
		
	if (useragent.search("iphone")>0)
	{
		//alert ('ipone');
		onMobile=true;
	}
	else if (useragent.search("ipod")>0)
	{
		//alert ('ipod');
		onMobile=true;	    
	}
	else if (useragent.search("android")>0)
	{
		//alert ('android');
		onMobile=true;
	}	
	
	//alert ("onMobile: " + onMobile);
	
	var isMobile=getSafeElementById("pageor");
	if (isMobile!=null)
	{
		if (onMobile==false)
		{
			//alert ('hiding page orientation ...');
			
			isMobile.style.display='none';
		}
	}
	
	debug ("initialize ()");
	
	commShell=new CTATCommShell ();
	commShell.init (this);

	canvasWidth=ctatcanvas.width;
	canvasHeight=ctatcanvas.height;
	
	debug ("Canvas: " +canvasWidth + "," + canvasHeight);		
}
/**
*
*/	
function initializeSidebar() 
{					
	debug ("initializeSidebar ()");
	
	commShell=new CTATCommShell ();
	commShell.init (this);	
	
	if (platform=="ctat")
	{
		// Create our own version of the sidebar
		
		canvasWidth=ctatcanvas.width;
		canvasHeight=ctatcanvas.height;
	
		debug ("Canvas: " +canvasWidth + "," + canvasHeight);
				
		createSidebarInterface (canvasWidth,canvasHeight);
	}
	else
	{
		// Create the Google sidebar
	}		
}
/**
 * 
 */
this.createInterface=function createInterface ()
{
	debug ("createInterface ("+components.length+")");
	
	// First rebuild the basic interface from the serialized interface
		
	var decString="";
	var x=0;
	var y=0;
	var width=50;
	var height=50;
	var instName="";
		
	if (interfaceElement!=null)
	{
		debug ("Re-creating interface ...");
		
		var intProps=interfaceElement.childNodes;
		
		//useDebugging=true;
		
		this.createStaticInterface (null,intProps,null);				
		
		//useDebugging=false;
	}
		
	// Next create all the CTAT components ... 
	
	for (var i=0;i<components.length;i++)
	{
		var aDesc=components [i];

		if (aDesc==null)
		{
			alert ("Internal error parsing component at index " + i);
			return;
		}
		
		if (aDesc.name==null)
		{
			alert ("Internal error parsing component at index " + i + " (no name attribute available)");
			return;
		}
		
		if (aDesc.name.indexOf ("null.")==-1)
		{
			debug ("Component: " + aDesc.name + ", type: " + aDesc.type);

			if (aDesc.type=="CTATCommShell")
			{
				if (commShell!=null)
				{
					commShell.setName (aDesc.name);
				}
				
				if (aDesc.type=="CTATCommShell")
				{
					debug ("Tutor dimensions: " + aDesc.width + "x" + aDesc.height);
					
					//>---------------------------------------------------------------
					
					var tutorCanvas=getSafeElementById("main-canvas");
					
					if (tutorCanvas!=null)
					{
						debug ("Setting canvas dimensions from: " + tutorCanvas.width+"px, "+ tutorCanvas.height+"px, to: " + aDesc.width+"px, "+ aDesc.height+"px");

						tutorCanvas.width=aDesc.width;
						tutorCanvas.height=aDesc.height;

						tutorCanvas.style.width=aDesc.width;
						tutorCanvas.style.height=aDesc.height;
										
						debug ("Canvas dimensions now: " + tutorCanvas.width+"px, "+ tutorCanvas.height+"px");

						centerTutor(aDesc.width, aDesc.height);
						ctatscrim.resizeScrim(aDesc.width, aDesc.height);
					}
					else
						debug ("Error: tutor canvas is null, can't adjust size");
					
					//>---------------------------------------------------------------				
					
					var tutorContainer=getSafeElementById("container");
					
					if (tutorContainer!=null)
					{
						tutorContainer.style.width=(aDesc.width+"px");
						tutorContainer.style.height=(aDesc.height+"px");
					}
					else
						debug ("Error: tutor container is null, can't adjust size");
					
				//>---------------------------------------------------------------				
				}
			}

			if ((aDesc.type=="CTATTextInput") || (aDesc.type=="CTATTextArea")) // we'll use the same code for now
			{
				debug ("Creating: " + aDesc.name);
								
				var comp=new CTATTextInput (aDesc,
											aDesc.x,
											aDesc.y,
											aDesc.width,
											aDesc.height);
				comp.setName (aDesc.name);
				comp.setEnabled (true);
				
				aDesc.setComponentPointer (comp);
				
				addComponent (comp);				
			}
			
			if (aDesc.type=="CTATButton")								
			{
				//useDebugging=true;
				
				debug ("Creating (CTATButton):" + aDesc.name);
			
				var buttonTest=new CTATButton (aDesc,
											   aDesc.x,
											   aDesc.y,
											   aDesc.width,
											   aDesc.height);
				buttonTest.setName(aDesc.name);
				
				aDesc.setComponentPointer (buttonTest);
				
				addComponent (buttonTest);
				
				//useDebugging=false;
			}	
		
			if (aDesc.type=="CTATImageButton")
			{
				debug ("Creating (CTATImageButton):" + aDesc.name);
				
				/*
				var imageButton=new CTATImageButton (canvas,ctx,aDesc,aDesc.x,aDesc.y,aDesc.width,aDesc.height);
				imageButton.setName ("imageButton");
				imageButton.assignImages ('skindata/Hint-Default.png','skindata/Hint-Hover.png','skindata/Hint-Click.png','skindata/Hint-Disabled.png');														
				addComponent (hint);
				*/			
			}
		
			if (aDesc.type=="CTATSkillWindow")
			{								
				debug ("Creating (CTATSkillWindow): " + aDesc.name);
				
				var skillWindow=new CTATSkillWindow (aDesc,
													 aDesc.x,
													 aDesc.y,
													 aDesc.width,
													 aDesc.height);
				skillWindow.setName (aDesc.name);
				
				aDesc.setComponentPointer (skillWindow);
				
				addComponent (skillWindow);			
			}
		
			if (aDesc.type=="CTATHintWindow")
			{								
				debug ("Creating (CTATHintWindow): " + aDesc.name);
				
				var hintWindow=new CTATHintWindow (aDesc,
												   aDesc.x,
												   aDesc.y,
												   aDesc.width,
												   aDesc.height);
				hintWindow.setName (aDesc.name);
				
				aDesc.setComponentPointer (hintWindow);
				
				addComponent (hintWindow);
			}
		
			if (aDesc.type=="CTATHintButton")
			{
				debug ("Creating (CTATHintButton):" + aDesc.name);
				
				var hint=new CTATImageButton (aDesc,
											  aDesc.x,
											  aDesc.y,
											  aDesc.width,
											  aDesc.height);
				hint.setName ("hint");
				hint.setClassName ("CTATHintButton");
				hint.assignImages (hintDefault,hintHover,hintClick,hintDisabled);
				
				aDesc.setComponentPointer (hint);
				
				addComponent (hint);

				hint.addSafeEventListener ('click',hint.processClick,null);
			}
		
			if (aDesc.type=="CTATDoneButton")
			{
				debug ("Creating (CTATDoneButton):" + aDesc.name);

				var done=new CTATImageButton (aDesc,
											  aDesc.x,
											  aDesc.y,
											  aDesc.width,
											  aDesc.height);
				done.setName("done");
				done.setClassName ("CTATDoneButton");
				done.assignImages (doneDefault,doneHover,doneClick,doneDisabled);
				
				aDesc.setComponentPointer (done);
				
				addComponent (done);			

				hint.addSafeEventListener ('click',done.processClick,done);
			}						
			
			if (aDesc.type=="CTATAudioButton")
			{
				debug ("Creating (CTATAudioButton):" + aDesc.name);
				
				var audioButton=new CTATAudioButton (aDesc,
													 aDesc.x,
													 aDesc.y,
													 aDesc.width,
													 aDesc.height);
				audioButton.setName (aDesc.name);								
				audioButton.assignImages('/skindata/audio-default.png',null, '/skindata/audio-hover.png', null);
				
				aDesc.setComponentPointer (audioButton);
				
				addComponent (audioButton);				
			}
			
			if (aDesc.type=="CTATTable")
			{
				debug ("Creating (CTATTable):" + aDesc.name);
				
				var table=new CTATTable (aDesc,
										 aDesc.x,
										 aDesc.y,
										 aDesc.width,
										 aDesc.height);
				table.setName (aDesc.name);
				
				aDesc.setComponentPointer (table);
				
				addComponent (table);				
			}
			
			if (aDesc.type=="CTATVideo")
			{
				debug ("Creating (CTATVideo):" + aDesc.name);
				
				var video=new CTATVideo (aDesc,
										 aDesc.x,
										 aDesc.y,
										 aDesc.width,
										 aDesc.height);
				video.setName (aDesc.name);
				
				aDesc.setComponentPointer (video);
				
				addComponent (video);				
			}
			
			if (aDesc.type=="CTATRadioButton")
			{
				debug ("Creating (CTATRadioButton):" + aDesc.name);
				
				var radio=new CTATRadioButton (aDesc,
											   aDesc.x,
											   aDesc.y,
											   aDesc.width,
											   aDesc.height);
				radio.setName (aDesc.name);
				
				aDesc.setComponentPointer (radio);
				
				addComponent (radio);				
			}			
			
			if (aDesc.type=="CTATComboBox")
			{
				debug ("Creating (CTATComboBox):" + aDesc.name);
				
				var combo=new CTATComboBox (aDesc,
											aDesc.x,
											aDesc.y,
											aDesc.width,
											aDesc.height);
				combo.setName (aDesc.name);
				
				aDesc.setComponentPointer (combo);
				
				addComponent (combo);				
			}			
						
			if (aDesc.type=="CTATCheckBox")
			{
				debug ("Creating (CTATCheckBox):" + aDesc.name);
				
				var checkbox=new CTATCheckBox (aDesc,
											   aDesc.x,
											   aDesc.y,
											   aDesc.width,
											   aDesc.height);
				checkbox.setName (aDesc.name);
				
				aDesc.setComponentPointer (checkbox);
				
				addComponent (checkbox);				
			}
			
			if (aDesc.type=="CTATScrollPaneComponent")
			{
				debug ("Creating (CTATScrollPaneComponent):" + aDesc.name);
				
				var scrollpane=new CTATScrollPaneComponent (aDesc,
															aDesc.x,
															aDesc.y,
															aDesc.width,
															aDesc.height);
				scrollpane.setName (aDesc.name);
				
				aDesc.setComponentPointer (scrollpane);
				
				addComponent (scrollpane);				
			}			
			
			if (aDesc.type=="CTATComponentContainerReference")
			{
				debug ("Creating (CTATComponentContainerReference):" + aDesc.name);
				
				var group=new CTATGroupingComponent (aDesc.name);
				
				addComponent (group);
			}
		}
	}

	/*
	useDebugging=true;	
	var tools=new CTATShellTools ();
	tools.listComponents ();	
	useDebugging=false;
	*/	
	
	this.postProcess ();
	
	this.drawTutor ();
	
	ctatscrim.scrimDown ();
};
/**
*
*/
this.postProcess=function postProcess ()
{
	debug ("postProcess ()");
	
	//>----------------------------------------------------------------------------------
	
	for (var i=0;i<components.length;i++)
	{
		var ref=components [i];
			
		//debug ("Obtaining component for " + ref.name + " with type: " + ref.type);
			
		var component=ref.getComponentPointer ();
			
		if (component!=null)
		{
			//>---------------------------------------------------------------------------------
		
			if (component.getClassName ()=="CTATTable")
			{
				component.adjustTableContents ();				
			}	
			
			//>---------------------------------------------------------------------------------

			if ((component.getClassName ()=="CTATScrollPaneComponent") || (component.getClassName ()=="CTATComponentContainerReference"))
			{
				component.postProcess ();
			}
			//>---------------------------------------------------------------------------------
		}
		else
		{
			debug ("Error: component pointer is null");
		}
	}
	
	//>----------------------------------------------------------------------------------	
};
/**
*
*/
this.createStaticInterface=function createStaticInterface (aParent,intProps,aMovieClip)
{
	debug ("createStaticInterface ()");

	var parent=getSafeElementById("container");

	if (aParent!=null)
		parent=aParent;

	for (var t=0;t<intProps.length;t++)
	{
		var intNode=intProps [t];
									
		debug (intNode.nodeName);
			
		if (intNode.nodeName=="timeline")
		{
			debug ("Timeline node found, obtaining visual elements ...");
							
			this.createStaticInterface (null,intNode.childNodes,null);
			
			return; // we know there's nothing more in there here
		}	
			
					
		if (intNode.nodeName=="ctatcomponent")
		{		
			var inst=intNode.attributes.getNamedItem("instance").value;
								
			if (aMovieClip!=null)
			{
				debug ("Registering existence of CTAT component on MovieClip container: " + inst);
						
				aMovieClip.addComponent (inst);
			}
			//else
			//	debug ("Internal error: no MovieClip object available to attach CTAT component reference to");
		}
					
		//>--------------------------------------------------------------------
					
		if (intNode.nodeName=="shape")
		{												
			x=intNode.attributes.getNamedItem("x").value;
			y=intNode.attributes.getNamedItem("y").value;
			width=intNode.attributes.getNamedItem("width").value;
			height=intNode.attributes.getNamedItem("height").value;
			instName=intNode.attributes.getNamedItem("instance").value;
												
			debug ("Creating shape: " + instName + " at: " + x +","+ y+","+width+","+height);
						
			descString=("data:image/png;base64, "+parser.getNodeTextValue (intNode));
																
			var imgA=new Image();

			imgA.setAttribute("style", "position: absolute; top: " + y + "px; left:" + x + "px; z-index:"+currentZIndex+";");
			imgA.setAttribute('id',instName);
			imgA.setAttribute('src',descString);
					
			parent.appendChild(imgA);
						
			currentZIndex++;
		}
					
		//>--------------------------------------------------------------------					
					
		if (intNode.nodeName=="statictext")
		{				
			x=intNode.attributes.getNamedItem("x").value;
			y=intNode.attributes.getNamedItem("y").value;
			width=intNode.attributes.getNamedItem("width").value;
			height=intNode.attributes.getNamedItem("height").value;		
			instName=intNode.attributes.getNamedItem("instance").value;
						
			debug ("Creating static text: " + instName + " at: " + x +","+ y+","+width+","+height);
						
			descString=("data:image/png;base64, "+parser.getNodeTextValue (intNode));
											
			var imgB=new Image();

			imgB.setAttribute("style", "position: absolute; top: " + y + "px; left:" + x + "px; z-index:"+currentZIndex+";");
			imgB.setAttribute('id',instName);
			imgB.setAttribute('src',descString);
					
			parent.appendChild(imgB);
						
			currentZIndex++;					
		}
					
		//>--------------------------------------------------------------------
					
		if (intNode.nodeName=="movieclip")
		{
			instName=intNode.attributes.getNamedItem("instance").value;
					
			debug ("Creating movieclip: " + instName);
																
			var aX=intNode.attributes.getNamedItem("x").value;
			var aY=intNode.attributes.getNamedItem("y").value;
			var aWidth=intNode.attributes.getNamedItem("width").value;
			var aHeight=intNode.attributes.getNamedItem("height").value;								
			
			var aClip=new CTATMovieClip (instName,aX,aY,aWidth,aHeight);

			var newParent=aClip.wrapComponent (parent);			
					
			debug ("Created movieclip: " + instName + " at: " + aClip.x +","+ aClip.y+","+aClip.width+","+aClip.height);										
										
			movieclips.push (aClip);
					
			var subProps=intNode.childNodes;
						
			this.createStaticInterface (newParent,subProps,aClip);
		}
				
		//>--------------------------------------------------------------------									
	}
};

/**
 * 
 */
function runTutor (aVars)
{
	debug ("runTutor ()");

	if (tutorRunning==true)
	{
		debug ("The tutor is already running");
		return;
	}	
	
	skillSet=new CTATSkillSet ();
	flashVars=new CTATFlashVars ();
	flashVars.assignRawFlashVars(aVars);
		
	window.onerror = function(errorMsg, url, lineNumber) 
	{
	    //var debugPointer = new CTATBase("", "");
	    
	    var formatter=new CTATHTMLManager ();
	    
	    debug(formatter.htmlEncode (errorMsg) + " in " + url + ", line " + lineNumber);	    
	};
	
	ctatcanvas = getSafeElementById("main-canvas");
		
	if (ctatcanvas==null)
	{
		alert ("Internal error: HTML5 canvas is null");
		return;
	}
	
	ctx = ctatcanvas.getContext('2d');
	
	if (ctx==null)
	{
		alert ("Internal error: HTML5 canvas context is null");
		return;
	}	
	
	//useDebugging=true;
	
	initialize();
	
	debug ("runTutor () ... all set");
	
	tutorRunning=true;
}
/**
 * 
 */
function runTutorSidebar (aVars)
{
	debug ("runTutorSidebar ()");
	
	if (tutorRunning==true)
	{
		debug ("The tutor is already running");
		return;
	}
	
	tutorRunning=true;	
	
	skillSet=new CTATSkillSet ();
	flashVars=new CTATFlashVars ();
	flashVars.assignRawFlashVars(aVars);
		
	if (platform=="ctat")
	{	
		window.onerror = function(errorMsg, url, lineNumber) 
		{	    
			var formatter=new CTATHTMLManager ();
			
			useDebugging=true; // This should always go through
			debug(formatter.htmlEncode (errorMsg) + " in " + url + ", line " + lineNumber);	    
			useDebugging=false;
		};
	
		ctatcanvas = getSafeElementById("main-canvas");
		
		if (ctatcanvas==null)
		{
			alert ("Internal error: HTML5 canvas is null");
			return;
		}
	
		ctx = ctatcanvas.getContext('2d');
	
		if (ctx==null)
		{
			alert ("Internal error: HTML5 canvas context is null");
			return;
		}
	}

	//testTutor ();

	initializeSidebar();
	
	debug ("runTutor () ... all set");	
}
/**
*
*/
function initTutor ()
{
	debug ("initTutor ()");
	 
	ctatscrim.waitScrimUp();
		
	var debugtraces=getSafeElementById("debugtraces");
	
	if (debugtraces!=null)
	{
		if (debugtraces.checked==true)
			useDebugging=true;
		else
			useDebugging=false;		
	}
	
	var tempFlashVars=tutorPrep (FlashVars);
	
	mobileAPI=new CTATMobileTutorHandler ("keyboardUI",tempFlashVars ['keyboard']);	

	debug ("initTutor ()");
	
	if (tempFlashVars ["session_id"]=="none")
		tempFlashVars ["session_id"]=("qa-test_"+guid());
		
	if (tempFlashVars ["connection"]=="javascript")
	{
		deployJava.runApplet({id: 'TSApplet', width: 150, height: 10}, {jnlp_href: '/ctat_applet/TSApplet.jnlp'}, '1.6');
	}		
		    	
	runTutor (tempFlashVars);
}
/**
*
*/
function initTutorSidebar (aVars)
{	
	debug ("initTutorSidebar ()");
	
	//ctatscrim.waitScrimUp();
		
	var debugtraces=getSafeElementById("debugtraces");
		
	var internalFlashVars=tutorPrep (aVars);
			
	if (internalFlashVars ["session_id"]=="none")
		internalFlashVars ["session_id"]=("qa-test_"+guid());
		    	
	runTutorSidebar (internalFlashVars);
}
/**
 * This is a function accessible by TutorShop
 */
function receiveFromTutor ()
{
	debug ("receiveFromTutor ()");
}

/**
 * This is a function accessible by TutorShop and is used to do a rapid
 * shutdown of a tutor whilst at the same time saving its state. 
 */
function saveAndQuit ()
{
	debug ("saveAndQuit ()");	
}

/**
*
*/
function prepTutorArea ()
{
	//The first thing we will do is apply centering styles to the tutor
	centerTutor(600, 200);

	//Will do a check to see if the Autorun box was checked. If it was, start the tutor.
	var args = parseQueryString ();
	
	if (args["AUTORUN"]=="on")
	{
		initTutor ();
	}
	
	else 
	{
		//This will drape a play button over the main canvas, like a scrim.
		var canvasToPlayButton=new CTATPlayButton();
	}	
}

/**
*
*/
function assignAnonymousGradingProcessor (aFunction)
{
	commShell.assignAnonymousGradingProcessor (aFunction);
}
/**
*
*/
function gradeAnonymousComponent (aSelection,anAction,anInput)
{
	debug ("gradeAnonymousComponent ()");

	var tsMessage=new CTATSAI(aSelection,anAction,anInput);
	commShell.processComponentAction(tsMessage);
}

/**
*
*/
function testTutor(aVars)
{
	debug ("testTutor ()");
	
	window.onerror = function(errorMsg, url, lineNumber) 
	{
		//debugPointer = new CTATBase("", "");
	
		var formatter=new CTATHTMLManager ();
		
		useDebugging=true; // This should always go through
		debug(formatter.htmlEncode (errorMsg) + " in " + url + ", line " + lineNumber);	    
		useDebugging=false;
	};	
	
	var internalFlashVars=tutorPrep (aVars);	
	
	skillSet=new CTATSkillSet ();
	flashVars=new CTATFlashVars ();
	flashVars.assignRawFlashVars(aVars);	

	var connector=new CTATCommLibrary ();
	//connector.send_post ("http://qa.pact.cs.cmu.edu/courses",'<?xml version=\"1.0\" encoding=\"UTF-8\"?><hello></hello>');
	connector.send ("http://augustus.pslc.cs.cmu.edu/crossdomain.xml");
}
/*******************************************************************************
**
** FileName: APIWrapper.js
**
*******************************************************************************/

/*******************************************************************************
**
** Concurrent Technologies Corporation (CTC) grants you ("Licensee") a non-
** exclusive, royalty free, license to use, modify and redistribute this
** software in source and binary code form, provided that i) this copyright
** notice and license appear on all copies of the software; and ii) Licensee does
** not utilize the software in a manner which is disparaging to CTC.
**
** This software is provided "AS IS," without a warranty of any kind.  ALL
** EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND WARRANTIES, INCLUDING ANY
** IMPLIED WARRANTY OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NON-
** INFRINGEMENT, ARE HEREBY EXCLUDED.  CTC AND ITS LICENSORS SHALL NOT BE LIABLE
** FOR ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT OF USING, MODIFYING OR
** DISTRIBUTING THE SOFTWARE OR ITS DERIVATIVES.  IN NO EVENT WILL CTC  OR ITS
** LICENSORS BE LIABLE FOR ANY LOST REVENUE, PROFIT OR DATA, OR FOR DIRECT,
** INDIRECT, SPECIAL, CONSEQUENTIAL, INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER
** CAUSED AND REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT OF THE USE OF
** OR INABILITY TO USE SOFTWARE, EVEN IF CTC  HAS BEEN ADVISED OF THE POSSIBILITY
** OF SUCH DAMAGES.
**
*******************************************************************************/

/*******************************************************************************
** This file is part of the ADL Sample API Implementation intended to provide
** an elementary example of the concepts presented in the ADL Sharable
** Content Object Reference Model (SCORM).
**
** The purpose in wrapping the calls to the API is to (1) provide a
** consistent means of finding the LMS API implementation within the window
** hierarchy and (2) to validate that the data being exchanged via the
** API conforms to the defined CMI data types.
**
** This is just one possible example for implementing the API guidelines for
** runtime communication between an LMS and executable content components.
** There are several other possible implementations.
**
** Usage: Executable course content can call the API Wrapper
**      functions as follows:
**
**    javascript:
**          var result = doLMSInitialize();
**          if (result != true) 
**          {
**             // handle error
**          }
**
**    authorware
**          result := ReadURL("javascript:doLMSInitialize()", 100)
**
*******************************************************************************/

var _Debug = true ;  // set this to false to turn debugging off
                     // and get rid of those annoying alert boxes.

/*******************************************************************************
**
** Function: doLMSInitialize()
** Inputs:  None
** Return:  CMIBoolean true if the initialization was successful, or
**          CMIBoolean false if the initialization failed.
**
** Description:
** Initialize communication with LMS by calling the LMSInitialize
** function which will be implemented by the LMS.
**
*******************************************************************************/
function doLMSInitialize()
{
	if (_Debug==true)
		alert ('doLMSInitialize ()');
}

/*******************************************************************************
**
** Function doLMSFinish()
** Inputs:  None
** Return:  CMIBoolean true if successful
**          CMIBoolean false if failed.
**
** Description:
** Close communication with LMS by calling the LMSFinish
** function which will be implemented by the LMS
**
*******************************************************************************/
function doLMSFinish()
{
	if (_Debug==true)
		alert ('doLMSFinish ()');
}

/*******************************************************************************
**
** Function doLMSGetValue(name)
** Inputs:  name - string representing the cmi data model defined category or
**             element (e.g. cmi.core.student_id)
** Return:  The value presently assigned by the LMS to the cmi data model
**       element defined by the element or category identified by the name
**       input value.
**
** Description:
** Wraps the call to the LMS LMSGetValue method
**
*******************************************************************************/
function doLMSGetValue(name)
{
	if (_Debug==true)
		alert ('doLMSGetValue ('+name+')');
}

/*******************************************************************************
**
** Function doLMSSetValue(name, value)
** Inputs:  name -string representing the data model defined category or element
**          value -the value that the named element or category will be assigned
** Return:  CMIBoolean true if successful
**          CMIBoolean false if failed.
**
** Description:
** Wraps the call to the LMS LMSSetValue function
**
*******************************************************************************/
function doLMSSetValue(name, value)
{
	if (_Debug==true)
		alert ('doLMSSetValue ('+name+','+value+')');	
}

/*******************************************************************************
**
** Function doLMSCommit()
** Inputs:  None
** Return:  None
**
** Description:
** Call the LMSCommit function 
**
*******************************************************************************/
function doLMSCommit()
{
	if (_Debug==true)
		alert ('doLMSCommit()');	
}

/*******************************************************************************
**
** Function doLMSGetLastError()
** Inputs:  None
** Return:  The error code that was set by the last LMS function call
**
** Description:
** Call the LMSGetLastError function 
**
*******************************************************************************/
function doLMSGetLastError()
{
	if (_Debug==true)
		alert ('doLMSGetLastError()');
}

/*******************************************************************************
**
** Function doLMSGetErrorString(errorCode)
** Inputs:  errorCode - Error Code
** Return:  The textual description that corresponds to the input error code
**
** Description:
** Call the LMSGetErrorString function 
**
********************************************************************************/
function doLMSGetErrorString(errorCode)
{
	if (_Debug==true)
		alert ('doLMSGetErrorString('+errorCode+')');
}

/*******************************************************************************
**
** Function doLMSGetDiagnostic(errorCode)
** Inputs:  errorCode - Error Code(integer format), or null
** Return:  The vendor specific textual description that corresponds to the 
**          input error code
**
** Description:
** Call the LMSGetDiagnostic function
**
*******************************************************************************/
function doLMSGetDiagnostic(errorCode)
{
	if (_Debug==true)
		alert ('doLMSGetDiagnostic('+errorCode+')');
}

/*******************************************************************************
**
** Function LMSIsInitialized()
** Inputs:  none
** Return:  true if the LMS API is currently initialized, otherwise false
**
** Description:
** Determines if the LMS API is currently initialized or not.
**
*******************************************************************************/
function LMSIsInitialized()
{
	if (_Debug==true)
		alert ('LMSIsInitialized()');
}

/*******************************************************************************
**
** Function ErrorHandler()
** Inputs:  None
** Return:  The current value of the LMS Error Code
**
** Description:
** Determines if an error was encountered by the previous API call
** and if so, displays a message to the user.  If the error code
** has associated text it is also displayed.
**
*******************************************************************************/
function ErrorHandler()
{
	if (_Debug==true)
		alert ('ErrorHandler()');
}

/******************************************************************************
**
** Function getAPIHandle()
** Inputs:  None
** Return:  value contained by APIHandle
**
** Description:
** Returns the handle to API object if it was previously set,
** otherwise it returns null
**
*******************************************************************************/
function getAPIHandle()
{
	if (_Debug==true)
		alert ('getAPIHandle()');
}


/*******************************************************************************
**
** Function findAPI(win)
** Inputs:  win - a Window Object
** Return:  If an API object is found, it's returned, otherwise null is returned
**
** Description:
** This function looks for an object named API in parent and opener windows
**
*******************************************************************************/
function findAPI(win)
{
	if (_Debug==true)
		alert ('findAPI()');
}



/*******************************************************************************
**
** Function getAPI()
** Inputs:  none
** Return:  If an API object is found, it's returned, otherwise null is returned
**
** Description:
** This function looks for an object named API, first in the current window's 
** frame hierarchy and then, if necessary, in the current window's opener window
** hierarchy (if there is an opener window).
**
*******************************************************************************/
function getAPI()
{
	if (_Debug==true)
		alert ('getAPI()');
}


/**------------------------------------------------------------------------------------
 $Author$ 
 $Date$ 
 $Header$ 
 $Name$ 
 $Locker$ 
 $Log$
 
 -
 License:
 -
 ChangeLog:
 -
 Notes:
 
 All the methods in this file correspond to functions made available by
 tutorshop. When placing a tutor on TS please remove this file otherwise
 the code will call the wrong functions.
*/

/**
 * 
 */
function javaScriptInfo (aString)
{
	var tutorCanvas=getSafeElementById("info");
	
	if (tutorCanvas!=null)
	{
		tutorCanvas.innerHTML=aString;
	}	
}
/**------------------------------------------------------------------------------------
 $Author$ 
 $Date$ 
 $Header$ 
 $Name$ 
 $Locker$ 
 $Log$
 
 -
 License:
 -
 ChangeLog:
 -
 Notes:
 
*/

/**
 * CTATActionEvaluation contains data relevant to Action Evalutation fields in 
 * log messages.<p>This class mainly serves the purpose of internal message 
 * management. All of the externally published logging methods that deal with 
 * action evaluations will condense their arguments down to one of these objects 
 * to be used with the internal logging methods.</p>
 * 
 * @see http://pslcdatashop.web.cmu.edu/dtd/guide/tutor_message.html#element.action_evaluation Action Evaluation specification
 */
function CTATActionEvaluationData (anEval)
{
	CTATBase.call (this,"CTATActionEvaluationData","actionevaluation");
	
	var classification="";
	var currentHintNumber=0;
	var totalHintsAvailable=0;
	var hintID= "";
	var evaluation=anEval;
				
	/**
	 * Sets the classification of the ActionEvaluation.
	 * @param	classification	A string that classifies the evaluation.
	 */
	this.setClassification=function setClassification(classification) 
	{
		this.classification = classification;
	};
		
	/**
	 * Returns whether or not that ActionEvaluation is of type "HINT"
	 * @return <code>true</code> if the ActionEvaluation describes a hint, <code>false</code> otherwise.
	 */
	this.isHint=function isHint() 
	{
		return (evaluation == "HINT");
	};
		
	/**
	 * Returns whether of not the ActionEvaluation has a classification.
	 * @return	<code>true</code> if the ActionEvaluation has a clasification, <code>false</code> otherwise.
	 */
	this.hasClassification=function hasClassification() 
	{
		return (classification != null);
	};
		
	/**
	 * Sets the current hint number value of the Action Evaluation.
	 * @param	hintNumber	The index of the current hint.
	 */
	this.setCurrentHintNumber=function setCurrentHintNumber(hintNumber) 
	{
		currentHintNumber = hintNumber;
	};
		
	/**
	 * Sets the total number of hints available.
	 * @param	numHints	The total number of hints.
	 */
	this.setTotalHintsAvailable=function setTotalHintsAvailable(numHints) 
	{
		totalHintsAvailable = numHints;
	};
		
	/**
	 * Sets the id of the current hint
	 * @param	theID	A Hint ID
	 */
	this.setHintID=function setHintID(theID) 
	{
		hintID = theID;
	};
		
	/**
	 * Returns the classification of the ActionEvaluation.
	 * @return	A classification of the action evaluation
	 */
	this.getClassification=function getClassification() 
	{
		return classification;
	};
		
	/**
	 * Sets the evaluation field of the ActionEvaluation.
	 * @see		http://pslcdatashop.web.cmu.edu/dtd/guide/tutor_message.html#table.action_evaluation Reccomended Values for Action Evaluation
	 * @param	theEvaluation	The evaluation field of the ActionEvaluation
	 */
	this.setEvaluation=function setEvaluation(theEvluation) 
	{
		evaluation = theEvluation;
	};
	
	/**
	 * Returns the evaluation field of the ActionEvaluation
	 * @return	The evaluation of the ActionEvaluation
	 */
	this.getEvaluation=function getEvaluation() 
	{
		return evaluation;
	};
		
	/**
	 * Returns the ActionEvalution in its DataShop specified XML format.
	 * @return	An XMLString representation of the ActionEvaluation.
	 */
	this.getAttributeString=function getAttributeString() 
	{
		var retString="";
			
		if (classification!= "")
		{
			retString += 'classification="' + classification + '" ';
		}
				
		if (!isHint())
		{
			return retString;
		}	
				
		retString += 'current_hint_number="' + currentHintNumber + '" ';
		retString += 'total_hints_available="' + totalHintsAvailable + '" ';
			
		if(hintID != "")
			retString += 'hint_id="' + hintID + '" ';
				
		return retString;
	};
}
	
CTATActionEvaluationData.prototype = Object.create(CTATBase.prototype);
CTATActionEvaluationData.prototype.constructor = CTATActionEvaluationData;
/**------------------------------------------------------------------------------------
 $Author$ 
 $Date$ 
 $Header$ 
 $Name$ 
 $Locker$ 
 $Log$
 
 -
 License:
 -
 ChangeLog:
 -
 Notes:
 
*/

/**
 *  
 */
function CTATCommLibrary ()
{
	CTATBase.call(this, "CTATCommLibrary", "commlibrary");

	var httpreqindex=0;
	var httprequests=new Array ();
	var httphandler=null;
	var pointer = this;
	
	var requestList=new Array();
	
	/**
	 * http://beradrian.wordpress.com/2007/07/19/passing-post-parameters-with-ajax/
	 */
	this.assignHandler=function assignHandler (aHandler)
	{
		httphandler=aHandler;
	};
	/**
	 * 
	 */
	this.encodeVariables=function encodeVariables(variables)
	{
		this.debug ("encodeVariables ()");
		
	    var parameterString="";
	 	    
	    for (var i=0;i<variables.length;i++)
	    {
	    	var variable=variables [i];
	    	
	    	if (i>0)
	    	{
	    		parameterString+="&";
	    	}
	    	
	    	parameterString+=variable.name;
	    	parameterString+="=";
	    	parameterString+=encodeURI (variable.value);
	    }
	    
	    return (parameterString);
	};
	/**
	 * 
	 */
	this.sendXML=function sendXML (aMessage)
	{	
		this.debug ('sendXML ('+aMessage+')');
		
		var vars=flashVars.getRawFlashVars ();
				
		var prefix="http://";
		
		if (vars ['connection']=='https')
		{
			prefix="https://";
		}
				
		var url=prefix + vars ["remoteSocketURL"] + ":" + vars ["remoteSocketPort"];
		
		this.debug ('sendXML ('+url+')');
		
		var formatted=aMessage;
		
		if (aMessage.indexOf ("<?xml")==-1)		
			formatted=("<?xml version=\"1.0\" encoding=\"UTF-8\"?>"+aMessage);

		if (vars ['connection']=='javascript')
		{
			// See TutorBridge.js
			sendToTutor (formatted);
		}
		else		
		{
			this.send_post (url,formatted);
		}
	};
	/**
	 * 
	 */
	this.sendXMLURL=function sendXMLURL (aMessage,aURL)
	{
		this.debug ('sendXMLURL ('+aURL+')');
						
		var formatted=aMessage;
		
		if (aMessage.indexOf ("<?xml")==-1)	
		{
			formatted=("<?xml version=\"1.0\" encoding=\"UTF-8\"?>"+aMessage);
		}
			
		var vars=flashVars.getRawFlashVars ();			

		this.debug ("Sending: " + formatted);
		
		if (vars ['connection']=='javascript')
		{
			// See TutorBridge.js
			sendToTutor (formatted);
		}
		else		
		{
			this.send_post (aURL,formatted);
		}
	};
	/**
	 * 
	 */
	this.sendURLVariables=function sendURLVariables (aURL,variables)
	{
		this.debug ('sendURLVariables ('+aURL+')');
		
		var vars=flashVars.getRawFlashVars ();
				
		if (aMessage.indexOf ("<?xml")==-1)		
			this.send_post_variables (aURL,"<?xml version=\"1.0\" encoding=\"UTF-8\"?>"+aMessage,variables);
		else	
			this.send_post_variables (aURL,variables);
	};
	/**
	* 
	*/		
	this.send=function send (url) 
	{
		this.debug ('send ('+url+')');
		
		if (globalCommDisabled==true)
		{
			this.debug ("Communications globally disabled, please check your settings");
			return;
		}		
	
		var newConnection=new CTATConnection ();
		newConnection.id=httpreqindex;
		httpreqindex++;
		 
		if (newConnection.httpObject==null) 
		{
			alert ('Cannot create XMLHTTP instance');
			return false;
		}
		
		httprequests.push(newConnection);
			 	

		newConnection.url=url;
		newConnection.httpObject.onreadystatechange=this.processReply;	 
		
		try
		{
			newConnection.httpObject.open ('GET', url, true);
		}
		catch(err)
		{
			this.debug ("Error in newConnection.httpObject.open: " + err.message);
			return;			
		}	
		
		try
		{
			newConnection.init ();
		}
		catch(err)
		{
			this.debug ("Error in newConnection.init: " + err.message);
			return;			
		}					

		try
		{
			newConnection.httpObject.send (null);
		}
		catch(err)
		{
			this.debug ("Error in newConnection.httpObject.send: " + err.message);
			return;			
		}
	};	
	/**
	*
	*/
	this.send_post=function send_post (url,data) 
	{
		this.debug ('send_post ('+url+')');
		
		if (globalCommDisabled==true)
		{
			this.debug ("Communications globally disabled, please check your settings");
			return;
		}
		
		var newConnection=new CTATConnection ();
		newConnection.id=httpreqindex;
		httpreqindex++;		
		 
		if (newConnection.httpObject==null) 
		{
			alert ('Cannot create XMLHTTP instance');
			return false;
		}
		
		httprequests.push(newConnection);
					 			
		this.debug (data);
		
		newConnection.url=url;
		newConnection.data=data;
		newConnection.httpObject.onreadystatechange=this.processReply;
			
		try
		{			
			newConnection.httpObject.open ('POST', url, true);				
		}
		catch(err)
		{
			this.debug ("Error in newConnection.httpObject.open: " + err.message);
			return;			
		}			
			
		try
		{	
			newConnection.init ();			
		}
		catch(err)
		{
			this.debug ("Error in newConnection.init: " + err.message);		
			return;						
		}			
			
		try
		{	
			newConnection.httpObject.send (data);			
		}
		catch(err)
		{
			this.debug ("Error in newConnection.httpObject.send: " + err.message);		
			return;
		}
	};
	/**
	* 		var data=this.encodeVariables(variables);
	*/
	this.send_post_variables=function send_post_variables (url,variables) 
	{
		this.debug ('send_post_variables ('+url+')');

		var data=this.encodeVariables(variables);
		
		this.debug ("Sending: " + data);
		
		this.send_post (url,data);
	};	
	/**
	*
	*/
	this.processReply=function processReply () 
	{ 		
		pointer.debug ('processReply ('+httprequests.length+')');
				
		var i=0;
		var found=false;
		var stringDelivery=new Array ();
		
		var request=0;
		
		//for (req in httprequests)
		for (request=0;request<httprequests.length;request++)
		{    
			var testConnection=httprequests [request];
			var testObject=testConnection.httpObject;
		
			if ((testObject.readyState==4) && (testConnection.consumed==false)) 
			{
				pointer.debug ("Investigating request response: " + i + " -> " + testObject.status + ", for: " + testConnection.url);
				
				found=false;

				if (testObject.status==0)
				{				
					found=true;				
					
					pointer.debug (testObject.responseText);
					
					ctatscrim.errorScrimUp("Error: Connection closed by foreign host.");
					testConnection.consumed=true; // make sure we don't call it again!
				}
			
				// 408 timeout response
				if(testObject.status==408)
				{
					found=true;
				
					ctatscrim.scrimDown();

					// Re-send all requests after and including the one that timed out
					/*
					while(i < requestList.length)
					{
						requestList [i][0].send(requestList [i][1]);
						i++;
					}
					*/
					
					testConnection.consumed=true; // make sure we don't call it again!					
				}
				
				if (testObject.status==502)
				{				
					found=true;				
					
					ctatscrim.errorScrimUp("Error contacting the server, please refresh the page and try again (HTTP status 502: gateway response).");					
					testConnection.consumed=true; // make sure we don't call it again!
				}
				
				if (testObject.status==200) 
				{	
					found=true;
				
					pointer.debug ("Processing 200 response ...");
  					
					if (httphandler!=null)
					{
						//pointer.debug ("Received message: " + testObject.responseText);
					
						pointer.debug ("Received message");
												
						//pointer.debug ("Checking XML API: " + testObject.responseXML);
						
						stringDelivery.push (testObject.responseText);
					}
					else
						pointer.debug ("Error: httphandler is null, can't process response!");

					//Not yet implemented - if this is not a boolean, it is a function.
					/*
					if (httprequests [req][2]!=false)
					{
						httprequests [req][2]();
					}*/	   					
					
					testConnection.consumed=true; // make sure we don't call it again!
				}  
								
				if (found==false)
				{
					pointer.debug ("Error: status not handled for: " + testObject.status);
				}
			}
			else
			{
				if (testObject.readyState===0)
				{
					pointer.debug ("Ready state: request not initialized");
				}
				
				if (testObject.readyState===1)
				{
					pointer.debug ("Ready state: server connection established");
				}

				if (testObject.readyState===2)
				{
					pointer.debug ("Ready state: request received");
				}
				
				if (testObject.readyState===3)
				{
					pointer.debug ("Ready state: processing request");
				}				
			}	
									
			i++;
		} 
		
		pointer.cleanup();
		
		for (var t=0;t<stringDelivery.length;t++)
		{
			pointer.debug ("Processing incoming message: " +  t);
		
			var aMessage=stringDelivery [t];
							
			httphandler.processMessage (aMessage);
			
			/*			
			if (aMessage.indexOf ("<?xml")==-1)		
			{
				pointer.debug ("Processing incoming message (cleaned): " +  t);
			
				httphandler.processMessage ("<?xml version=\"1.0\" encoding=\"UTF-8\"?>"+aMessage);
			}	
			else	
			{
				pointer.debug ("Processing incoming message: " +  t);
				
				httphandler.processMessage (aMessage);
			}*/			
		}	
	}	
	/**
	*
	*/
	this.cleanup=function cleanup () 
	{ 
		pointer.debug ("cleanup ()");
		
		var i=0;
		var count=0;
		var found=false;
		var clean=false;
		
		while (clean==false)
		{			
			//pointer.debug ("Checking ...");
		
			found=this.checkEntries ();
					
			//pointer.debug ("Found: " + found);
			
			if (found==false)
			{
				clean=true;
			}
			else
				count++;
		}	
		
		pointer.debug ("Removed " + count + " entries");
	};
	/**
	*
	*/
	this.checkEntries=function checkEntries ()
	{
		pointer.debug ("checkEntries ()");
	
		var i=0;	
		var requests=0;
	
		//for (req in httprequests)
		for (requests=0; requests<httprequests.length;requests++)
		{    
			var testConnection=httprequests [requests];
		
			if (testConnection.consumed==true)
			{
				pointer.debug ("Removing : " + testConnection.id);
			
				httprequests.splice(i, 1);
				return (true);
			}
			
			i++;
		}	
		
		return (false);
	};
}	

CTATCommLibrary.prototype = Object.create(CTATBase.prototype);
CTATCommLibrary.prototype.constructor = CTATCommLibrary;
/**------------------------------------------------------------------------------------
 $Author$ 
 $Date$ 
 $Header$ 
 $Name$ 
 $Locker$ 
 $Log$
 
 -
 License:
 -
 ChangeLog:
 -
 Notes:
 
*/


/**
 *  
 */
function CTATCommShell ()
{
	CTATBase.call(this, "CTATCommShell", "theShell");
	
	var tutor=null;
	var tools=new CTATShellTools ();
	var pointer=this;
	var xmlParser=new CTATXML ();
	var gradingProcessor=null;
			
	/**
	 * 
	 */
	this.init=function init (aTutor)
	{
		this.debug ("init ()");
		
		var vars=flashVars.getRawFlashVars ();
		
		var prefix="http://";
		
		if (vars ['connection']=='https')
		{
			prefix="https://";
		}
				
		//drawText ("Running HTML5 CTAT version: " + version,2,10);
		
		tutor=aTutor;
		
		var generator=new CTATGuid ();
		
		contextGUID=generator.guid ();
		
		//this.debug ("A");
				
		processSkills ();
		
		//this.debug ("B");
		
		commMessageHandler=new CTATMessageHandler ();
		commMessageHandler.assignHandler (this);
		commMessageBuilder=new CTATTutoringServiceMessageBuilder ();			
		commLogMessageBuilder=new CTATLogMessageBuilder ();
		commLibrary=new CTATCommLibrary ();
		commLibrary.assignHandler (this);
		commLMSService=new CTATCurriculumService (commLibrary);
				
		//this.debug ("C2");
		
		//commLoggingLibrary=new CTATLoggingLibrary ();
		
		//this.debug ("C3");
		
		var vars=flashVars.getRawFlashVars ();
				
		flashVars.setTimeZone (null); // Force detection of timezone
		
		//this.debug ("D");
		
		var htmlManager=new CTATHTMLManager ();
				
		if (vars ['info']!="")
		{
			javaScriptInfo(htmlManager.entitiesConvert (vars ['info']));
		}
		else
			this.debug ("There is no info flash var");
				
		this.debug ("Connecting to: " + prefix + vars ["remoteSocketURL"] + ":" + vars ["remoteSocketPort"]);
				
		commLibrary.sendXMLURL (commMessageBuilder.createSetPreferencesMessage (version),prefix + vars ["remoteSocketURL"] + ":" + vars ["remoteSocketPort"]);

		var saiTest=new CTATSAI ();		
	};
	/**
	*
	*/
	this.assignAnonymousGradingProcessor=function assignAnonymousGradingProcessor (aFunction)
	{
		gradingProcessor=aFunction;
	};
	/**
	 * 
	 */
	this.reset=function reset ()
	{
		pointer.debug ("reset ()");
		
		interfaceElement=null;
	}
	/**
	 *
	 */
	this.getMessageHandler=function getMessageHandler ()
	{
		return (this.commMessageHandler);
	};
	/**
	 *
	 */
	function processSkills ()
	{
		pointer.debug ("processSkills ()");

		skillSet=new CTATSkillSet ();

		var vars=flashVars.getRawFlashVars ();

		skillSet.fromXMLString(vars ['skills']);
	}
	/**
	 * 
	 * @param anX
	 * @param anY
	 */
	function drawText (aString,anX,anY)
	{			
		pointer.debug ("drawText ()");
		
    	ctx.fillText(aString,anX,anY);
	}
	/**
	 * 
	 */
	this.focusNextComponent=function focusNextComponent (aComponent)
	{
		this.debug ("focusNextComponent ()");
			
		if (aComponent==null)
		{
			this.debug ("Internal error, unable to resolve currentComponentPointer");
		}
		else
		{								
			this.debug ("From: " + aComponent.getName () + ", to: " + "TBD");
			
			aComponent.setHintHighlight (true);
		}	
	};
	/**
	 * 
	 */
	this.gradeComponent=function gradeComponent (aComponent)
	{
		this.debug ("gradeComponent ("+aComponent.getName ()+","+aComponent.getClassName ()+")");
			
		if (nameTranslator!=null)
		{
			nameTranslator.translateFromCTAT (aComponent.getName ());
		}
		else
			this.debug ("Info: no name translator provided, using as-is");
			
		if (aComponent==null)
		{
			this.debug ("Internal error, provided component is null");
			return;
		}
		
		if (aComponent.getTutorComponent ()=="Do not tutor")
		{
			return;
		}
				
		if ((aComponent.getName ()=="hint") || (aComponent.getClassName ()=="CTATHintButton"))
		{
			this.requestHint();
			return;
		}
		
		if ((aComponent.getName ()=="done") || (aComponent.getClassName ()=="CTATDoneButton"))
		{
			this.processDone ();
			return;
		}		
		
		if (aComponent.getName ()=="previous")
		{
	    	if(aComponent.getEnabled()==true)
	    	{
				for (var i=0;i<feedbackComponents.length;i++)
				{
					var feedbackComponent=feedbackComponents [i];
					
					// Log the message ...
					
					// Make it happen ...
					
					feedbackComponent.goPrevious ();
				}
			}			
			
			return;
		}

		if (aComponent.getName ()=="next")
		{
	    	if(aComponent.getEnabled()==true)
	    	{
				for (var i=0;i<feedbackComponents.length;i++)
				{
					var feedbackComponent=feedbackComponents [i];
					
					// Log the message ...
					
					// Make it happen ...					
					
					feedbackComponent.goNext ();
				}
			}			
			
			return;
		}		
		
		this.debug ("Checking for back grading: " + aComponent.getName ());
		
		/*
		if(aComponent.getClassName ()=="CTATTextArea")
		{
			this.debug ("Backgrading ...");
			
			this.debug ("Grading value: " + aComponent.getValue ());

			if (isBlank (aComponent.getValue ())==true)
			{
				this.debug ("Empty component, nothing to grade");
				return;
			}

			var textSAI=new CTATSAI(aComponent.getName (), "UpdateTextArea", aComponent.getValue ());
			
			pointer.processComponentAction(textSAI);
			
			//aComponent.showCorrect();
			
			return;
		}
		*/
		
		if ((aComponent.getClassName ()=="CTATTextArea") || (aComponent.getClassName ()=="CTATTextInput") || (aComponent.getClassName ()=="CTATTextField"))
		{
			this.debug ("Backgrading ...");
			
			this.debug ("Grading value: " + aComponent.getValue ());

			if (isBlank (aComponent.getValue ())==true)
			{
				this.debug ("Empty component, nothing to grade");
				return;
			}

			var textSAI=null;
			
			if (aComponent.getClassName ()=="CTATTextField")
				textSAI=new CTATSAI(aComponent.getName (), "UpdateTextField", aComponent.getValue ());
				
			if (aComponent.getClassName ()=="CTATTextInput")
				textSAI=new CTATSAI(aComponent.getName (), "UpdateTextArea", aComponent.getValue ());

			if (aComponent.getClassName ()=="CTATTextArea")
				textSAI=new CTATSAI(aComponent.getName (), "UpdateTextArea", aComponent.getValue ());
			
			pointer.processComponentAction(textSAI);
						
			return;
		}
		
		if (aComponent.getClassName ()=="CTATComboBox")
		{
			this.debug ("Grading combobox ...");
			
			var combobox=aComponent.getHTMLComponent ();
			
			var strUser = combobox.options[combobox.selectedIndex].value;
			
			if (isBlank (strUser)==true)
			{
				this.debug ("Empty component, nothing to grade");
				return;
			}
			
			var tsMessage=new CTATSAI(aComponent.getName (), "UpdateComboBox", strUser);
			
			pointer.processComponentAction(tsMessage);
			
			return;
		}	

		this.debug ("Grading regular component ...");
		
		//this.debugObjectShallow (aComponent.getBaseElement ());
		
		if(aComponent.getClassName ()=="CTATButton")
		{	
			var tsMessage=new CTATSAI(aComponent.getName (), "ButtonPressed", -1);
			
			pointer.processComponentAction(tsMessage);
			
			return;
		}
		
		if(aComponent.getClassName ()=="CTATRadioButton")
		{
			var tsMessage=new CTATSAI(aComponent.getComponentGroup (), 
									  "UpdateRadioButton", 
									  aComponent.getRadioInput ());
									  
			pointer.processComponentAction(tsMessage);
			
			return;
		}
		
		if(aComponent.getClassName ()=="CTATCheckBox")
		{
			var tsMessage=new CTATSAI(aComponent.getComponentGroup (),
									  "UpdateCheckBox",
									  aComponent.getCheckBoxInput ());
					
			pointer.processComponentAction(tsMessage);	
			
			return;
		}
		
		var tsMessage=new CTATSAI(aComponent.getName (), "ButtonPressed", -1);
		pointer.processComponentAction(tsMessage);
	};
	/**
	 * 
	 */
	this.processMessage=function processMessage(aMessage)
	{
		this.debug ("processMessage ()");
				
		commMessageHandler.processMessage (aMessage);
		
		this.debug ("processMessage () done");
	};
	/**
	 * 
	 */
	this.processStartState=function processStartState ()
	{
		this.debug ("processStartState ()");
		
		if (tutor!=null)
		{
			tutor.createInterface ();
			
			//useDebugging=true;
			
			if (commLoggingLibrary!=null)
			{
				commLoggingLibrary.startProblem ();
			}
			else
			{
				this.debug ("Info: no logging library available!");
			}
			
			//useDebugging=false;
		}
	};
	/**
	 * Ported from AS3
	 */						
	this.sendStartProblemMessage=function sendStartProblemMessage() 
	{
		pointer.debug ("sendStartProblemMessage()");
		
		/*
		var problemName:String = context.ProblemName;
		var message:String = CTATTutoringServiceMessageBuilder.createStartProblemMessage(problemName);
		connectionManager.sendMainConnectionMessage(message);
		*/
		
		// Not relevant for HTML5		
	};
	/**
	 * Ported from AS3
	 */
	this.sendProblemSummaryRequest=function sendProblemSummaryRequest (callBack)
	{
		pointer.debug ("sendProblemSummaryRequest()");
				
		var builder = new CTATTutoringServiceMessageBuilder ();
		
		var tsMessage = builder.createProblemSummaryRequestMessage();
		
		commLibrary.sendXML (tsMessage);
	};
	/**
	* Ported from AS3
	*/
	this.sendInterfaceDescriptionMessages=function sendInterfaceDescriptionMessages() 
	{
		pointer.debug("sendInterfaceDescriptionMessages ()");
		
		// Not relevant for HTML5
	};
	/**
	 * 
	 */
	this.processSerialization=function processSerialization()
	{
		pointer.debug ("processSerialization()");

		// Process component specific pre-defined styles ...
		
		pointer.setText (this.label);
		
		// Process component custom styles ...		

		this.styles=aDescription.styles;

		this.styles=pointer.getGrDescription().styles;
		
		pointer.debug ("Processing " + this.styles.length + " styles ...");
		
		for (var i=0;i<this.styles.length;i++)
		{
			var aStyle=this.styles [i]; // CTATStyle
			
			if(aStyle.styleName=="CorrectColor")
			{
				correctColor=aStyle.styleValue;
			}
			
			if(aStyle.styleName=="IncorrectColor")
			{
				incorrectColor=aStyle.styleValue;
			}
			
			if(aStyle.styleName=="HintColor")
			{
				hintColor=aStyle.styleValue;
			}
			
			if(aStyle.styleName=="EnableDebugging")
			{
				pointer.setUseDebugging(aStyle.styleValue);
			};
		}	
	};
	/**
	 * 
	 */
	this.processComponentAction=function processComponentAction (sai,tutorComponent,behaviorRecord,component)
	{
		pointer.debug("processComponentAction(" +sai.getSelection() + "," + sai.getAction() + "," + sai.getInput() + ")");
				
		var generator=new CTATGuid ();
		
		var transactionID = generator.guid ();
		
		// First we log
		
		if (commLoggingLibrary!=null)
		{
			if (commMessageHandler.getInStartState ()==false)
			{
				//if ((useFlashSideLogging) && (!inAuthorTime))
				//{
					pointer.debug("logging the action ...");
				
					if (sai.getSelection()=="scrim")
					{
						debug ("Not logging any scrim actions (for now)");
					}
					else
					{
						if ((sai.getSelection() == "hint") || (sai.getSelection()=="null.nextButton") || (sai.getSelection()=="null.previousButton"))
						{
							commLoggingLibrary.logSemanticEvent(transactionID, sai, "HINT_REQUEST", "");
						}
						else
							commLoggingLibrary.logSemanticEvent(transactionID, sai, "ATTEMPT", "");
					}			
				//}
			}		
		}
		else
		{
			this.debug ("Info: no logging library available!");
		}		
		
		// Then we send to the TS
		
		var builder = new CTATTutoringServiceMessageBuilder ();
		
		var tsMessage = builder.createInterfaceActionMessage(transactionID,sai);
		
		commLibrary.sendXML (tsMessage);
		// Et Voila!
	};
	/**
	 * This is the method accessed by CTATComponents to inform all of CTAT's resources of actions. The
	 * CommShell will use parameters set at run time to determine how to process logging and will use parameters passed by the component
	 * in question to determine how to process tutoring. The default tutoring behavior is the be recorded and send InterfaceAction 
	 * messages, which will be reflected within a brd in CTAT. If tutorComponent is set to false then the action will be recorded as 
	 * Untutored, in which case CTAT will be informed of the action but will not consider it as correct or incorrect. This is useful for
	 * providing more contextual hints. There is also an option to have the action not be recorded by CTAT at all. In this case a log
	 * message will be sent to the logging service but CTAT will not be aware of the action.
	 * 
	 * @param	sai				A CTATSAI containing the selection, action, and input of the action taken by a component
	 * @param	tutorComponent	A boolean for whether you want the action to be tutored (InterfaceAction), or untutored (UntutoredAction)
	 * @param	behaviorRecord	A boolean for whether you want the action recorded by the Java side behavior recorder. Useful for actions you only want logged, in which case you would set this to false.
	 * @eventType CTATMessageEvent.sendingMessage
	 * @eventType CTATMessageEvent.messageSent
	 */
	/*
	this.processComponentAction=function processComponentAction (sai, 
													 			 tutorComponent, 
													 			 behaviorRecord, 
													 			 component) 
	{
		debug("processComponentAction(" +sai.getSelection() + "," + sai.getAction() + "," + sai.getInput() + ")","commShell");		
		debug("ProcessingConfirmDone : " + processingConfirmDone + " sai.getSelection().toLowerCase() = " +sai.getSelection().toLowerCase());
		debug("confirmdone = " + confirmDone);
		
		if (!processingConfirmDone && sai.getSelection().toLowerCase() == "done" && confirmDone)
		{				
			showConfirmDoneDialog(sai, tutorComponent, behaviorRecord, component);
			return;
		}
		
		if(processingConfirmDone)
			processingConfirmDone = false;
					
		lastStudentAction = getCurrentMs();
		var transactionID = CTATGuid.create(16);
		
		if ((useFlashSideLogging) && (!inAuthorTime))
		{
			debug("logging the action" + logger,"commShell");
			
			if (sai.getSelection()=="scrim")
			{
				debug ("Not logging any scrim actions (for now)");
			}
			else
			{
				//if ((sai.getSelection() == "hint") || (sai.getSelection()=="null.nextButton") || (sai.getSelection()=="null.previousButton"))
				//{
				//	logger.logSemanticEvent(transactionID, sai, "HINT_REQUEST", "");
				//}
				//else
				//	logger.logSemanticEvent(transactionID, sai, "ATTEMPT", "");	
			}
		}

		if (behaviorRecord) 
		{
			debug("recording the action","commShell");
			debug(sai.toXMLString(true));
			
			var tsMessage="";
			var ctatMess=null;
			
			if (tutorComponent) 
			{
				tsMessage = CTATTutoringServiceMessageBuilder.createInterfaceActionMessage(transactionID, sai);
				ctatMess = new CTATMessage(tsMessage);
				
				if (CTATLinkData.messageHistory != null) 
					CTATLinkData.messageHistory.addToolMessage(ctatMess);
			}
			else 
			{
				tsMessage = CTATTutoringServiceMessageBuilder.createUntutoredActionMessage(transactionID, sai);
				ctatMess = new CTATMessage(tsMessage);
				
				if (CTATLinkData.messageHistory != null)
					CTATLinkData.messageHistory.addUnpairedMessage(ctatMess);
			}
			
			dispatchEvent(new CTATMessageEvent(CTATMessageEvent.SENDING_MESSAGE, ctatMess));
			
			try 
			{
				debug("connectionManager ....");
				
				if(connectionManager.isConnected("MAIN"))
					connectionManager.sendMainConnectionMessage(tsMessage);
			}
			catch (error:Error) 
			{
				if (error.errorID == 2002)
				{
					displayWarning("The socket to the behavior recorder was closed, make sure the authoring tools are open and try again.");
				}
				else
					handleFlashError(error);
				return;
			}
			
			//dispatchEvent(new CTATMessageEvent(CTATMessageEvent.MESSAGE_SENT, ctatMess));
		}
	};
	*/
	/**
	 * Requests a hint from the tutoring service.
	 * <p>Hint requests and normal component actions are very similar, however, a hint request requires knowledge of
	 * of the previous focus to help with tutoring service decide which hints to send in response.</p>
	 */
	this.requestHint=function requestHint() 
	{
		pointer.debug("requestHint()");
		
		// Note: convert SAI to Complex SAI
		var hintSAI=new CTATSAI("hint", "ButtonPressed", "-1");
		
		/*
		if (previousFocus!=null) 
		{
			if (previousFocus instanceof CTATCompBase)
			{
				hintSAI.addSelectionActionInput(previousFocus.getSAI().getSelection(),"PreviousFocus");
			}	
			else
			{
				pointer.debug ("Current focus is not a CTAT component, can't ask for a hint yet");
				
				//hintSAI.addSelectionActionInput((previousFocus as DisplayObject).name, "PreviousFocus");
			}
		}
		*/
						
		this.processComponentAction(hintSAI);		
	};
	/**
	 * 
	 */
	this.processDone=function processDone() 
	{
		pointer.debug("processDone()");
		
		//this.globalReset ();
				
		if (confirmDone==true)
		{
			showYesNoDialog ("Confirm Done","Are you sure you are done?",this.processDoneContinue);	
		}
		else
		{
			var doneSAI=new CTATSAI("done", "ButtonPressed", "-1");
							
			pointer.processComponentAction(doneSAI);
		}
	};
	/**
	 * 
	 */
	this.processDoneContinue=function processDoneContinue(aResult) 
	{
		pointer.debug("processDoneContinue()");
		
		if (aResult==true)
		{
			var doneSAI=new CTATSAI("done", "ButtonPressed", "-1");

			pointer.processComponentAction(doneSAI);						
		}	
	}	
	/**
	 * 
	 */
	this.processCorrectAction=function processCorrectAction (aMessage)
	{
		pointer.debug("processCorrectAction()");
		
		aMessage.setGradeResult ("correct");
		
		if (gradingProcessor!=null)
		{
			debug ("Calling custom grading processor ...");
			aMessage ();
			return;
		}
		
		var sel=aMessage.getSelection ();
		
		var comp=tools.findComponent (sel, aMessage.getInput ());
		
		if (comp!=null)
		{
			comp.showCorrect ();
			
			if (sel=="done")
			{
				commLibrary.sendXML (commMessageBuilder.createProblemSummaryRequestMessage());
			}
		}
		else
			pointer.debug("Error: component is null for selection " + sel);			
	};
	
	/**
	 * 
	 */
	this.processInCorrectAction=function processInCorrectAction (aMessage)
	{
		pointer.debug("processInCorrectAction()");

		aMessage.setGradeResult ("incorrect");
		
		if (gradingProcessor!=null)
		{
			debug ("Calling custom grading processor ...");
			aMessage ();
			return;
		}		
		
		var sel=aMessage.getSelection ();

		var comp=tools.findComponent (sel, aMessage.getInput ());

		if (comp!=null)
		{
			comp.showInCorrect ();
		}
		else
			pointer.debug("Error: component is null for selection " + sel);		
	};

	/**
	 *
	 */
	this.processHighlightMsg=function processHighlightMsg (aMessage)
	{
		pointer.debug("processHighlightMsg()");
		
		var sel=aMessage.getSelection ();
		
		var comp=tools.findComponent (sel);
		
		if (comp!=null)
		{
			comp.setHintHighlight (true);
		}
		else
			pointer.debug("Error: component is null for selection " + sel);
	};
	
	/**
	 *
	 */
	this.processUnHighlightMsg=function processUnHighlightMsg (aMessage)
	{
		pointer.debug("processUnHighlightMsg()");
		
		var sel=aMessage.getSelection ();
		
		var comp=tools.findComponent (sel);
		
		if (comp!=null)
		{
			comp.setHintHighlight (false);
		}
		else
			pointer.debug("Error: component is null for selection " + sel);		
	};
	
	/**
	 * 
	 */
	this.processAssociatedRules=function processAssociatedRules (aMessage,indicator,advice)
	{
		pointer.debug("processAssociatedRules()");
		
		// Log the message ...
		if (commMessageHandler.getInStartState ()==true)
		{
			var logSAI=message.getSAI();
			var semanticEvent="";
			var evalObj=new CTATActionEvaluationData("");
			//var advice=message.getProperty ("TutorAdvice");
			
			pointer.debug ("Found tutor advice: " + advice);
			
			if (message.getIndicator() == "Hint" || message.getIndicator() == "HintWindow") 
			{
				debug ("Preparing log message to indicate a hint response","commShell");
				
				/*
				evalObj.setCurrentHintNumber (CTATLinkData.hints.getCurrentHintIndexForLogging());
				evalObj.setTotalHintsAvailable (CTATLinkData.hints.getHintCount());
				*/
				
				evalObj.setCurrentHintNumber (hintIndex);
				evalObj.setHintsAvailable (hints.length);
				
				evalObj.setEvaluation ("HINT");
				semanticEvent = "HINT_MSG";
				//advice=CTATLinkData.hints.getCurrentHint();
				advice=hints [hintIndex];
			}
			else 
			{
				if (message.getIndicator() == "Correct")
					evalObj.setEvaluation("CORRECT");
				else
					evalObj.setEvaluation("INCORRECT");
					
				semanticEvent = "RESULT";
			}
			
			debug ("Adding custom field names ...");
			
			commLogMessageBuilder.resetCustomFields();
			commLogMessageBuilder.addCustomField("step_id",message.getProperty("StepID"));
						
			debug ("Sending log message ...");
										
			if (commLoggingLibrary!=null)
			{
				commLoggingLibrary.logTutorResponse (transactionID,
													 logSAI,
													 semanticEvent,
													 "",
													 evalObj,
													 advice,
													 skillsToLog,
													 commLogMessageBuilder.getCustomFieldNames(),
													 commLogMessageBuilder.getCustomFieldValues ());
			}
			else
			{
				this.debug ("Info: no logging library available!");
			}
		}		
		
		// Continue with processing ...
		/*
		if (indicator=="InCorrect")
		{
			//this.processInCorrectAction (aMessage);
		}
	
		if (indicator=="Correct")
		{
			//this.processCorrectAction (aMessage);
		}
		*/
		
		for (var i=0;i<feedbackComponents.length;i++)
		{
			var feedbackComponent=feedbackComponents [i];
			
			pointer.debug ("Showing tutor advice ...");

			feedbackComponent.showFeedback (advice);
		}
		
		this.updateSkillWindow ();	
	};
	
	/**
	 * 
	 */
	this.processBuggyMessage=function processBuggyMessage (aMessage)
	{
		pointer.debug("processBuggyMessage()");
	};
	
	/**
	 * 
	 */
	this.processSuccessMessage=function processSuccessMessage (aMessage)
	{
		pointer.debug("processSuccessMessage()");
	};
	
	/**
	 * 
	 */
	this.processInterfaceAction=function processInterfaceAction (aMessage)
	{			
		pointer.debug("processInterfaceAction("+aMessage.getSelection ()+","+aMessage.getAction ()+","+aMessage.getInput ()+")","commShell");

		// Prep all the various variables and pointers ...
		
		var targetComponent=tools.findComponent (aMessage.getSelection ());
		
		if (targetComponent==null)
		{
			pointer.debug ("Internal error: unable to find pointer to component object");
			return;
		}
		
		// Log the message ...
		
		if (commMessageHandler.getInStartState ()==false)
		{
			pointer.debug("This is not a start state TPA so it should be logged","commShell");
			
			if (commLoggingLibrary!=null)
			{
				commLoggingLibrary.logSemanticEvent (message.getTransactionID(), message.getSAI(), "ATTEMPT", message.getProperty("subtype"));
			}
			else
			{
				this.debug ("Info: no logging library available!");
			}
		}
		else
			pointer.debug ("Info for incoming TPA, commMessageHandler.getInStartState (): "+commMessageHandler.getInStartState ());		
		
		// Call the action on the component ...
		
		targetComponent [aMessage.getAction ()] (aMessage.getInput ());				
	};
	
	/**
	 * 
	 */
	this.processInterfaceIdentification=function processInterfaceIdentification (aMessage)
	{
		pointer.debug("processInterfaceIdentification()");
		
		// Not relevant for HTML5?
	};
	
	/**
	 * 
	 */
	this.processAuthorModeChange=function processAuthorModeChange (aMessage)
	{
		pointer.debug("processAuthorModeChange()");
		
		// Not relevant for HTML5 (yet)?		
	};

	/**
	 * 
	 */
	this.processShowHintsMessage=function processShowHintsMessage (aMessage)
	{
		pointer.debug("processShowHintsMessage()");
		
		// Instead handled by associated rules
	};
	
	/**
	 * 
	 */
	this.processConfirmDone=function processConfirmDone (aMessage)
	{
		pointer.debug("processConfirmDone()");
		
	};
	
	/**
	 * 
	 */
	this.processVersionInfo=function processVersionInfo (messageProperties)
	{
		pointer.debug("processVersionInfo()");
		
		// Not relevant?
	};
	
	/**
	 * 
	 */
	this.processTutoringServiceAlert=function processTutoringServiceAlert (messageProperties)
	{
		pointer.debug("processTutoringServiceAlert()");
	
		var aTitle="";
		var aMessage="";
		
		for (var t=0;t<messageProperties.length;t++)
		{
			var propNode=messageProperties [t];
													
			if (xmlParser.getElementName (propNode)=="ErrorType")
			{
				aTitle=xmlParser.getNodeTextValue (propNode)
			}
			
			if (xmlParser.getElementName (propNode)=="Details")
			{
				aMessage=xmlParser.getNodeTextValue (propNode)
			}			
		}	
		
		ctatscrim.scrimUp (aMessage);
	};
	
	/**
	 * 
	 */
	this.processTutoringServiceError=function processTutoringServiceError (messageProperties)
	{
		pointer.debug("processTutoringServiceError()");
		
		var aTitle="";
		var aMessage="";

		for (var t=0;t<messageProperties.length;t++)
		{
			var propNode=messageProperties [t];
													
			if (xmlParser.getElementName (propNode)=="ErrorType")
			{
				aTitle=xmlParser.getNodeTextValue (propNode)
			}
			
			if (xmlParser.getElementName (propNode)=="Details")
			{
				aMessage=xmlParser.getNodeTextValue (propNode)
			}
		}
		
		ctatscrim.scrimDown();
		ctatscrim.errorScrimUp(aTitle+" - "+aMessage);
	};
	
	/**
	 * 
	 */
	this.processProblemSummaryResponse=function processProblemSummaryResponse (aMessage)
	{
		pointer.debug("processProblemSummaryResponse()");
	
		//pointer.debug ("Check: " + aMessage);
	
		var generator=new CTATXML ();
	
		commLMSService.sendSummary	(generator.xmlToString (aMessage.getXMLObject ()));
		
		lastMessage=true;
	};

	/**
	 * 
	 */
	this.processProblemRestoreEnd=function processProblemRestoreEnd (aMessage)
	{
		pointer.debug("processProblemRestoreEnd()");
		
	};
	/**
	 * 
	 */
	this.processHintResponse=function processHintResponse (aMessage,aHintArray)
	{
		pointer.debug("processHintResponse()");
				
		// First process the array of hints ...
		
		//if(pointer.getEnabled()==true)
		//{		
			for (var i=0;i<feedbackComponents.length;i++)
			{
				var feedbackComponent=feedbackComponents [i];
				
				pointer.debug ("Calling showHint () ...");

				feedbackComponent.showHint (aHintArray);
			}
		//}
			
		// Next show any hints if necessary ...
			
		var highlightSAI=aMessage.getSAI();
		
		if (highlightSAI!=null)
		{
			var highlightSelection=highlightSAI.getSelection ();
			
			if (highlightSelection!=null)
			{
				var aComponent=tools.findComponent (highlightSelection);
				
				if (aComponent!=null)
					aComponent.setHintHighlight (true);
				else
					pointer.debug ("Unable to find component name in list: " + aComponent);
			}
			else
				pointer.debug ("Error: no highlight selection present in SAI");
		}
		else
			pointer.debug ("Warning: no SAI found in highlight message");
		
		// All done
	};
	/**
	 * 
	 */
	this.globalReset=function globalReset ()
	{
		pointer.debug ("globalReset ()");
		
		// Reset global variables ...
		
		scriptElement="";
		
		var tools=new CTATShellTools ();
		
		tools.listComponents ();
		
		// First iterate through all the regular gradeable components ...
		
		for (var i=0;i<components.length;i++)
		{
			var aDesc=components [i];
						
			var component=aDesc.getComponentPointer ();
			
			if (component!=null)
			{
				pointer.debug ("Calling reset on regular component ...");				
				
				component.reset ();
			}
		}
		
		// Next iterate through all components that are not in our main list ...
		
		/*
		for (var j=0;j<feedbackComponents.length;j++)
		{
			var feedbackComponent=feedbackComponents [j];
			
			pointer.debug ("Calling reset on feedback component ...");

			feedbackComponent.reset ();
		}
		*/		
		
		// Finally reset the CommShell ...
		
		this.reset ();
	};
	/**
	* See the following url for more information on the tutor <-> tutoring service protocol:
	* https://docs.google.com/document/d/1B4r8jf4vv8dDkL5ULl1aSMngpmS5TevB1qsGyjSweho/edit
	*/
	this.nextProblem=function nextProblem (aMessage)
	{
		pointer.debug("nextProblem ()");
	
		if (isBlank (aMessage))
		{
			pointer.debug("Message is blank, requesting next problem ...");
		
			var vars=flashVars.getRawFlashVars ();
									
			var url=vars ['run_problem_url'];
						
			commLibrary.send (url);
		}
		else
		{
			pointer.debug("Message contains html data, writing ...");
							
			try
			{
				document.close(); // if open
			}
			catch (err)			
			{
				alert ("Error closing document: " + err.message);
			}
			
			try
			{
				document.write (aMessage);
			}
			catch (err)			
			{
				alert ("Error writing document: " + err.message);
			}			
		}	
	};
	/**
	 *  
	 */
	this.updateSkillWindow=function updateSkillWindow ()
	{
		pointer.debug("updateSkillWindow()");
		
		var skillWindow=tools.findComponentByClass ("CTATSkillWindow");
		
		if (skillWindow!=null)
		{
			//skillWindow.drawComponent ();
		}
		else
			pointer.debug("Info: no skill window available");
	};
	/**
	 * 
	 */
	this.processComponentFocus=function processComponentFocus(aComponent)
	{
		//useDebugging=true;
		
		pointer.debug("processComponentFocus("+aComponent.getName ()+","+aComponent.getClassName ()+")");
		
		if ((aComponent.getClassName ()=="CTATTextInput") || (aComponent.getClassName ()=="CTATTextField") || (aComponent.getClassName ()=="CTATTextArea"))
		{
			selectedTextInput=aComponent;
			
			// Trigger custom keyboard on mobile devices ...
			
			if (mobileAPI!=null)
			{
				if (mobileAPI.getEnabled ()==true)
				{
					mobileAPI.processTextFocus (aComponent.getX (),
												aComponent.getY (),
												aComponent.getWidth (),
												aComponent.getHeight ());
				}	
			}
		}
		else
			selectedTextInput=null;
		
		//useDebugging=false;
	};
}

CTATCommShell.prototype = Object.create(CTATBase.prototype);
CTATCommShell.prototype.constructor = CTATCommShell;
/**------------------------------------------------------------------------------------
 $Author$ 
 $Date$ 
 $Header$ 
 $Name$ 
 $Locker$ 
 $Log$

 -------------------------------------------------------------------------------------
 License:
 -------------------------------------------------------------------------------------
 ChangeLog:
 -------------------------------------------------------------------------------------
 Notes:
 ------------------------------------------------------------------------------------
*/

/**
 *
 */
function CTATConnection () 
{	
	CTATBase.call(this, "CTATConnection","connection");
	
	this.id=-1;
	this.consumed=false;
	this.url="";
	this.data="";
	this.httpObject=null;
				
	var pointer = this;
	
	/**
	*
	*/	
	this.createHTTPObject=function createHTTPObject ()
	{
		pointer.debug ("createHTTPObject ()");
	
		this.httpObject=new XMLHttpRequest(); 
			
		if (window.XMLHttpRequest) 
		{		
			pointer.debug ("Creating regular XMLHttpRequest ...");
		
			this.httpObject=new XMLHttpRequest(); 
		
			if (this.httpObject.overrideMimeType) 
			{	
				this.httpObject.overrideMimeType('text/html');
			}		
		} 
		else if (window.ActiveXObject) 
		{
			pointer.debug ("Detected window.ActiveXObject ...");
		
			// IE
			try 
			{
				pointer.debug ("Creating Msxml2.XMLHTTP ...");
			
				this.httpObject=new ActiveXObject ("Msxml2.XMLHTTP");
			} 
			catch (e) 
			{					
				try 
				{
					pointer.debug ("Creating Microsoft.XMLHTTP ...");
				
					this.httpObject=new ActiveXObject("Microsoft.XMLHTTP");
				} 
				catch (e) 
				{
					alert ('Error: Unable to create HTTP Request Object: ' + e.message);
				}
			}
		}		
	};
	/**
	* Do not call this method before open is called on the http object. If you do you will
	* get a Javascript exception that says: "an attempt was made to use an object that is 
	* not or is no longer usable"
	*/
	this.init=function init ()
	{
		pointer.debug ("init ()");
							
		if (this.httpObject!=null)
		{	
			var fVars=flashVars.getRawFlashVars ();	
			var aSession=fVars ['session_id'];
	
			try
			{
				this.httpObject.setRequestHeader ("Access-Control-Allow-Origin","*");
				//this.httpObject.setRequestHeader ("Access-Control-Allow-Headers","Origin, X-Requested-With, Content-Type, Accept");
				this.httpObject.setRequestHeader ("ctatsession",aSession);
				//this.httpObject.setRequestHeader ("Content-type","application/x-www-form-urlencoded");
				//this.httpObject.setRequestHeader ("Content-type","application/xml");
				this.httpObject.setRequestHeader ("Content-type","*/*");
			}
			catch (err)
			{
				alert ("HTTP object creation error: " + err.message);
			}
		}
		else	
			alert ("Internal error: http object is null right after creation");	
			
		pointer.debug ("init () done");
	};	
	
	this.createHTTPObject ();
}

CTATConnection.prototype = Object.create(CTATBase.prototype);
CTATConnection.prototype.constructor = CTATConnection;
/**------------------------------------------------------------------------------------
 $Author$ 
 $Date$ 
 $Header$ 
 $Name$ 
 $Locker$ 
 $Log$
 
 -
 License:
 -
 ChangeLog:
 -
 Notes:
 
*/

/**
 * CTATCurriculumService handles interaction with Curriculum Services, such as TutorShop.
 * <p>TutorShop is the primary Curriculum Service that CTAT is used with, as such the 
 * problem-to-problem protocol defined here is modeled after the specifications expected 
 * by TutorShop. It should be made clear that this class does not represent a 
 * CurriculumService in itself but the way in which CTAT interfaces with one.</p>
 */
function CTATCurriculumService (aCommLibrary)
{
	CTATBase.call(this, "CTATCurriculumService","curriculum_service");
	
	var commLibrary=aCommLibrary;
	var variables=new Array ();
	var pointer = this;
	
	/**
	 * 
	 */
	this.reset=function reset ()
	{
		variables=new Array ();
	};
	/**
	 * 
	 */
	this.addVariable=function addVariable (aName,aValue)
	{
		var variable=new CTATVariable ();
		variable.name=aName;
		variable.value=aValue;
		
		variables.push (variable);
	};
	/**
	 * Sends a problem summary to the Curriculum Service and initiates the problem-to-problem protocol.
	 * <p>The specifics of CTAT's behavior during the problem-to-problem protocol are defined by FlashVars provided by the
	 * Curriculum Service. If <code>reuse_swf</code> is set to <code>true</code> then the interface will reset itself and
	 * make a URLRequest to the <code>curriculum_service_url</code> for new flashVars. If <code>reuse_swf</code> is <code>false</code>
	 * then flash will navigate to a new URL to load the next problem.</p>
	 * @param	problemSummary	A ProblemSummary message received from the Tutoring Service.
	 */
	this.sendSummary=function sendSummary (problemSummary) 
	{			
		pointer.debug("Forwarding Summary to tutorshop: " + problemSummary);
						
		ctatscrim.nextProblemScrimUp ();
							
		var vars=flashVars.getRawFlashVars ();
		
		var url=vars ['curriculum_service_url'];
		
		variables=new Array ();

		this.addVariable ('user_guid',vars ['user_id']);
		this.addVariable ('session_id',vars ['session_id']);
		this.addVariable ('authenticity_token',vars ['authenticity_token']);
		this.addVariable ('school_name',vars ['school_name']);
		this.addVariable ('summary',encodeURIComponent(problemSummary));
		this.addVariable ('problem_state',""); // This will come later
		
		var targetFrame=vars ['target_frame'];
		var reuseSWF=vars ['reuse_swf'];
		
		this.addVariable ('targetFrame',targetFrame);
		this.addVariable ('reuseSWF',reuseSWF);
		
		pointer.debug ("TargetFrame = " + targetFrame + " reuseSwf " + reuseSWF);
		
		commLibrary.send_post_variables (url,variables);
	};

	/**
	 * 
	 */
	/*
	this.downloadComplete=function downloadComplete(event)
	{
		var data;
	
		pointer.debug("Download Complete");
		pointer.debug("Loader data : " + connectionManager.getProblemSummaryData());
		pointer.debug("loader data_format " + connectionManager.getProblemSummaryDataFormat());
			
		if(CTATLinkData.commShell.inSaveAndQuitMode)
		{
			CTATLinkData.commShell.exitTutor();
			return;
		}
			
		//if data is a URLVariables object then use it as one
		if (connectionManager.getProblemSummaryDataFormat() == URLLoaderDataFormat.VARIABLES) 
		{
			data = connectionManager.getProblemSummaryData();
		}
		//If data is not a URLVariables object then effectively make it one.
		else if (connectionManager.getProblemSummaryDataFormat() == URLLoaderDataFormat.TEXT) 
		{
			data = { };
			var tempArr:Array = connectionManager.getProblemSummaryData().split("&");
			
			for each (var variable_assignment:String in tempArr) 
			{
				//var pair:Array = variable.split("=");
				var delim:int = variable_assignment.indexOf("=");
				var variableName:String = variable_assignment.substring(0,delim);
				var variableValue:String = variable_assignment.substring(delim+1);
			
				pointer.debug("Flashvar encoded = " + variableValue);
				
				variableValue = unescape(variableValue.replace(/\+/g, " "));//First convert plus signs to space, then unescape
				
				pointer.debug("Flashvar decoded = " + variableValue);
				
				data[variableName] = variableValue;
			}
		}
		else 
		{
			pointer.debug("CTATCurriculumService has no idea what to do with binary data");
			return;
		}
			
		pointer.debug("reuse_swf access = " + CTATLinkData.flashVars.reuse_swf);
		pointer.debug("reuse_swf getFlashVar = " + CTATLinkData.flashVars.getFlashVar("reuse_swf"));
		pointer.debug("flashVars.student_interface = " + CTATLinkData.flashVars.student_interface);
		pointer.debug("data.student_interface = " + data.student_interface);
			
		//IF we aren't reuseing_swf, or current.student_interface != downloaded.student_interface, navigateTo a new URL
		//ELSE reset the current interface.
		if (!CTATLinkData.flashVars.reuse_swf || (CTATLinkData.flashVars.student_interface != data.student_interface)) 
		{
			//load the new swf
			var target_frame:String = (CTATLinkData.flashVars.checkIsValid("target_frame") ? CTATLinkData.flashVars.target_frame : "_self");

			//We are supposed to use run_problem_url, but older versions of tutorshop might
			//not be updated and will accept a second request to curriculum_service_url.
			var url:String = (CTATLinkData.flashVars.checkIsValid("run_problem_url") ? CTATLinkData.flashVars.run_problem_url : CTATLinkData.flashVars.curriculum_service_url);
				
			pointer.debug(" url is " + url);
				
			//We don't need to send any extra data for this request.
			var request:URLRequest = new URLRequest(url);
			request.method = "POST";
				
			try 
			{
				//to_be_fixed. We should use target_frame here, rather then self.
				//Also, we should lock the interface incase reuse_swf is false.
				
				pointer.debug("Target_frame = " + target_frame);
				
				if(target_frame != null)
					navigateToURL(request, target_frame);
				else
					navigateToURL(request, "_self");
			}
			catch(err) 
			{
				pointer.debug("ERROR " + err);
			}
		}
		else 
		{
			CTATLinkData.scrim.scrimUp ("Loading the Next Problem...");

			//update the flashVars
			CTATLinkData.flashVars.updateFlashVars(data);
				
			//Updating the number-bar outside the SWF on tutorshop
			pointer.debug ("Info is : " + CTATLinkData.flashVars.info);
			
			if (CTATLinkData.flashVars.checkIsValid("info"))
			{
				pointer.debug("Valid info... calling javascript");
				
				//ExternalInterface.call("javaScriptInfo('"+CTATLinkData.flashVars.info+"')");
				
				pointer.debug("success.. I think?");
			}
				
			this.resetInterface();
		}
	};
	*/
		
	/**
	 * Note the type of the param is Object because it may be a URLVariables object, but it 
	 * also might be an Associative Array, i.e. Object
	 * @param	variables
	 */
	this.updateFlashVars=function updateFlashVars(variables) 
	{
		pointer.debug("UpdateFlashVars ()");
		
		/*
		CTATLinkData.flashVars.updateFlashVars(variables);
		
		var xml:XML = new XML(decodeURIComponent(variables.skills));
		
		if(xml.skill != undefined)
				CTATLinkData.skills.fromXMLString(xml.skill);
		
		CTATLinkData.hints.resetHints();
		*/
	};
		
	/**
	 * This is a hard reset and should be used carefully. It will bring the
	 * interface back to the state where it was when it was first loaded.
	 */		
	this.resetInterface=function resetInterface() 
	{
		pointer.debug ("resetInterface ()");
			
		// Reset the message tank ...
			
		pointer.debug ("Resetting message tank ...");
		
		/*
		CTATLinkData.messageHistory=new CTATMessageHistory ();
		*/
						
		// Call reset on every component ...
			
		pointer.debug ("Calling reset on every component ...");
			
		for (var i=0;i<this.components.length;i++)
		{
			var aComponent=this.components [i]; // CTATStyle
			
			aComponent.reset ();
		}	
			
		pointer.debug ("Resetting feedback components ...");
			
		// This is partially to confirm that everything has been properly reset 
		// and also confirms that the hint window gets properly reset.
		
		for (var j=0;j<this.feedbackComponents.length;j++)
		{
			var aFeedbackComponent=this.feedbackComponents [j]; // CTATStyle
			
			aFeedbackComponent.reset ();
		}	
					
		// And finally reset the commshell itself ...
			
		pointer.debug ("Resetting the commshell ...");

		if (commShell!=null)
		{
			commShell.reset();
		}	
	};
		
	/**
	 * This code is borrowed from the adobe help reference on navigateToURL() it is used to validate a URL before
	 * calling navigatToURL
	 * AS3 Regular expression pattern match for URLs that start with http:// and https:// plus your domain name.
	 * @param	flashVarURL
	 * @return
	 */
	this.checkProtocol=function checkProtocol (flashVarURL) 
	{
		if ((flashVarURL == "localhost") || (flashVarURL == "127.0.0.1"))
			return true;
		
		/*
		// Get the domain name for the SWF if it is not known at compile time.
		// If the domain is known at compile time, then the following two lines can be replaced with a hard coded string.
		var my_lc:LocalConnection = new LocalConnection();
		var domainName:String = my_lc.domain;
		*/
		
		// Build the RegEx to test the URL.
		// This RegEx assumes that there is at least one "/" after the
		// domain. http://www.mysite.com will not match.
		
		var pattern=new RegExp("^http[s]?\:\\/\\/([^\\/]+)\\/");
		var result=pattern.exec(flashVarURL);
		
		if (result == null || flashVarURL.length >= 4096) 
		{
			return (false);
		}
		
		return (true);
	};
}

CTATCurriculumService.prototype = Object.create(CTATBase.prototype);
CTATCurriculumService.prototype.constructor = CTATCurriculumService;
/**------------------------------------------------------------------------------------
 $Author$ 
 $Date$ 
 $Header$ 
 $Name$ 
 $Locker$ 
 $Log$
 
 -
 License:
 -
 ChangeLog:
 -
 Notes:
 
*/

/**
 *  
 */
function CTATLoggingLibrary ()
{
	CTATBase.call(this, "CTATLoggingLibrary", "logginglibrary");
	
	var pointer=this;
	
	// The current version of this LoggingLibrary.
	var version="3.Beta";
	
	// The version of the DataShop DTD specification that this LoggingLibrary conforms with.
	var DTDVersion="4";
	
	// I just copy pasted this off of DataShop's website, its probably right but it may not even be necessary to include.
	var nameSpace="xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance' xsi:noNamespaceSchemaLocation='http://learnlab.web.cmu.edu/dtd/tutor_message_v4.xsd'";
	
	// The standard XMLProlog, we actually reference this a lot.
	var xmlProlog='<?xml version="1.0" encoding="UTF-8"?>';	

	var useOLILogging=true;	
	
	/**
	 * 
	 */
	this.startProblem=function startProblem ()
	{
		pointer.debug ("startProblem ()");
		
		this.sendMessage (commLogMessageBuilder.createContextMessage(true));
	};
	/**
	*
	*/		
	this.sendMessage=function sendMessage (message) 
	{				
		pointer.debug ("sendMessage ()");
		
		return; // Temporarily disabled for debugging purposes		
		
		/*
		message = xmlProlog + '<tutor_related_message_sequence version_number="' + DTDVersion + '">' + message + '</tutor_related_message_sequence>';
		
		pointer.debug ("Pre encoded log message: " + message);
		
		if (useOLILogging==true)
		{
			message = commLogMessageBuilder.wrapForOLI (message);
		}	
		
		var vars=flashVars.getRawFlashVars ();
		
		commLibrary.sendXML (message);
		*/
	};
	/**
	 * @private
	 * This is the internal version of Semantic Event logging for within CTAT itself and won't be visible in the API.
	 * NOTE:We will also end up using this one for hints.
	 * @param	transactionID			A GUID for the transaction
	 * @param	sai						A CTATSAI for the action.
	 * @param	semanticEventName		A name for the Semantic Event, usually "ATTEMPT"
	 * @param	semanticEventSubtype	A subtype for the Semantic Event, commonly used to refer to tutor-performed actions
	 */
	this.logSemanticEvent=function logSemanticEvent (transactionID,
									  				 sai, 
									  				 semanticEventName,
									  				 semanticEventSubtype,
									  				 customFieldNames,
									  				 customFieldValues) 
	{
		var timeStamp = new Date();
					
		commLogMessageBuilder.resetCustomFields ();		
		commLogMessageBuilder.addCustomField ("tool_event_time",commLogMessageBuilder.formatTimeStamp (timeStamp));
				
		var message=commLogMessageBuilder.createSemanticEventToolMessage (sai, 
																		  transactionID,
																		  semanticEventName,
																		  semanticEventSubtype,
																		  useOLILogging,
																		  customFieldNames,
																		  customFieldValues);
		this.sendMessage (message);		
	};
	/**
	 * @private
	 * This is the internal method to send a tutor_message. It will not show up in the external API.
	 * NOTE: we will end up using this for hints as well, though you can use one of the public version as well.
	 * @param	transactionID
	 * @param	sai
	 * @param	anEval
	 * @param	feedBack
	 * @param	skills
	 */
	this.logTutorResponsefunction=function logTutorResponse (transactionID,
									  						 sai,
									  						 semanticName,
									  						 semanticSubtype,
									  						 anEval,
									  						 feedBack,
									  						 skills, 
									  						 customFieldNames, 
									  						 customFieldValues) 
	{
		pointer.debug("CTATLoggingLibrary","logTutorResponse ()");
		
		var timeStamp = new Date();
					
		pointer.debug("CTATLoggingLibrary","Adding custom field names ...");
			
		commLogMessageBuilder.resetCustomFields ();		
		commLogMessageBuilder.addCustomField ("tutor_event_time",commLogMessageBuilder.formatTimeStamp (timeStamp));
				
		pointer.debug("CTATLoggingLibrary","Formatting feedback ...");
		
		var formattedFeedback=feedBack;
		
		if ((feedBack.indexOf("'")!=-1) || 
			(feedBack.indexOf("\"")!=-1) || 
			(feedBack.indexOf("<")!=-1) || 
			(feedBack.indexOf(">")!=-1) || 
			(feedBack.indexOf("&")!=-1))
		{
			pointer.debug("CTATLoggingLibrary","Feedback message contains invalid characters, wrapping in CDATA ...");
			formattedFeedback="<![CDATA["+feedBack+"]]>";
		}
		else
			pointer.debug("CTATLoggingLibrary","Feedback message doesn't contain any invalid characters, using as-is");			
		
		pointer.debug("CTATLoggingLibrary","Creating tutor message ...");
		
		var message=commLogMessageBuilder.createTutorMessage (context,
															  sai,
															  transactionID,
															  semanticName,
															  anEval,
															  formattedFeedback,
															  semanticSubtype,
															  skills,
															  useOLILogging,
															  customFieldNames, 
															  customFieldValues);		
		this.sendMessage (message);
	};
}

CTATLoggingLibrary.prototype = Object.create(CTATBase.prototype);
CTATLoggingLibrary.prototype.constructor = CTATLoggingLibrary;
/**------------------------------------------------------------------------------------
 $Author$ 
 $Date$ 
 $Header$ 
 $Name$ 
 $Locker$ 
 $Log$
 
 -
 License:
 -
 ChangeLog:
 -
 Notes:
 
*/

/**
 * CTATLogMessageBuilder is used to create xml log messages that conform to DataShop's specifications.
 * <p> This class contains static factory methods that are used to create the different types of log messages used in the 
 * DataShop specification.</p>
 * Example:
 	<tutor_related_message_sequence version_number="4">
		<context_message context_message_id="98F2147D22FAA521048373A69AB06C23B347866" name="LOAD_TUTOR">
			<class>
				<name>Default Class</name>
				<school>Admin</school>
				<instructor>admin</instructor>
			</class>
			<dataset>
				<name>Mathtutor</name>
				<level type="ProblemSet">
					<name>QA2.0_debug_enabled_tutor</name>
					<problem>
						<name>1415-error</name>
					</problem>
				</level>
			</dataset>
		</context_message>
	</tutor_related_message_sequence>
*/
function CTATLogMessageBuilder ()
{
	CTATBase.call (this,"CTATLogMessageBuilder","logmessagebuilder");
	
	var pointer=this;
		
	// Blanked this out to kill a bug that generated extra XML headers. Used to be = '<?xml version="1.0" encoding="UTF-8"?>'
	var xmlHeader = '';
	
	/**
	 * The standard XMLProlog, we actually reference this a lot.
	 */
	var xmlProlog = '<?xml version="1.0" encoding="UTF-8"?>';	
	
	var customFieldNames=new Array ();
	var customFieldValues=new Array ();
	
	/**
	 * <b>[Required]</b> The &#60;name&#62; attribute of the current context.
	 * <p>The name attribute is used to indicate where the student is in the process of working on a tutor or problem. 
	 * The PSLC DataShop team has established some canonical values for this attribute that should be used,
	 * displayed in <a href="http://pslcdatashop.web.cmu.edu/dtd/guide/context_message.html#table.context_message.name.values">Table 1, Recommended values for the &#60;context_message&#62; name attribute</a>.</p>
	 * @param	context_name	A name for the current context, see table for a set  of recommended names.
	 */
	this.setContextName=function setContextName(context_name) 
	{ 
		contextGUID = context_name; 
	};
		
	this.getContextName=function getContextName()
	{
		return contextGUID;
	};
	
	/**
	*	Builds a context message to the Data Shop specifications.
	*	@see http://pslcdatashop.web.cmu.edu/dtd/guide/context_message.html 
	*	DataShop specification for context_message
	*/
	this.createContextMessage=function createContextMessage (aWrapForOLI) 
	{
		pointer.debug("createContextMessage()");
					
		var now=new Date();
		
		var vars=flashVars.getRawFlashVars ();
		
		var messageString=xmlHeader+'<context_message context_message_id="'+vars ['session_id']+'" name="'+ this.getContextName()+'">';

		if(!aWrapForOLI) 
		{
			messageString += this.makeMetaElement(now);			
		}
		
		/*

		//<class>
		if (contextObj.hasClassField()) 
		{
			var classS:String = '<class>';
			if(contextObj.hasClassName()) {classS += '<name>'+contextObj.ClassName+'</name>';}
			if(contextObj.hasClassSchool()) {classS += '<school>'+contextObj.ClassSchool+'</school>';}
			if(contextObj.hasClassPeriod()) {classS += '<period>'+contextObj.ClassPeriod+'</period>';}
			if(contextObj.hasClassDescription()) {classS += '<description>'+contextObj.ClassDescription+'</description>';}
			if (contextObj.hasClassInstructor()) { classS += '<instructor>' + contextObj.ClassInstructor + '</instructor>';}
			classS += '</class>';
			messageString += classS;
		}			
		
		//<dataset>
		var dataset:String = '<dataset>';
		dataset += '<name>'+contextObj.DatasetName+'</name>';
		var datasetLevelTypes:Vector.<String> = contextObj.DatasetLevelTypes;
		var datasetLevelNames:Vector.<String> = contextObj.DatasetLevelNames;
		for (var level:String in datasetLevelTypes) 
		{
			dataset += '<level type="' + datasetLevelTypes[level] + '">';
			dataset += '<name>' + datasetLevelNames[level] + '</name>';
		}
		
		//<dataset><problem>
		dataset += '<problem';
							
		if ((CTATLinkData.flashVars.getFlashVar ("problem_tutorflag")!="") || (CTATLinkData.flashVars.getFlashVar ("problem_otherproblemflag")!=""))
		{
			if (CTATLinkData.flashVars.getFlashVar ("problem_tutorflag")!="")
			{
				dataset+=' tutorFlag="'+CTATLinkData.flashVars.getFlashVar ("problem_tutorflag")+'"';
			}
			else
			{
				dataset+=' tutorFlag="other"';
			}
		}
		
		dataset += '>';
		dataset += '<name>'+contextObj.ProblemName+'</name>';		
		dataset += '<context>' + contextObj.ProblemContext + '</context>';
		dataset += '</problem>';
		
		for (var i:int = 0;  i < datasetLevelTypes.length;i++ ) 
		{
			dataset += '</level>';
		}
		
		dataset += '</dataset>';
		
		messageString += dataset;
						
		//<condition>
		if (contextObj.hasConditions()) 
		{
			var condition:String="";
			var conditionNames:Vector.<String> = contextObj.getConditionNames();
			var conditionTypes:Vector.<String> = contextObj.getConditionTypes();
			var conditionDescriptions:Vector.<String> = contextObj.getConditionDescriptions();
			
			for (var cond:String in conditionNames) 
			{
				condition += '<condition><name>'+conditionNames[cond]+'</name>';
				condition += (conditionTypes[cond] == "" ? "" : '<type>'+conditionTypes[cond]+'</type>');
				condition += (conditionDescriptions[cond] == "" ? "" : '<desc>'+conditionDescriptions[cond]+'</desc>');
				condition += '</condition>';
			}
			messageString += condition;
		}
		
		*/
		
		//messageString+=this.createCustomFields (customFieldNames,customFieldValues);
		messageString+=this.createCustomFields (null,null);
		
		messageString += "</context_message>";
		
		if (aWrapForOLI==true) 
		{
			messageString = this.wrapForOLI (messageString);
		}
		
		pointer.debug ("messageString = " + messageString);
		
		return messageString;
	};

	/**
	*	Builds a tool message to the Data Shop specifications, for tool messages with semantic_event fields.
	* 	<p>The basic difference between the tool messages is that a Semantic Event message contains data that is
	* 	useful in a tutoring context where a UI_Event does not.</p>
	*	@see http://pslcdatashop.web.cmu.edu/dtd/guide/tool_message.html DataShop specification for tool_message
	*/
	this.createSemanticEventToolMessage=function createSemanticEventToolMessage(sai, 
														  						semanticTransactionID,
														  						semanticName,
														  						semanticSubType,
														  						wrapForOLI,
														  						customFieldNames, 
														  						customFieldValues) 
	{
		pointer.debug ("createSemanticEventToolMessage()");
				
		var now=new Date();
		var vars=flashVars.getRawFlashVars ();
		var messageString=xmlHeader+'<tool_message context_message_id="'+vars ['session_id']+'">';
		
		//<meta>
		if (!wrapForOLI) 
		{
			messageString += this.makeMetaElement (now);
		}
		
		//<semantic_event> (1+)
		var semantic='<semantic_event transaction_id="'+semanticTransactionID+ '" name="' + semanticName + '"';
		
		if (semanticSubType != "")
			semantic += ' subtype="' + semanticSubType + '"';
			
		semantic+='/>';
		messageString+=semantic;
					
		//<event_descriptor>(0+)
		var eventDescriptor = '<event_descriptor>';
		eventDescriptor+=sai.toXMLString(true);
		eventDescriptor+='</event_descriptor>';
		messageString+=eventDescriptor;
		
		messageString+=this.createCustomFields (customFieldNames,customFieldValues);
		
		messageString += '</tool_message>';
		
		if (wrapForOLI) 
		{
			messageString = this.wrapForOLI(messageString);
		}
		
		pointer.debug ("messageString = "+messageString);
		
		return messageString;
	};
	
	/**
	*	Builds a tool message to the Data Shop specifications, for tool messages with ui_event fields.
	* 	<p>The basic difference between the tool messages is that a Semantic Event message contains data that is
	* 	useful in a tutoring context where a UI_Event does not.</p>
	*	@see http://pslcdatashop.web.cmu.edu/dtd/guide/tool_message.html DataShop specification for tool_message
	*/
	this.createUIEventToolMessage=function createUIEventToolMessage (sai,
																	 uiEventName,
																	 uiEventField,
																	 wrapForOLI,
																	 customFieldNames, 
																	 customFieldValues) 
	{
		pointer.debug ("createUIEventToolMessage()");
		
		var now = new Date();
		var vars=flashVars.getRawFlashVars ();
		var messageString = xmlHeader+'<tool_message context_message_id="'+vars ['session_id']+'">';
		
		//<meta>
		if (!wrapForOLI) 
		{
			messageString += this.makeMetaElement (now);
		}
			
		//<ui_event> (1+)
		var uiEvent = '<ui_event name="'+uiEventName+'">'+uiEventField+'</ui_event>';
		messageString += uiEvent;
		
		//<event_descriptor>(0+)
		var eventDescriptor = '<event_descriptor>';
		eventDescriptor+=sai.toSerializedString();
		eventDescriptor+='</event_descriptor>';
		
		messageString+=eventDescriptor;
		
		messageString+=this.createCustomFields (customFieldNames,customFieldValues);
		
		messageString+='</tool_message>';
		
		if (wrapForOLI)
		{
			messageString = this.wrapForOLI(messageString);
		}
		
		pointer.debug ("messageString = "+messageString);
		
		return messageString;
	};
	
	/**
	*	Builds a tutor message to the Data Shop specifications.
	*	@see http://pslcdatashop.web.cmu.edu/dtd/guide/tutor_message.html DataShop specification for tutor_message
	*/
	this.createTutorMessage=function createTutorMessage (sai,
											   			 semanticTransactionID,
											   			 semanticName,
											   			 evalObj,
											   			 advice,
											   			 semanticSubType,
											   			 skillList,
											   			 wrapForOLI,
											   			 customFieldNames, 
											   			 customFieldValues) 
	{
		pointer.debug ("createTutorMessage()");
		
		var now = new Date();
		var vars=flashVars.getRawFlashVars ();
		var messageString = xmlHeader+'<tutor_message context_message_id="'+vars ['session_id']+'">';
		
		//<meta>
		if (!wrapForOLI) 
		{
			messageString += this.makeMetaElement(now);
		}
		
		//<semantic_event> (1+)
		var semantic = '<semantic_event transaction_id="' + semanticTransactionID + '" name="' + semanticName + '"';
		
		if (semanticSubType != "") 
		{ 
			semantic += ' subtype="' + semanticSubType + '"'; 
		}
		
		semantic+='/>';
		messageString+=semantic;
		
		//<event_descriptor>(0+)
		var eventDescriptor = '<event_descriptor>';
		eventDescriptor+=sai.toXMLString(true);
		eventDescriptor+='</event_descriptor>';
		messageString+=eventDescriptor;

		//<action_evaluation> (0+)
		var actionEvaluation = '<action_evaluation ';
		if (evalObj.hasClassification())
		{
			if (evalObj.getAttributeString()!=null)					
				actionEvaluation += evalObj.getAttributeString();
		}
		
		actionEvaluation += '>'+evalObj.getEvaluation()+'</action_evaluation>';
		messageString += actionEvaluation;

		//<tutor_advice>(0+)
		if (advice != "") 
		{
			messageString += '<tutor_advice>'+advice+'</tutor_advice>';
		}

		//<skill> (0+)
		/*
		if (skillList != null ) 
		{
			var skills = "";
			
			for each (var skill in skillList) 
			{
				skills += "<skill probability=\""+skill.getLevel()+"\"><name>"+skill.getSkillName()+"</name>";
				
				if (skill.hasCategory()) 
				{
					skills +='<category>' + skill.getCategory() + '</category>';
				}
				
				if (skill.hasModelName()) 
				{ 
				 	skills += '<model_name>' + skill.getModelName() + '</model_name>'; 
				}					
				
				skills += '</skill>';
			}
			
			messageString += skills;
		}
		*/
		
		messageString+=this.createCustomFields (customFieldNames,customFieldValues);
		
		messageString += '</tutor_message>';
		
		if (wrapForOLI) 
		{
			messageString = this.wrapForOLI(messageString);
		}
		
		pointer.debug(classType,"messageString = "+messageString);
		
		return messageString;
	};
		
	/**
	*	Builds a generic message to the Data Shop specifications.
	*	<p>In practice this will only assure that the message compiles with general XML specifications and that
	*	it contains the minimal requirements for a "message" in Data Shop's specifications.</p>
	*	@see http://pslcdatashop.web.cmu.edu/dtd/guide/message_message.html DataShop specification for message
	*/
	this.createGenericMessage=function createGenericMessage(logMessage,wrapForOLI) 
	{
		pointer.debug ("createGenericMessage()");
		
		var vars=flashVars.getRawFlashVars ();		
		
		var messageString = xmlHeader+'<message context_message_id="'+vars ['session_id']+'">';
		messageString+=logMessage;
		messageString+='</message>';
		
		if (wrapForOLI==true) 
		{
			messageString = this.wrapForOLI (messageString);
		}
		
		pointer.debug ("messageString = "+messageString);
		
		return messageString;
	};
	
	/**
	 * 
	 */
	this.makeMetaElement=function makeMetaElement (timeStamp) 
	{					
		var vars=flashVars.getRawFlashVars ();
		
		var meta='<meta>';
		meta += '<user_id>'+vars ['user_guid']+'</user_id>';
		meta += '<session_id>'+vars ['session_id']+'</session_id>';
		meta += '<time>'+this.formatTimeStamp(timeStamp)+'</time>';
		meta += '<time_zone>'+flashVars.getTimeZone ()+'</time_zone></meta>';
		
		return meta;
	};
	
	/**
	*
	*/				
	this.wrapForOLI=function wrapForOLI(messageString) 
	{	
		var now=new Date();
		
		var vars=flashVars.getRawFlashVars ();
		
		messageString = encodeURIComponent(messageString);
		
		var wrapper = xmlProlog + '<log_action ';
		wrapper += 'auth_token="'+vars ['auth_token']+'" ';
		wrapper += 'session_id="' + vars ['session_id'] + '" ';
		wrapper += 'user_guid="' + vars ['user_guid'] + '" ';
		wrapper += 'date_time="' + this.formatTimeStamp(now) + '" ';
		wrapper += 'timezone="' + flashVars.getTimeZone () + '" '; 
		wrapper += 'source_id="' + vars ['source_id'] + '" ';
		wrapper += 'external_object_id="" info_type="tutor_message.dtd">';
		messageString = wrapper + messageString + "</log_action>";
		
		return messageString;
	};
	
	/**
	 * Creates a SessionStart message.
	 * <p>session_log messages are part of logging to an OLI framework.</p>
	 * @param	sessionObj	The CTATSessionData object, this is a member of CTATContextData 
	 * @return	Returns a session_log message.
	 */
	this.createLogSessionStart=function createLogSessionStart ()
	{
		var now=new Date();
		
		var message='<log_session_start timezone="' + flashVars.getTimeZone() + '" ';

		var vars=flashVars.getRawFlashVars ();
		
		message += 'date_time="'+this.formatTimeStamp(now) + '" ';
		message += 'auth_token="' +vars ['auth_token'] + '" ';
		message += 'session_id="' + vars ['session_id'] + '" ';
		message += 'user_guid="' + vars ['user_guid'] + '" ';
		message += 'class_id="" treatment_id="" assignment_id="" info_type="tutor_message.dtd"/>';
		
		return message;
	};
	
	/**
	 * Formats Date objects into Datashop's prefered format.
	 * @param	stamp	A Date object.
	 * @return	A String in the proper format
	 * 
	 * http://www.w3schools.com/jsref/jsref_obj_date.asp
	 */
	this.formatTimeStamp=function formatTimeStamp (stamp) 
	{
		var s="";
		var year= stamp.getFullYear();
		s += year+"/";

		var month=stamp.getMonth();
		month++;		
		s += ((month<10) ? ("0"+month) : month)+"/";

		var date = stamp.getDate();
		s += ((date<10) ? ("0"+date) : date)+" ";

		var hours = stamp.getHours();
		s += ((hours<10) ? ("0"+hours) : hours)+":";

		var mins = stamp.getMinutes();
		s += ((mins<10) ? ("0"+mins) : mins)+":";

		var secs = stamp.getSeconds();
		s += ((secs<10) ? ("0"+secs) : secs);

		var msec = stamp.getMilliseconds ();
		s+=".";
		s+=msec;

		return s;
	};
	/**
	 * 
	 * @param customFieldNames
	 * @param customFieldValues
	 * @returns {String}
	 */
	this.createCustomFields=function createCustomFields (aCustomFieldNames, 
											   			 aCustomFieldValues) 
	{
		pointer.debug ("createCustomFields ()");
		
		if ((aCustomFieldNames==null) || (aCustomFieldValues==null))
		{
			return ("");
		}
		
		var message='';
		
		for (var dex=0; dex < aCustomFieldNames.length; dex++) 
		{
			pointer.debug ("Adding custom field: ["+aCustomFieldNames[dex]+"],["+aCustomFieldValues[dex]+"]");
			
			message += '<custom_field>';
			message += '<name>' + aCustomFieldNames[dex] + '</name>';
			message += '<value>' + aCustomFieldValues[dex] + '</value>';
			message += '</custom_field>';
		}
		
		return message;
	};	
	/**
	 * 
	 */
	this.resetCustomFields=function resetCustomFields ()
	{
		this.customFieldNames=new Array ();
		this.customFieldValues=new Array ();				
	};
	/**
	 * 
	 */
	this.addCustomField=function addCustomfield (aName,aValue)
	{
		this.customFieldNames.push (aName);
		this.customFieldValues.push (aValue);
	};
	/**
	 * 
	 */
	this.getCustomFieldNames=function getCustomFieldNames ()
	{
		return (customFieldNames);
	};
	/**
	 * 
	 */
	this.getCustomFieldValues=function getCustomFieldValues ()
	{
		return (customFieldValues);
	};
}

CTATLogMessageBuilder.prototype = Object.create(CTATBase.prototype);
CTATLogMessageBuilder.prototype.constructor = CTATLogMessageBuilder;
/**------------------------------------------------------------------------------------
 $Author$ 
 $Date$ 
 $Header$ 
 $Name$ 
 $Locker$ 
 $Log$

 -------------------------------------------------------------------------------------
 License:
 -------------------------------------------------------------------------------------
 ChangeLog:
 -------------------------------------------------------------------------------------
 Notes:
 ------------------------------------------------------------------------------------
*/

/**
 * CTATMessage is used as an accessible representation of CTAT's message format.
 * <p>CTATMessage is mainly used to parse and manipulate messages that the interface 
 * receives from the TutoringService but it also maintains functionality to work with 
 * the DataShop log message format as well. The provided accessors do <i>not</i> represent 
 * an exhaustive list of all the possible fields a message can have, merely the most 
 * commonly used ones. Any field that is not given a direct accessor can be retrieved 
 * by working directly with the underlying <code>XML</code> object, though this would 
 * require a prior knowledge of the message's format, which is not very well documented 
 * at this time.</p>
 */
function CTATMessage (aMessage) 
{	
	CTATBase.call(this, "CTATMessage","message");
	
	var gradeResult="ungraded";
	var isLogMessage=false;
	var hassai=false;
	var rawMessage="";
	var xmlObj=null;
	
	if (aMessage instanceof String)
	{
		rawMessage=aMessage;
	}
	else
	{
		xmlObj=aMessage;
	}
	
	var messageType="";	
	var transactionID="";
	var toolSelection="";
	
	var sai=null; // CTATSAI
	var studentSAI=null; // CTATSAI
	
	var xmlParser=new CTATXML ();

	/**
	*
	*/
	this.setGradeResult=function setGradeResult (aResult)
	{
		gradeResult=aResult;
	};
	/**
	*
	*/
	this.getGradeResult=function getGradeResult() 
	{
		return gradeResult;
	};	
	/**
	*
	*/
	this.getXMLObject=function getXMLObject ()
	{
		return (xmlObj);
	};
	/**
	*
	*/
	this.parseMessage=function parseMessage (aMessage)
	{
		isLogMessage=false;
		hassai=false;
		rawMessage="";
		xmlObj=null;	
	
		if (aMessage instanceof String)
		{
			rawMessage=aMessage;
		}
		else
		{
			xmlObj=aMessage;
		}
	
		this.parse ();
	}
	/**
	 * 
	 */
	this.parse=function parse ()
	{
		//useDebugging=true;
		
		this.debug ("parse ()");
				
		if (xmlObj==null)
		{
			xmlObj=xmlParser.parseXML (rawMessage);
		}
		else
			this.debug ("Message already pre-parsed, walking the DOM ...");
		
		this.debug ("Root name: " + xmlParser.getElementName (xmlObj));
		
		if (xmlParser.getElementName(xmlObj)=="tool_message")
		{
			this.debug ("Detected tool message");
			messageType="tool_message";
		}
		else
		{
			if (xmlParser.getElementName (xmlObj) != "message") 
			{
				isLogMessage = true;
				messageType = xmlParser.getElementName (xmlObj);
			}
			else 
			{
				isLogMessage = false;
			
				this.parseMessageType ();
			}
		}
				
		this.parseTransactionID();
							
		this.parseSAI();
		
		this.debug ("Message " + messageType + ", with transaction id: " + transactionID);
		
		//useDebugging=false;
	};
	/**
	 * Depending on format SAI is located in different places
	 * @internal TODO - need to extend this to parse potential ComplexSAIs
	 */
	this.parseSAI=function parseSAI() 
	{
		this.debug ("parseSAI ()");
		
		var selection="";
		var action="";
		var input="";
		var prompt="";
					
		if (messageType=="tool_message")
		{
			this.debug ("Parsing s, a and i");

			var tList=xmlParser.getElementChildren (xmlObj);
			
			for (var t=0;t<tList.length;t++)
			{
				var entry=tList [t];
				
				if (xmlParser.getElementName (entry)=="tool_message")
				{
					var aList=xmlParser.getElementChildren (entry);
					
					for (var w=0;w<aList.length;w++)
					{
						var test=aList [w];
						
						if (xmlParser.getElementName (test)=="event_descriptor")
						{							
							sai=new CTATSAI ();
							sai.fromXMLInternal (test);							
						}	
					}	
				}
			}			
				
			hassai = true;				
				
			return;
		}
		
		/*
		if (hasProperty("tool_selection"))
		{
			//toolSelection = xmlObj.properties.tool_selection;
			
			var tList=xmlObj.childNodes;
			
			for (var t=0;t<tList.length;t++)
			{
				var entry=tList [t];
				
				if (entry.nodeName=="properties")
				{
					var aList=entry.childNodes;
					
					for (var w=0;w<aList.length;w++)
					{
						var test=aList [w];
						
						if (test.nodeName=="tool_selection")
							toolSelection=xmlParser.getNodeTextValue (test);
					}	
				}
			}						
		}
		*/
			
		if(!isLogMessage) 
		{
			this.debug ("!isLogMessage ...");
				
			/*
			selection = xmlObj.properties.Selection.value;
			action = xmlObj.properties.Action.value;
			input = xmlObj.properties.Input.value;
			prompt = xmlObj.properties.prompt;
				
			if (hasProperty("StudentSelection")) 
			{
				this.debug ("hasProperty(StudentSelection) ...");
				
				var studentSelection = xmlObj.properties.StudentSelection.value;
				var studentAction= xmlObj.properties.StudentAction.value;
				var studentInput = xmlObj.properties.StudentInput.value;
				studentSAI = new CTATSAI (studentSelection, studentAction, studentInput,prompt);
			}
			*/				
			
			var tList=xmlParser.getElementChildren (xmlObj);
			
			for (var t=0;t<tList.length;t++)
			{
				var entry=tList [t];
				
				if (xmlParser.getElementName (entry)=="properties")
				{
					var aList=xmlParser.getElementChildren (entry);
					
					for (var w=0;w<aList.length;w++)
					{
						var test=aList [w];
						
						this.debug ("Nodename: " + xmlParser.getElementName (test));
						
						if (xmlParser.getElementName (test)=="Selection")
						{
							selection=xmlParser.getNodeTextValue (test);
						}
						
						if (xmlParser.getElementName (test)=="Action")
						{
							action=xmlParser.getNodeTextValue (test);
						}
						
						if (xmlParser.getElementName (test)=="Input")
						{
							input=xmlParser.getNodeTextValue (test);
						}
						
						if (xmlParser.getElementName (test)=="prompt")
						{
							prompt=xmlParser.getNodeTextValue (test);
						}						
					}	
				}
			}								
		}
		else 
		{
			this.debug ("isLogMessage ...");
				
			/*
			selection = xmlObj.event_descriptor.selection;
			action = xmlObj.event_descriptor.action;
			input = xmlObj.event_descriptor.input;
			prompt = xmlObj.event_descriptor.prompt;
			*/

			var tList=xmlParser.getElementChildren (xmlObj);
			
			for (var t=0;t<tList.length;t++)
			{
				var entry=tList [t];
				
				if (xmlParser.getElementName (entry)=="event_descriptor")
				{
					var aList=xmlParser.getElementChildren (entry);
					
					for (var w=0;w<aList.length;w++)
					{
						var test=aList [w];
						
						if (xmlParser.getElementName (test)=="selection")
						{
							selection=xmlParser.getNodeTextValue (test);
						}
						
						if (xmlParser.getElementName (test)=="action")
						{
							action=xmlParser.getNodeTextValue (test);
						}
						
						if (xmlParser.getElementName (test)=="input")
						{
							input=xmlParser.getNodeTextValue (test);
						}
						
						if (xmlParser.getElementName (test)=="prompt")
						{
							prompt=xmlParser.getNodeTextValue (test);
						}						
					}	
				}
			}									
		}
			
		if ((selection != "") && (selection != null)) 
		{
			this.debug ("Creating new SAI object with ("+selection+","+action+","+input+","+prompt+"), activating new parsing ...");
			
			sai=new CTATSAI (selection,action,input,prompt);

			//sai=new CTATSAI ();
			//sai.fromXMLInternal (xmlObj.properties);
			
			/*
			var tList=xmlObj.childNodes;
			
			for (var t=0;t<tList.length;t++)
			{
				var entry=tList [t];
				
				if (entry.nodeName=="properties")
				{
					sai=new CTATSAI ();
					sai.fromXMLInternal (entry);	
				}
			}
			*/						
			
			hassai = true;
		}
		else
		{
			this.debug ("No SAI found");
			hassai = false;
		}
				
		this.debug ("parseSAI () done");
	};
		
	/**
	 * Depending on format TransactionID is located in different places.
	 */
	this.parseTransactionID=function parseTransactionID() 
	{
		this.debug ("parseTransactionID()");
			
		if (messageType=="tool_message")
		{				
			//transactionID = xmlObj.tool_message.semantic_event.@transaction_id;		
				
			this.debug ("Transaction ID: " + transactionID);
				
			return;
		}
			
		if (!isLogMessage)
		{				
			var tList=xmlParser.getElementChildren (xmlObj);
			
			for (var t=0;t<tList.length;t++)
			{
				var entry=tList [t];
				
				if (xmlParser.getElementName (entry)=="properties")
				{
					var aList=xmlParser.getElementChildren (entry);
					
					for (var w=0;w<aList.length;w++)
					{
						var test=aList [w];
						
						if (test.nodeName=="transaction_id")
							transactionID=xmlParser.getNodeTextValue (test);
					}	
				}
			}			
		}	
		else
		{	
			/*
			if (xmlObj.semantic_event != null)
			{
				//transactionID = xmlObj.semantic_event.@transaction_id;
			}
			*/			
		}	
	};
	
	/**
	 * 
	 */
	this.parseMessageType=function parseMessageType ()
	{
		this.debug ("parseMessageType()");
		
		var tList=xmlParser.getElementChildren (xmlObj);
		
		for (var t=0;t<tList.length;t++)
		{
			var entry=tList [t];
			
			if (xmlParser.getElementName (entry)=="properties")
			{
				var aList=xmlParser.getElementChildren (entry);
				
				for (var w=0;w<aList.length;w++)
				{
					var test=aList [w];
					
					if (xmlParser.getElementName (test)=="MessageType")
					{
						messageType=xmlParser.getNodeTextValue (test);
					}	
				}	
			}
		}
	};
		
	/**
	 * Returns the MessageType element of the message.
	 * <p>This is by far the most commonly used property of any CTATMessage as it governs determines the format of the message
	 * and provides what other fields can be expected to be available. A class will exist at some point that contains static
	 * variables for the possible values of this field.</p>
	 * @see CTATMessageType
	 * @return	The type of the CTATMessage.
	 */
	this.getMessageType=function getMessageType() 
	{
		return messageType;
	};
		
	/**
	 * Returns the Transaction ID of the message.
	 * <p>Most messages will have a Transaction ID, usually a 16 character GUID. A message sent to the Tutoring Service that has a
	 * transaction ID will recieve a response with an identical ID. The primary use of the ID is for this pairing but it can also 
	 * be used to uniquely identify messages.</p>
	 * @return	The transaction ID of the message.
	 */
	this.getTransactionID=function getTransactionID() 
	{
		return transactionID;
	};
		
	/**
	 * Returns the SAI of the message.
	 * <p>An SAI tripple is used to describe every action within CTAT. The SAI is the central important feature in most message types.
	 * Despite this, not all messages have an SAI element. For messages types that do not have an SAI, this method will return an
	 * SAI whose values are empty strings.</p>
	 * @return	The SAI of the message, or an empty SAI if the message doesn't have one.
	 */
	this.getSAI=function getSAI() 
	{
		return (hassai ? sai : new CTATSAI());
	};
		
	/**
	 * Returns the Selction value of the messages SAI if it has one.
	 * @return	The Selection String of the message's SAI, if it has one, empty String otherwise.
	 */
	this.getSelection=function getSelection() 
	{
		return (hassai ? sai.getSelection() : "");
	};
		
	/**
	 * Returns the Action value of the messages SAI if it has one.
	 * @return	The Action String of the message's SAI, if it has one, empty String otherwise.
	 */
	this.getAction=function getAction() 
	{
		return (hassai ? sai.getAction() : "");
	};
		
	/**
	 * Returns the Input value of the messages SAI if it has one.
	 * @return	The Input String of the message's SAI, if it has one, empty String otherwise.
	 */
	this.getInput=function getInput() 
	{
		return (hassai ? sai.getInput() : "");
	};
	
	/**
	 * Returns the internal <code>XML</code> object used to represent the message.
	 * <p>If you are need a message field that has no simple accessor, i.e. it is further nested <code>XML</code> that cannot be 
	 * reached through the <code>getProperty()</code> method, or the message is a log message, you can access any field
	 * not otherwise provided for by retrieveing the <code>XML</code> object, which the CTATMessage uses internally to store
	 * message content. This will require prior knowledge of the message's xml formatting, which is provided to the best of our
	 * ability in the CTATMessageType class documentation.</p>
	 * @see getProperty()
	 * @return	The internal XML object used to store the message.
	 */
	this.getXML=function getXML() 
	{
		return xmlObj;
	};
		
	/**
	 * Returns the XMLString representation of the message.
	 * <p>The XMLString of the message is equivalent to the String that was passed over the XML socket to or from the tutoring
	 * service. There is an option for whether the string should be pretty printed or not. This setting is behaviourally
	 * equivalent to XML.prettyPrinting</p>
	 * @param	prettyPrinting A boolean for whether you want the string returned to be pretty printed or not.
	 * @return	The XMLString representation of the message.
	 */
	this.getXMLString=function getXMLString(pretty) 
	{
        if (xml_node.xml)
            return xml_node.xml;
        else if (XMLSerializer)
        {
            var xml_serializer = new XMLSerializer();
            return xml_serializer.serializeToString(xml_node);
        }
        else
        {
            alert("ERROR: Extremely old browser");
            return "";
        }
	};
		
	/**
	 * Returns the Indicator field of an AssociatedRules Message.
	 * <p>AssociatedRules messages are a common response message type, which carry an extra Indicator field to function like a
	 * MessageSubType. Due to their commodity a direct accessor to this field was implemented. If the message is not an AssociatedRules
	 * type this method will return an empty String.</p>
	 * <p><b>NOTE:</b> It is currently planned for the AssociatedRules message type to become a central response message type. This field
	 * would then absorb the functionality of the current <code>CORRECT</code>, <code>INCORRECT</code>, <code>HIGHLIGHT</code>, 
	 * <code>UNHIGHLIGHT</code>, and <code>SHOW_HINTS</code> message types.</p>
	 * @return The Indicator type of an <code>ASSOCIATED_RULES</code> message, if the message is not <code>ASSOCIATED_RULES</code>, empty string.
	 */
	this.getIndicator=function getIndicator() 
	{
		if (messageType != "AssociatedRules")
			return "";
		else
			return xmlObj.properties.Indicator;
	}
		
	/**
	 * 
	 */
	this.getIndicatorSub=function getIndicatorSub () 
	{
		if (messageType != "AssociatedRules")
			return "";
		else
		{
			if (hasProperty ("IndicatorSub")==true)
				return xmlObj.properties.IndicatorSub;
		}
			
		return "";
	};

	/**
	 *
	 */
	this.setProperty=function setProperty(property,value)
	{
		xmlObj.properties [property]=value;
	};
		
	/**
	 * Returns a given property of a Tutoring Service message.
	 * <p>All messages between the interface the and Tutoring Service contain a list of properties. The accessor methods 
	 * provided in this class are for the most commonly used properties, however, if a message contains a property that is not included 
	 * explicitly it can be accessed here.</p>
	 * <p><b>NOTE:</b> This method is only valid for Tutoring Service messages, if called on a log message it will return an empty string.
	 * If you need to access a field of a log message that is not included use the <code>getXML()</code> method instead</p>
	 * @see		getXML()
	 * @param	property	The name of a property, case-sensative.
	 * @return	The value of the given property.
	 */
	this.getProperty=function getProperty(property) 
	{
		//xmlObj.properties
		if (isLogMessage || !hasProperty(property))
			return "";
		else
			return xmlObj.properties[property];
	};

	/**
	 * Returns whether or not the CTATMessage contains a given property.
	 * <p>Subject to the same message type contraints in getProperty. Checks whether or not the message containts a given property.
	 * If called on a logMessage it will always return <code>false</code>.</p>
	 * <p><b>NOTE:</b> Calling <code>message.hasProperty("SAI")</code> will always return <code>false</code> because messages
	 * never contain a field explicitly named "SAI"</p>
	 * @see 	hasSAI()
	 * @param	property	The name of a property, case-sensative.
	 * @return	<code>true</code> if the message contains the property, <code>false</code> otherwise.
	 */
	this.hasProperty=function hasProperty(property) 
	{
		return (!isLogMessage && xmlObj.properties[property] != null && xmlObj.properties[property] != null);
	};
		
	/**
	 * Returns whether or not the CTATMessage contains an SAI element.
	 * <p>Because not all messages necessarily contain SAI elements this method is provided to check for their presence.</p>
	 * @return	<code>true</code> if the message contains an SAI, <code>false</code> otherwise.
	 */
	this.hasSAI=function hasSAI() 
	{
		return hassai;
	};
		
	/**
	 * Returns whether or not the current message is the end of a two way transaction.
	 * <p>Messages sent to the tutoring service are paired with their response messages. It is also possible that
	 * more than one response is sent for every message. In such a case it can be necessary to check if a particular message
	 * is at the end of a transaction.</p>
	 * @return	<code>true</code> if the message is the end of a transaction, <code>false</code> otherwise.
	 */
	this.isEndOfTransaction=function isEndOfTransaction() 
	{
		return hasProperty("end_of_transaction") && xmlObj.properties.end_of_transaction == "true";
	};

	/**
	 * Returns whether or not the message is in the logging format.
	 * @return <code>true</code> if the message is a log message, <code>false</code> otherwise.
	 */
	this.isLogMessageType=function isLogMessageType() 
	{
		return isLogMessage;
	};

	/**
	 * Returns whether or not the message has student SAI fields.
	 * @return <code>true</code> if the message has a student SAI, <code>false</code> otherwise.
	 */
	this.hasStudentSAI=function hasStudentSAI() 
	{
		return studentSAI != null;
	};

	/**
	 * Returns the selection of the student SAI.
	 * @return
	 */
	this.getStudentSelection=function getStudentSelection() 
	{
		return studentSAI.getSelection();
	};
		
	/**
	 * Returns the action of the student SAI.
	 * @return
	 */
	this.getStudentAction=function getStudentAction() 
	{
		return studentSAI.getAction();
	};
		
	/**
	 * Returns the input of the student SAI
	 * @return
	 */
	this.getStudentInput=function getStudentInput() 
	{
		return studentSAI.getInput();
	};
		
	/**
	 * Returns the full student SAI.
	 * @return
	 */
	this.getStudentSAI=function getStudentSAI() 
	{
		return studentSAI;
	};
		
	/**
	 * 
	 */
	this.getToolSelection=function getToolSelection()
	{
		return toolSelection;
	};		
	
	// Let's fix a transaction id if one doesn't exist
	
	var generator=new CTATGuid ();
	
	transactionID=generator.guid();
	
	// Now, on with the parsing!!
	
	this.parse ();
}

CTATMessage.prototype = Object.create(CTATBase.prototype);
CTATMessage.prototype.constructor = CTATMessage;
/**------------------------------------------------------------------------------------
 $Author$ 
 $Date$ 
 $Header$ 
 $Name$ 
 $Locker$ 
 $Log$
 
 -
 License:
 -
 ChangeLog:
 -
 Notes:
 
*/

/**
 *  http://api.jquery.com/jQuery.parseXML/
 */
function CTATMessageHandler ()
{
	CTATBase.call(this, "CTATMessageHandler", "messagehandler");

	var messageHandler=null;
	var pointer = this;
	
	var startStateMessages=new Array ();
	var inStartState=false;

	var xmlParser=new CTATXML ();
	
	/**
	 * 
	 */
	this.assignHandler=function assignHandler (aHandler)
	{
		pointer.debug ("assignHandler ()");
	
		messageHandler=aHandler;
	};
	/**
	 * 
	 */
	this.getInStartState=function getInStartState ()
	{
		return (inStartState);
	};
	/**
	 * http://api.jquery.com/category/traversing/
	 * http://www.w3schools.com/dom/dom_nodes_traverse.asp
	 */
	this.processMessage=function processMessage (aMessage)
	{	
		pointer.debug ("processMessage ("+lastMessage+")");
				
		var xmlDoc=null;
								
		/*
		if (lastMessage===true)
		{
			commShell.nextProblem (aMessage);
		}
		*/
				
		//var begin=getTimeStamp ();
		
		pointer.debug ("Attempting parse ...");

		xmlDoc=xmlParser.parseXML (aMessage);

		if (xmlDoc==null)
		{
			pointer.debug ("Error parsing xml");
			return;
		}		
		
		//var end=getTimeStamp ();
				
		//pointer.debug ("XML Parsing took: " + (end-begin) + " milliseconds");
		
		//begin=getTimeStamp ();
		
		if (xmlDoc===null)
		{
			pointer.debug ("Aborted XML parsing");
			return;
		}
		
		this.parseElement (xmlDoc);
		
		//end=getTimeStamp ();
		
		//pointer.debug ("Start state processing took: " + (end-begin) + " milliseconds");
	};
	/**
	 * 
	 */
	this.parseElement=function parseElement (anElement)
	{
		pointer.debug ("parseElement ("+xmlParser.getElementName (anElement)+")");
		
		if ((xmlParser.getElementName (anElement)=="CTATResponseMessages") || (xmlParser.getElementName (anElement)=="StartStateMessages") || (xmlParser.getElementName (anElement)=="MessageBundle"))
			this.processMessageBundle (anElement);
		
		if (xmlParser.getElementName (anElement)=="message")
			this.processSingleMessage (anElement);
	};
	/**
	 * 
	 */
	this.processMessageBundle=function processMessageBundle (anElement)
	{
		pointer.debug ("processMessageBundle ("+xmlParser.getElementName (anElement)+")");
	
		//x=anElement.childNodes;
		x=xmlParser.getElementChildren (anElement);
		
		for (var i=0;i<x.length;i++)
		{
			this.parseElement (x [i]);
		}		
	};
	/**
	 * 
	 */
	 
	 var count=0;
	 
	this.processSingleMessage=function processSingleMessage (anElement)
	{
		pointer.debug ("processSingleMessage ("+xmlParser.getElementName (anElement)+")");
		
		var aMessage=new CTATMessage (anElement);
				
		var x=xmlParser.getElementChildren (anElement);
		
		pointer.debug ("Generated CTATMessage, now doing regular processing ...");
		
		for (var i=0;i<x.length;i++)
		{
			var tempElement=x [i];
			
			if (xmlParser.getElementName (tempElement)=='properties')
			{
				pointer.debug ("Parsing properties ...");
				
				var messageProperties=xmlParser.getElementChildren (tempElement);
				
				for (var t=0;t<messageProperties.length;t++)
				{
					var propNode=messageProperties [t];
															
					if (xmlParser.getElementName (propNode)=="MessageType")
					{
						var nodeValue=xmlParser.getNodeTextValue (propNode);
						
						pointer.debug ("MessageType: " + nodeValue);
						
						if (nodeValue=="StateGraph")
						{	
							//useDebugging=true;
							
							this.processStateGraph (tempElement);
							
							//useDebugging=false;
						}
					
						if (nodeValue=="StartProblem")
						{
							inStartState=true;
							
							this.processStartProblem (messageProperties);
						}	
					
						if (nodeValue=="InterfaceIdentification")
						{
							this.processInterfaceIdentification (messageProperties);
						}	
					
						if (nodeValue=="InterfaceDescription")
							this.processInterfaceDescription (messageProperties);			
					
						if (nodeValue=="SendWidgetLock")
						{
							pointer.debug ("Found: SendWidgetLock");
							
						}	
					
						if (nodeValue=="StartStateEnd")
						{
							pointer.debug ("Found: StartStateEnd");
							
							this.displayComponentList ();
							
							if (messageHandler!=null)
							{
								messageHandler.processStartState ();
							}	

							this.processStartStateActions ();
							
							inStartState=false;
							
							//removeScrim ();
						}
						
						
						if (nodeValue=="CorrectAction")
						{
							pointer.debug ("Found: CorrectAction");

							messageHandler.processCorrectAction (aMessage);
						}
						
						if (nodeValue=="InCorrectAction")
						{
							pointer.debug ("Found: InCorrectAction");

							messageHandler.processInCorrectAction (aMessage);
						}
						
						if (nodeValue=="HighlightMsg")
						{
							pointer.debug ("Found: HighlightMsg");

							messageHandler.processHighlightMsg (aMessage);
						}
						
						if (nodeValue=="UnHighlightMsg")
						{
							pointer.debug ("Found: UnHighlightMsg");
							
							messageHandler.processUnHighlightMsg (aMessage);
						}
						
						if (nodeValue=="AssociatedRules")
						{
							pointer.debug ("Found: AssociatedRules ("+messageProperties.length+")");		
							
							var advice="";
							var actor="";
							var indicator="";
							var stepID="";
							var logAsResult="";
							var toolSelection="";
							
							for (var k=0;k<messageProperties.length;k++)
							{
								var testNode=messageProperties [k];
								
								//pointer.debug ("testNode:" + testNode.nodeName);
								
								if (xmlParser.getElementName (testNode)=="TutorAdvice")
								{
									advice=xmlParser.getNodeTextValue (testNode);
								}
								
								if (xmlParser.getElementName (testNode)=="Actor")
								{
									actor=xmlParser.getNodeTextValue (testNode);
								}
								
								if (xmlParser.getElementName (testNode)=="Indicator")
								{
									indicator=xmlParser.getNodeTextValue (testNode);
								}
																
								if (xmlParser.getElementName (testNode)=="StepID")
								{
									stepID=xmlParser.getNodeTextValue (testNode);
								}
								
								if (xmlParser.getElementName (testNode)=="LogAsResult")
								{
									logAsResult=xmlParser.getNodeTextValue (testNode);
								}
								
								if (xmlParser.getElementName (testNode)=="tool_selection")
								{
									toolSelection=xmlParser.getNodeTextValue (testNode);
								}
								
								if (xmlParser.getElementName (testNode)=="Skills")
								{
									pointer.debug ("Processing skills ...");
									
									if (skillSet==null)
									{	
										pointer.debug ("Interesting, there isn't a skillSet object yet. Creating ...");
										skillSet=new CTATSkillSet ();
									}

									skillSet.parseByValue(testNode);									 
								}								
							}
							
							messageHandler.processAssociatedRules (aMessage,indicator,advice);
						}
						
						if (nodeValue=="BuggyMessage")
						{
							pointer.debug ("Found: BuggyMessage");
							
							messageHandler.processBuggyMessage (aMessage);
						}
						
						if (nodeValue=="SuccessMessage")
						{
							pointer.debug ("Found: SuccessMessage");
							
							messageHandler.processSuccessMessage (aMessage);
						}
						
						if (nodeValue=="InterfaceAction")
						{
							pointer.debug ("Found: InterfaceAction");
							
							if (inStartState==true)
							{
								startStateMessages.push (aMessage);
							}
							else
							{
								messageHandler.processInterfaceAction (aMessage);
							}
						}
						
						if (nodeValue=="InterfaceIdentification")
						{
							pointer.debug ("Found: InterfaceIdentification");							
							
							//messageHandler.processInterfaceIdentification (aMessage);
						}
						
						if (nodeValue=="AuthorModeChange")
						{
							pointer.debug ("Found: AuthorModeChange");
							
							//messageHandler.processAuthorModeChange (aMessage);
							
							messageHandler.globalReset ();							
						}
						
						if (nodeValue=="ResetAction")
						{
							pointer.debug ("Found: ResetAction");
							
							// For now not implemented
							
							messageHandler.globalReset ();
						}
												
						if (nodeValue=="ShowHintsMessage")
						{
							pointer.debug ("Found: ShowHintsMessage");
							
							var hintComplete=false;
							var hintArray=new Array ();
							
							// Extract all the hints from XML and store them in a temporary list
							
							for (var k=0;k<messageProperties.length;k++)
							{
								var propNode=messageProperties [k];
								
								if (xmlParser.getElementName (propNode)=="HintsMessage")
								{
									var aList=xmlParser.getElementChildren (propNode);
									
									for (var w=0;w<aList.length;w++)
									{
										var hintNode=aList [w];
										
										if (xmlParser.getElementName (hintNode)=="value")
										{
											hintArray.push (xmlParser.getNodeTextValue (hintNode));
										
											hintComplete=true;
										}	
									}	
								}
							}	
							
							// Call the commshell to handle the message together with the list of hints
							
							if (hintComplete==true)
							{
								messageHandler.processHintResponse (aMessage,hintArray);
							}
							else
								pointer.debug ("Error: incomplete hint message received");
							
							// All done
						}
						
						if (nodeValue=="ConfirmDone")
						{
							pointer.debug ("Found: ConfirmDone");
							
							messageHandler.processConfirmDone (aMessage);
						}
						
						if (nodeValue=="VersionInfo")
						{
							pointer.debug ("Found: VersionInfo");
							
							messageHandler.processVersionInfo (messageProperties);
						}
						
						if (nodeValue=="TutoringServiceAlert")
						{
							pointer.debug ("Found: TutoringServiceAlert");
							
							messageHandler.processTutoringServiceAlert (messageProperties);
						}
						
						if (nodeValue=="TutoringServiceError")
						{
							pointer.debug ("Found: TutoringServiceError");
																					
							messageHandler.processTutoringServiceError (messageProperties);
						}
						
						if (nodeValue=="ProblemSummaryResponse")
						{
							pointer.debug ("Found: ProblemSummaryResponse");
							
							messageHandler.processProblemSummaryResponse (aMessage);
						}
						
						if (nodeValue=="ProblemRestoreEnd")
						{
							pointer.debug ("Found: ProblemRestoreEnd");
							
							messageHandler.processProblemRestoreEnd (aMessage);
						}
					}	
				}
			}
		}				
	};
	/**
	 * <message>
	 * <verb>SendNoteProperty</verb>
	 * <properties>
	 *     <MessageType>StateGraph</MessageType>
	 *     <caseInsensitive>true</caseInsensitive>
	 *     <unordered>true</unordered>
	 *     <lockWidget>true</lockWidget>
	 *     <suppressStudentFeedback>false</suppressStudentFeedback>
	 *     <highlightRightSelection>true</highlightRightSelection>
	 *     <confirmDone>false</confirmDone>
	 *     <Skills>
	 *       <value>right right=0.3=0=Right Branch</value>
	 *     </Skills>
	 *   </properties>
	 * </message>
	 */
	this.processStateGraph=function processStateGraph (aPropertyList)
	{
		pointer.debug ("processStateGraph ()");
		
		if ((aPropertyList==undefined) || (aPropertyList==null))
		{
			pointer.debug ("Error: state graph property list is undefined");
			return;
		}
		
		pointer.debug ("Processing node: " + aPropertyList.nodeName);
				
		if (xmlParser.getElementChildren (aPropertyList)==null)
		{
			pointer.debug ("Error: state graph property list is undefined");
			return;
		}		
				
		var messageProperties=xmlParser.getElementChildren (aPropertyList);
		
		for (var t=0;t<messageProperties.length;t++)
		{
			var propNode=messageProperties [t];
									
			pointer.debug ("State graph attribute: " + xmlParser.getElementName (propNode));
			
			if (xmlParser.getElementName (propNode)=="caseInsensitive")
			{
				if (xmlParser.getNodeTextValue (propNode)=='false')
					caseInsensitive=false;
				else
					caseInsensitive=true;
			}
			
			if (xmlParser.getElementName (propNode)=="unordered")
			{
				if (xmlParser.getNodeTextValue (propNode)=='false')
					unordered=false;
				else
					unordered=true;				
			}
			
			if (xmlParser.getElementName (propNode)=="lockWidget")
			{
				if (xmlParser.getNodeTextValue (propNode)=='false')
					lockWidget=false;
				else
					lockWidget=true;				
			}
			
			if (xmlParser.getElementName (propNode)=="suppressStudentFeedback")
			{
				if (xmlParser.getNodeTextValue (propNode)=='false')
					suppressStudentFeedback=false;
				else
					suppressStudentFeedback=true;				
			}
			
			if (xmlParser.getElementName (propNode)=="highlightRightSelection")
			{
				if (xmlParser.getNodeTextValue (propNode)=='false')
					highlightRightSelection=false;
				else
					highlightRightSelection=true;				
			}
			
			if (xmlParser.getElementName (propNode)=="confirmDone")
			{
				pointer.debug ("Confirm done: " + xmlParser.getNodeTextValue (propNode));
				
				if (xmlParser.getNodeTextValue (propNode)=='false')
					confirmDone=false;
				else
					confirmDone=true;				
			}
		    
			if (xmlParser.getElementName (propNode)=="Skills")
			{
				pointer.debug ("Processing skills ...");
				
				if (skillSet==null)
					skillSet=new CTATSkillSet ();

				skillSet.parseByValue(propNode);
				
				messageHandler.updateSkillWindow ();
			}
		}
	};
	/**
	 * 
	 */
	this.processStartProblem=function processStartProblem (aPropertyList)
	{
		//pointer.debug ("processStartProblem ()");
		
	};
	/**
	 * 
	 */
	this.processInterfaceIdentification=function processInterfaceIdentification (aPropertyList)
	{
		//pointer.debug ("processInterfaceIdentification ()");
		
	};
	/**
	 * 
	 */
	this.processInterfaceDescription=function processInterfaceDescription (aPropertyList)
	{
		pointer.debug ("processInterfaceDescription ("+aPropertyList.length+")");
				
		var aType="Unknown";
		var aName="Unknown";
				
		for (var i=0;i<aPropertyList.length;i++)
		{
			var tempElement=aPropertyList [i];
						
			if (xmlParser.getElementName (tempElement)=="WidgetType")
			{
				pointer.debug ("Widget type: " + xmlParser.getNodeTextValue (tempElement));
				
				aType=xmlParser.getNodeTextValue (tempElement);
			}
			
			if (xmlParser.getElementName (tempElement)=="CommName")
			{
				pointer.debug ("Instance name: " + xmlParser.getNodeTextValue (tempElement));
				
				aName=xmlParser.getNodeTextValue (tempElement);
			}
			
			if (xmlParser.getElementName (tempElement)=="serialized")
			{
				pointer.debug ("De-serializing component ...");
				
				this.deserializeComponent (aType,aName,tempElement.childNodes[0]);
			}
			
			if (xmlParser.getElementName (tempElement)=="interface")
			{
				pointer.debug ("Storing interface for post start-state reconstruction ...");
				
				interfaceElement=tempElement;
			}
			
			if (xmlParser.getElementName (tempElement)=="script")
			{
				pointer.debug ("Storing and loading main javascript code as defined by the BRD ...");
				
				scriptElement=xmlParser.getNodeTextValue (tempElement);
			}			
		}	
	};
	/**
	 *
	 */
	this.deserializeComponent=function deserializeComponent (aType,aName,aComponentElement)
	{
		pointer.debug ("deserializeComponent ("+aType+","+aName+")");
		
		// quick test to see if we have new style components 
		
		if (aComponentElement.attributes.getNamedItem("x")==null)
		{
			pointer.debug ("Warning: this component does not have x,y information. Probably an older component");
			return;
		}
		
		var x=aComponentElement.attributes.getNamedItem("x").value;
		var y=aComponentElement.attributes.getNamedItem("y").value;
		var width=aComponentElement.attributes.getNamedItem("width").value;
		var height=aComponentElement.attributes.getNamedItem("height").value;
		
		//debug ("x: " + x + ", y: " + y + ", width: " + width + ", height: " + height);
		
		var compEntry=new CTATComponentDescription ();
		compEntry.type=aType;
		compEntry.name=aName;
		compEntry.x=Math.floor (x);
		compEntry.y=Math.floor (y);
		compEntry.width=Math.floor (width);
		compEntry.height=Math.floor (height);
		
		components.push (compEntry);
		
		var serializedProps=aComponentElement.childNodes;
		
		for (var i=0;i<serializedProps.length;i++)
		{
			var tempElement=serializedProps [i];
			
			if (tempElement.nodeName=="Parameters")
			{
				this.debug ("Processing component parameters ...");
				
				var paramProps=tempElement.childNodes [0].childNodes;
				
				for (var t=0;t<paramProps.length;t++)
				{
					var paramProperty=paramProps [t];
				
					if (paramProperty.nodeName=="CTATComponentParameter")
					{
						this.debug ("Processing parameter property ...");
						
						var aParam=new CTATParameter();
						
						var paramValues=paramProperty.childNodes;
						
						for (var j=0;j<paramValues.length;j++)
						{
							var paramElement=paramValues [j];
							
							if (paramElement.nodeName=="name")
							{
								this.debug ("Found parameter name: " + xmlParser.getNodeTextValue (paramElement));
								aParam.paramName=xmlParser.getNodeTextValue (paramElement);								
							}
							
							if (paramElement.nodeName=="value")
							{	
								this.debug ("Found parameter value: " + xmlParser.getNodeTextValue (paramElement));

								aParam.paramValue=xmlParser.getNodeTextValue (paramElement);
								
								if(aParam.paramName=="group")
								{
									compEntry.groupName=aParam.paramValue;
								}
							}	
						}
							
						this.debug ("Parameter name: " + aParam.paramName + ", value: " + aParam.paramValue);
						compEntry.params.push(aParam);
					}
				}
			}
			
			if (tempElement.nodeName=="Styles")
			{
				this.debug ("Processing component styles ...");
				
				var stylesProps=tempElement.childNodes [0].childNodes;
				
				for (var t=0;t<stylesProps.length;t++)
				{
					var styleProperty=stylesProps [t];
					
					if (styleProperty.nodeName=="CTATStyleProperty")
					{
						this.debug ("Processing style property ...");
						
						//alert(xml_to_string(styleProperty));
						
						var aStyle=new CTATStyle ();
						
						var styleValues=styleProperty.childNodes;
						
						for (var j=0;j<styleValues.length;j++)
						{
							var styleElement=styleValues [j];
							
							//alert(xml_to_string(styleElement));
							
							if (styleElement.nodeName=="name")
							{
								this.debug ("Found style name: " + xmlParser.getNodeTextValue (styleElement));
								aStyle.styleName=xmlParser.getNodeTextValue (styleElement);								
							}
							
							if (styleElement.nodeName=="value")
							{	
								this.debug ("Found style value: " + xmlParser.getNodeTextValue (styleElement));
								
								if((aStyle.styleName != "DisplayHTMLText") || (aStyle.styleName != "ProcessHTMLInHints"))
								{
									aStyle.styleValue=xmlParser.getNodeTextValue (styleElement);
								}								
								else
								{
									var encoder=new CTATHTMLManager();
									aStyle.styleValue=encoder.htmlEncode(styleElement);
								}
							}	
						}
							
						this.debug ("Style name: " + aStyle.styleName + ", value: " + aStyle.styleValue);
						
						compEntry.styles.push(aStyle);				
					}
				}	
			}			
		}			
	};
	/**
	 * 
	 */
	this.displayComponentList=function displayComponentList ()
	{
		pointer.debug ("displayComponentList ("+components.length+")");
		
		for (var i=0;i<components.length;i++)
		{
			var aDesc=components [i];
			
			pointer.debug ("Component (Desc): " + aDesc.name + ", type: " + aDesc.type+", x: " + aDesc.x + ", y: " + aDesc.y + ", width: " + aDesc.width + ", height: " + aDesc.height);
			
			var component=aDesc.getComponentPointer ();
			
			if (component!=null)
			{
				pointer.debug ("Component (Pointer): " + component.name + ", type: " + component.type+", x: " + component.x + ", y: " + component.y + ", width: " + component.width + ", height: " + component.height);
			}	
		}
	};
	/**
	 * 
	 * @param xml_node
	 * @returns
	 */
    function xml_to_string(xml_node)
    {
        if (xml_node.xml)
            return xml_node.xml;
        else if (XMLSerializer)
        {
            var xml_serializer = new XMLSerializer();
            return xml_serializer.serializeToString(xml_node);
        }
        else
        {
            alert("ERROR: Extremely old browser");
            return "";
        }
    }	
    /**
     * 
     */
    this.processStartStateActions=function processStartStateActions ()
    {    	
    	pointer.debug ("processStartStateActions ()");
    	
		for (var i=0;i<startStateMessages.length;i++)
		{
			var aMessage=startStateMessages [i];
			messageHandler.processInterfaceAction (aMessage);						
		}	    	
				
		if (scriptElement!="")
		{
			try
			{
				eval (scriptElement);
			}
			catch (err)
			{
				alert ("Error executing script from BRD: " + err.message);
			}
		}		
    };
}

CTATMessageHandler.prototype = Object.create(CTATBase.prototype);
CTATMessageHandler.prototype.constructor = CTATMessageHandler;
/**------------------------------------------------------------------------------------
 $Author$ 
 $Date$ 
 $Header$ 
 $Name$ 
 $Locker$ 
 $Log$
 
 -
 License:
 -
 ChangeLog:
 -
 Notes:
 
*/

/**
 *  
 */
function CTATTutoringServiceMessageBuilder ()
{
	CTATBase.call(this, "CTATTutoringServiceMessageBuilder", "__undefined__");

	var xmlHeader='<?xml version="1.0" encoding="UTF-8"?>';	

	/**
	*
	*/		
	this.createStartProblemMessage=function createStartProblemMessage(problemName) 
	{
		this.debug ("createStartProblemMessage ()");
		
		return (xmlHeader+"<message><verb>NotePropertySet</verb><properties><MessageType>StartProblem</MessageType><ProblemName>" + problemName + "</ProblemName></properties></message>");
	};
	
	/**
	 * 
	 */
	this.createInterfaceIdentificationMessage=function createInterfaceIdentificationMessage (anID)
	{
		this.debug ("createInterfaceIdentificationMessage ("+anID+")");
		
		return (xmlHeader+"<message><verb>NotePropertySet</verb><properties><MessageType>InterfaceIdentification</MessageType><Guid>" + anID + "</Guid></properties></message>");
	};
	
	/**
	*
	*/		
	this.createInterfaceDescriptionMessage=function createInterfaceDescriptionMessage(components,tWidth,tHeight) 
	{
		this.debug ("createInterfaceDescriptionMessage ()");
		
		var message = "<message><verb>NotePropertySet</verb><properties><MessageType>MessageBundle</MessageType><messages>";
		
		// First we add the commshell which for the start state represents the tutor itself

		message += "<message><verb>NotePropertySet</verb><properties><MessageType>InterfaceDescription</MessageType>";
		message += "<WidgetType>CTATCommShell</WidgetType>";
		message += "<CommName>theShell</CommName>";
		message += "<UpdateEachCycle>false</UpdateEachCycle>";
		message += '<jessDeftemplates><value>(deftemplate CTATCommShell (slot_name))</value></jessDeftemplates>';
		message += '<jessInstances><value>(assert (CTATCommShell (name CTATCommShell) (value "" )))</value></jessInstances>';
		message	+= '<serialized>';			
		message +=("<CTATCommShell name=\"theShell\" x=\"0\" y=\"0\" width=\""+tWidth+"\" height=\""+tHeight+"\"></CTATCommShell>");						
		message += '</serialized>';
		message += "</properties></message>";			
		
		// Since we don't do authoring from within HMTM5 we don't have
		// to send all the component interface descriptions
		
		/*
		for each(var comp:CTATComponentInterface in components) 
		{
			message += createComponentDescriptionMessage(comp);
		}
		*/
		
		message += "</messages></properties></message>";
					
		return (xmlHeader+message);
	};	
	
	/**
	 * There will probably need to be more fields in this method. Builds a SetPreferences message to be sent to the tutoring service.
	 * @param	versionNum	The current CommShell version number, which should be available at CommShell.version
	 * @param	context		The CTATContextData object for the session.
	 * @param	skills		The CTATSkillSet of the current session.
	 * @param	logURL		The logServiceURL being used by CTAT
	 * @param	logMethod	The Logging method of the session, which should be available at CommShell.Logging
	 * @return	A properly formated SetPreferences message to be sent to the tutoring service.
	 */
	this.createSetPreferencesMessage=function createSetPreferencesMessage (versionNum)
	{
		this.debug ("createSetPreferencesMessage ()");
			
		var vars=flashVars.getRawFlashVars ();
			
		var message = "<message><verb>NotePropertySet</verb><properties><MessageType>SetPreferences</MessageType>";
			
		message += "<log_service_url>" + vars ["log_service_url"] + "</log_service_url>";
			
		var logRemote = false;
		var logDisk = false;
			
		var logMethod=vars ["Logging"];
			
		switch (logMethod) 
		{
			case "ServiceToLogServer" :
												logRemote = true;
												break;
			case "ServiceToDisk" :
												logDisk = true;
												break;
			case "ServiceToDiskAndLogServer" :
												logRemote = true;
												logDisk = true;
												break;
			default :
												break;
		}
								
		message += "<log_to_remote_server>" + logRemote + "</log_to_remote_server><log_to_disk>" + logDisk + "</log_to_disk>";
			
		message += "<log_to_disk_directory>" + vars ["log_to_disk_directory"] + "</log_to_disk_directory>";
				
		message += "<user_guid>" + vars ["user_guid"] + "</user_guid>";	
		
		message += "<problem_name>" + vars ["problem_name"] + "</problem_name>";	
		
		message += "<question_file>" + vars ["question_file"] + "</question_file>";
		
		message += "<class_name>" + vars ["class_name"] + "</class_name>";
		
		message += "<school_name>" + vars ["school_name"] + "</school_name>";
		
		message += "<instructor_name>" + vars ["instructor_name"] + "</instructor_name>";
		
		message += "<session_id>" + vars ["session_id"] + "</session_id>";
																			
		message += "<source_id>" + vars ["source_id"] + "</source_id>";
		
		message += "<sui><![CDATA[" + vars ["sui"] + "]]></sui>";		
				
		message += "<problem_state_status>" + vars ["problem_state_status"] + "</problem_state_status>";		
									
		/*
		if (context.hasDatasetName()) 
		{
			message += "<dataset_name>" + context.DatasetName + "</dataset_name>";
			var dataSetLevelNames:Vector.<String> = context.DatasetLevelNames;
			var dataSetLevelTypes:Vector.<String> = context.DatasetLevelTypes;
				
			for (var i:int = 0; i < dataSetLevelNames.length; i++) 
			{
				message += "<dataset_level_name" + (i + 1) + ">" + dataSetLevelNames[i] + "</dataset_level_name" + (i + 1) + ">";
				message += "<dataset_level_type" + (i + 1) + ">" + dataSetLevelTypes[i] + "</dataset_level_type" + (i + 1) + ">";
			}
		}
		*/
		
		/*	
		if (context.hasConditions()) 
		{				
			var dataConditionNames:Vector.<String> = context.conditionNames;
			var dataConditionTypes:Vector.<String> = context.conditionTypes;
				
			for (var j:int = 0; j < dataConditionNames.length; j++) 
			{
				message += "<study_condition_name" + (j + 1) + ">" + dataConditionNames[j] + "</study_condition_name" + (j + 1) + ">";
				message += "<study_condition_type" + (j + 1) + ">" + dataConditionTypes[j] + "</study_condition_type" + (j + 1) + ">";
			}
		}
		*/
									
		if (skillSet!=null)
		{
			message+=skillSet.toSetPreferencesXMLString ();
		}	
				
		message += "<CommShellVersion>" + versionNum + "</CommShellVersion>";
		message += "</properties></message>";
		
		return xmlHeader+message;
	};
	
	/**
	*
	*/		
	this.createInterfaceActionMessage=function createInterfaceActionMessage(transactionID,sai) 
	{
		this.debug ("createInterfaceActionMessage ()");
		
		var message = "<message><verb>NotePropertySet</verb><properties><MessageType>InterfaceAction</MessageType>";
		
		message += "<transaction_id>" + transactionID + "</transaction_id>";
		message += sai.toXMLString(false);
		message += "</properties></message>";
		
		return (xmlHeader+message);
	};
	
	/**
	*
	*/		
	this.createUntutoredActionMessage=function createUntutoredActionMessage(transactionID,sai) 
	{
		this.debug ("createUntutoredActionMessage ()");
		
		var message = "<message><verb>NotePropertySet</verb><properties><MessageType>UntutoredAction</MessageType>";
		
		message += "<transaction_id>" + transactionID + "</transaction_id>";
		message += sai.toXMLString(false);
		message += "</properties></message>";
		
		return (xmlHeader+message);
	};	
	
	/**
	*
	*/		
	this.createProblemSummaryRequestMessage=function createProblemSummaryRequestMessage() 
	{
		var message = "<message><verb>NotePropertySet</verb><properties><MessageType>ProblemSummaryRequest</MessageType></properties></message>";
		
		return (xmlHeader + message);
	};
	
	/**
	*
	*/		
	this.createProblemRestoreEndMessage=function createProblemRestoreEndMessage()
	{
		var message = "<message><verb>NotePropertySet</verb><properties><MessageType>ProblemRestoreEnd</MessageType></properties></message>";
	
		return (xmlHeader + message);
	};	
}

CTATTutoringServiceMessageBuilder.prototype = Object.create(CTATBase.prototype);
CTATTutoringServiceMessageBuilder.prototype.constructor = CTATTutoringServiceMessageBuilder;
/**------------------------------------------------------------------------------------
 $Author$ 
 $Date$ 
 $Header$ 
 $Name$ 
 $Locker$ 
 $Log$
 
 -
 License:
 -
 ChangeLog:
 -
 Notes:
 
*/

/**
 * 
 */
function CTATBase(aClassName, aName) 
{
	var className=aClassName;
	var name=aName;
	var pointer=this;

	this.getClassName=function getClassName ()
	{
		return (className);
	};
	
	this.setClassName=function setClassName(aClass)
	{
		className=aClass;
	};

	this.setName=function setName (aName)
	{
		name=aName;		
	};
	
	this.getName=function getName ()
	{
		return (name);
	};
	
	this.getUseDebugging=function getUseDebugging()
	{
		return (useDebugging);
	};
	
	this.setUseDebugging=function setUseDebugging(aValue)
	{
		useDebugging=aValue;
	};

	this.debug=function debug (msg, aClassName)
	{
		//var aName=aClassName;
		var aMessage=msg;
		
		console.log (msg);
		
		if (useDebuggingBasic==true)
		{
			pointer.debugInternal (aMessage,"UnknownClass");
			return;
		}
		
		/*
		if (aName===null)
		{
			try
			{
				pointer.getClassName();
			}
			catch (err)
			{	
				pointer.debugInternal ("UndefinedClass","Internal error, trying to call pointer.getClassName () on an object that does not have that method: " + err.message);
				pointer.debugInternal (aName,msg);
				return;
			}			
		
			if (pointer.getClassName()===null)
			{
				aName="UndefinedClass";
			}
			else
			{
				aName=pointer.getClassName();
			}
		}
		*/
		
		if (msg===null)
		{
			aMessage="No message provided";
		}
	
		if(useDebugging===true)
		{
			//pointer.debugInternal (aName,aMessage);
			pointer.debugInternal (aMessage,pointer.getClassName());
		}
	};

	this.debugObject=function debugObject (object)
	{
		var output='';
		var index=0;
		
		for (property in object) 
		{
		  //output += property + ': ' + object[property]+'; \n ';
		  this.debug ("("+index+")" + property + ': ' + object[property]);
		  
		  index++;
		}				
	};

	this.debugInternal=function debugInternal (msg,aClassName)
	{		
		//var aClassName=aName;
		//var aName=name;
		var aMessage=msg;
		var txt="No msg assigned yet";
		
		if (aMessage==null)
		{
			aMessage="No message!";
		}
		
		if (aMessage=="")
		{
			aMessage="Empty message!";
		}	
		
		if (useDebuggingBasic==true)
		{		
			txt=formatLogMessage ("Unknown","undefined",aMessage);
						
			if (customconsole===null)
			{
				customconsole=getSafeElementById('customconsole');
			}	

			if (customconsole!==null)
			{			
				customconsole.innerHTML+=(txt+"<br>");
			
				customconsole.scrollTop = customconsole.scrollHeight;
			}
			
			return;
		}
		
		if (aClassName===null)
		{
			aClassName="UndefinedClass";
		}
				
		if (aMessage===null)
		{
			aMessage="No message";
		}		
	
		txt=formatLogMessage (aClassName,pointer.getName (),aMessage);
	
		if (platform=="google")
		{
			Logger.log(txt);
			return;
		}	
			
		if (customconsole===null)
		{
			customconsole=getSafeElementById('customconsole');
		}	

		if (customconsole!==null)
		{			
			customconsole.innerHTML+=(txt+"<br>");
		
			customconsole.scrollTop = customconsole.scrollHeight;
		}	
	};

	/**
	*
	*/
	this.debugObjectShallow=function debugObjectShallow (object)
	{
		var output = '';
	
		for (property in object) 
		{
		  output += property + ', ';
		}	
	
		pointer.debugInternal ("Object: " + output,"Global");
	};
	
	this.urldecode=function urldecode(str) 
	{
	   return decodeURIComponent((str+'').replace(/\+/g, '%20'));
	};
	
	/**
	*	
	*/
	this.entitiesConvert=function entitiesConvert (str) 
 	{
		this.debug ("entitiesConvert ()");
 		
		return (this.urldecode (unescape (str)));
 	};
	
 	/**
	*	
	*/
	this.entitiesGenerate=function entitiesGenerate (str) 
 	{
		temper=str;

		return (temper);
 	};
 	
	/**
	*
	*/
 	this.htmlEncode=function htmlEncode (value)
 	{
 		//create a in-memory div, set it's inner text(which jQuery automatically encodes)
 		//then grab the encoded contents back out.  The div never exists on the page.
		
 		return $('<div/>').text(value).html();
		
		//return value;
 	};

	/**
	*
	*/
 	this.htmlDecode=function htmlDecode (value)
 	{
 		return $('<div/>').html(value).text();
 	}; 		

	/**
	*
	*/
	function formatLogMessage (aClass,anInstance,aMessage)
	{		
		var now = new Date();
		
		if (aClass===null)
		{
			aClass="unknownclass";
		}
		
		if (anInstance===null)
		{
			anInstance="nullinstance";
		}
		
		var formatted=pointer.htmlEncode (aMessage);		
				
		var txt="["+dateFormat(now,"hh:MM:ss")+"] ["+aClass+":"+anInstance+"] "+formatted;
		
		return (txt);
	}
		
	/*	
	if (useDebugging===true)
	{
		pointer.debugInternal (aClassName + " ()",aClassName);
	}
	*/	
}

/**
*
*/
function formatLogMessageGoogle (aClass,anInstance,aMessage)
{
	//var formatted=formatter.htmlEncode (aMessage);		
	var formatted=pointer.htmlEncode (aMessage);		
	var txt="["+aClass+":"+anInstance+"] "+formatted;
	
	return (txt);
}	

/**
*
*/
function debug (aMessage) 
{  
	if(useDebugging===false)
	{
		return;
	}
	
	if (aMessage===null)
	{
		aMessage="Empty message!";
	}
	
	if (aMessage=="")
	{
		aMessage="Empty message!";	
	}

	if (platform=="google")
	{
		Logger.log(formatLogMessageGoogle ("CTATTutor","tutor",aMessage));
		return;
	}	
	
	if (debugPointer===null)
	{
		debugPointer = new CTATBase("CTATTutor", "tutor");
	}

	debugPointer.debug (aMessage,"CTATTutor");
}
/**------------------------------------------------------------------------------------
 $Author$ 
 $Date$ 
 $Header$ 
 $Name$ 
 $Locker$ 
 $Log$
 
 -
 License:
 -
 ChangeLog:
 -
 Notes:
 
*/

/**
 * 
 */
function CTATButtonBasedComponent (aClassName,
								   aName,
								   aDescription,
								   aX,
								   aY,
								   aWidth,
								   aHeight)
{
	CTATTutorableComponent.call(this,
					   aClassName, 
					   aName,
					   aDescription,
					   aX,
					   aY,
					   aWidth,
					   aHeight);

	var pointer=this;	
	var buttonText="";
	
	this.debug ("CTATButtonBasedComponent" + " ("+this.getX()+","+this.getY()+","+this.getWidth()+","+this.getHeight()+")");

	/**
	 * 
	 * @param aText
	 */
	this.setText=function setText (aText)
	{
		pointer.debug("setText (" + aText + ")");
	
		buttonText=aText;
	
		if (pointer.getComponent()!=null)
			pointer.getComponent().innerHTML=aText;
	};
	
	this.getText=function getText ()
	{
		return (buttonText);
	}

	/**
	 * 
	 * @param e
	 */
	this.processClick=function processClick (e)
	{
		pointer.debug ("processClick ("+e.currentTarget.getAttribute ("id")+" -> "+e.eventPhase+")");
				
		if (pointer.getEnabled()==true)
		{			
			commShell.gradeComponent (pointer);
		}
		else
			pointer.debug ("Component is disabled, not grading");		
    };		
}

CTATButtonBasedComponent.prototype = Object.create(CTATTutorableComponent.prototype);
CTATButtonBasedComponent.prototype.constructor = CTATButtonBasedComponent;

/**------------------------------------------------------------------------------------
 $Author$ 
 $Date$ 
 $Header$ 
 $Name$ 
 $Locker$ 
 $Log$
 
 -
 License:
 -
 ChangeLog:
 -
 Notes:
 
*/

/**
 * 
 */
function CTATClickableComponent(aClassName,
								aName,
								aDescription,
								aX,
								aY,
								aWidth,
								aHeight)
{
	CTATCompBase.call(this,
					  aClassName,
					  aName,
					  aDescription,
					  aX,
					  aY,
					  aWidth,
					  aHeight);
					
	var pointer=this;
								
	/**
	 * Implement in child class
	 * @param e
	 */
	this.processClick=function processClick (e)
	{
		pointer.debug ("processClick ("+e.currentTarget.getAttribute ("id")+" -> "+e.eventPhase+")");
				
		if (pointer.getEnabled()==true)
		{		
			if ((pointer.getClassName ()=="CTATTextArea") || (pointer.getClassName ()=="CTATTextInput") || (pointer.getClassName ()=="CTATTextField"))
			{
				pointer.debug ("Info: click detected on a text based component, we should grade this type exclusively through backgrading");
			}	
			else
				commShell.gradeComponent (pointer);
		}
		else
			pointer.debug ("Component is disabled, not grading");		
    };     
}

CTATClickableComponent.prototype = Object.create(CTATCompBase.prototype);
CTATClickableComponent.prototype.constructor = CTATClickableComponent;
/**------------------------------------------------------------------------------------
 $Author$ 
 $Date$ 
 $Header$ 
 $Name$ 
 $Locker$ 
 $Log$
 
 -
 License:
 -
 ChangeLog:
 -
 Notes:
 
*/

/**
 * 
 */
function CTATCompBase (aClassName,
					   aName,
					   aDescription,
					   aX,
					   aY,
					   aWidth,
					   aHeight) 
{
	CTATBase.call (this, aClassName, aName);

	var grDescription=aDescription || genDesc;
	
	var x=aX || -2;
	var y=aY || -2;
	var width=aWidth || -2;
	var height=aHeight || -2;
	
	this.debug ("CTATCompBase" + " ("+x+","+y+","+width+","+height+")");
	
	var text="";
	var backgroundColor=globalBackgroundColor;
	var borderColor=globalBorderColor;	
	var fontColor=globalFontColor;
	var fontFamily=globalFontFamily;
	var fontSize=globalFontSize;
	var align=globalAlign;
	var initialized=false;
	var enabled=true;
	var showBorder=false;
	var borderStyle="solid";
	var divWrapper=null;
	var highlighted=false;
	var isBolded=false;
	var isItalicized=false;
	var isUnderlined=false;
	var disableOnCorrect=true;
	var disabledBGColor="white";
	var disabledTextColor="black";
	var showHintHighlight=true;
	var componentGroup="";

	var component=null;
	var label=null;
	var parameters=null;
	var styles=null;
	var pointer=this;
	
	var hasImages=false;	
	var backgroundColor=globalBackgroundColor;	
	var selected=false;	
	
	var componentStyle=new CTATCSS();
	var initialStyle="";
	generateBaseStyle();
	
	var subCanvas=document.createElement('canvas');
	var canvasVisible="hidden";
	
	var topDivZIndex=currentZIndex;
	var topDivIDIndex=currentIDIndex;
	
	var canvasZIndex=currentZIndex+1;
	var canvasIDIndex=currentIDIndex+1;
	
	// Let's give it some kind of default value
	var internalSAI=new CTATSAI ("this","ButtonPressed","-1");
	
	currentZIndex+=2;
	currentIDIndex+=2;

	/**
	 * 
	 */
	this.setSAI=function setSAI (aSelection,anAction,anInput)
	{
		internalSAI=new CTATSAI (aSelection,anAction,anInput,"");		
	};
	
	/**
	 * 
	 */
	this.getSAI=function getSAI ()
	{
		internalSAI.setSelection (pointer.getName());
		
		return (internalSAI);
	};
	
	/**
	*
	*/
	this.setStyle=function setStyle (aStyle,aValue)
	{
		componentStyle.addCSSAttribute(aStyle,aValue);	
	};
	
	/**
	*
	*/
	this.setStyleAll=function setStyleAll (aStyle,aValue)
	{
		subCanvas.setAttribute(aStyle,aValue);
		componentStyle.modifyCSSAttribute(aStyle,aValue);	
	};	
	
	/**
	*
	*/
	function generateBaseStyle()
	{
		pointer.debug ("generateBaseStyle()");
	
		componentStyle.addSelector(":focus");
		componentStyle.addSelectorAttribute(":focus", "outline", 0);
	
		componentStyle.addCSSAttribute("left", x+"px");
		componentStyle.addCSSAttribute("top", y+"px");
    componentStyle.addCSSAttribute("width", width+"px");
		componentStyle.addCSSAttribute("height", height+"px");
		
		componentStyle.addCSSAttribute("position", "absolute");
	}	
	
	/**
	 * 
	 * @param topDiv
	 */
	this.wrapComponent=function wrapComponent(topDiv)
	{
		pointer.debug ("wrapComponent ()");
	
		divWrapper=document.createElement('div');
		divWrapper.setAttribute('id', ('ctatdiv' + topDivIDIndex));
		divWrapper.setAttribute('name', grDescription.name);
		divWrapper.setAttribute('onkeypress', 'return noenter(event)');
		divWrapper.setAttribute('style', "z-index: "+topDivZIndex);
		topDiv.appendChild(divWrapper);
		
		pointer.debug ("Container div created, adding canvas ...");
		
		subCanvas.setAttribute('id', ('ctatdiv' + canvasIDIndex));
		subCanvas.setAttribute('onkeypress', 'return noenter(event)');
		subCanvas.setAttribute('width', width+canvasCalibrate+"px");
		subCanvas.setAttribute('height', height+canvasCalibrate+"px");
		subCanvas.setAttribute("style", "border: 1px #ff0000 solid; position: absolute; visibility:"+canvasVisible+"; left:"+x+"px; top:"+y+"px; z-index:"+canvasZIndex+";");

		divWrapper.appendChild(subCanvas);
		
		pointer.debug ("wrapComponent () done");		
	};
	
	/**
	 * http://ajaxian.com/archives/forcing-a-ui-redraw-from-javascript
	 */
	this.redraw=function redraw ()
	{
		var temp=divWrapper.style.display;
		divWrapper.style.display="none";
		var redrawFix = divWrapper.offsetHeight;
		divWrapper.style.display=temp; // or other value if required	
	};
	
	/**
	*
	*/
	this.setCanvasVisibility=function setCanvasVisibility(anAttrib)
	{
		canvasVisible=anAttrib;
	};
	
	/**
	*
	*/
	this.getSubCanvasCtx=function getSubCanvasCtx()
	{
		return subCanvas.getContext("2d");
	};

//Accessors-----------------------------------------------------------

	/**
	*
	*/
	this.getSubCanvas=function getSubCanvas ()
	{
		return (subCanvas);
	};

	this.getGrDescription=function getGrDescription()
	{
		return (grDescription);
	};

	this.getX=function getX() 
	{
		return (x);
	};

	this.getY=function getY()
	{
		return (y);
	};

	this.getWidth=function getWidth()
	{
		return (width);
	};
	
	this.getDisabledBGColor=function getDisabledBGColor()
	{
		return (disabledBGColor);
	};
	
	this.getDisabledTextColor=function getDisabledTextColor()
	{
		return (disabledTextColor);
	};
	
	this.getBorderStyle=function getBorderStyle()
	{
		return (borderStyle);
	};

	this.getHeight=function getHeight()
	{
		return (height);
	};

	this.getText=function getText()
	{
		return (text);
	};

	this.getBackgroundColor=function getBackgroundColor()
	{
		return (backgroundColor);
	};

	this.getBorderColor=function getBorderColor()
	{
		return (borderColor);
	};

	this.getFontColor=function getFontColor()
	{
		return (fontColor);
	};

	this.getFontFamily=function getFontFamily()
	{
		return (fontFamily);
	};

	this.getFontSize=function getFontSize()
	{
		return (fontSize);
	};

	this.getAlign=function getAlign()
	{
		return (align);
	};

	this.getInitialized=function getInitialized() 
	{
		return (initialized);
	};

	this.getEnabled=function getEnabled()
	{
		return (enabled);
	};

	this.getShowBorder=function getShowBorder()
	{
		return (showBorder);
	};

	this.getDivWrap=function getDivWrap()
	{
		return (divWrapper);
	};
	
	this.getComponent=function getComponent()
	{
		return (component);
	};
	
	this.getLabel=function getLabel()
	{
		return (label);
	};

	this.getHighlighted=function getHighlighted()
	{
		return (highlighted);
	};
	
	/**
	*
	*/
	this.getCanvasZIndex=function getCanvasZIndex ()
	{
		return (canvasZIndex);
	};
	
    /**
    * This method is primarily for checkboxes and radio buttons so that they
    * may be all grouped together.
    */
	this.getComponentGroup=function getComponentGroup()
	{
		return (componentGroup);
	};

	//Mutators-----------------------------------------------------------

	this.setGrDescription=function setGrDescription(aGrDescription)
	{
		grDescription=aGrDescription;
    };
    
    this.setComponent=function setComponent(aComponent)
    {
    	component=aComponent;
    };
    
    
    /**
    * This method is primarily for checkboxes and radio buttons so that they
    * may be all grouped together.
    */
    this.setComponentGroup=function setComponentGroup(aGroup)
    {
    	componentGroup=aGroup;
    	
    	if (component!=null)
    	{
    		component.name=aGroup;
    	}
    }
    
    this.setLabel=function setLabel(aLabel)
    {
    	label=aLabel;
    };
    
    this.setdivWrapper=function setDivWrapper(aWrapping) 
    {
        divWrapper=aWrapping;
    };

    this.assignText=function assignText(aText)
    {
    	text=aText;
    };
    
	//Needed because there is already a setEnabled method, which happens to be abstract...
	this.assignEnabled=function assignEnabled(aValue)
	{
		enabled=aValue;
	};
	
	this.getCompCSS=function getCompCSS()
	{
		return (componentStyle);
	};

	/**
	 * Even though the reference is called component we can also think 'div',
	 * since in a lot of cases that will be true.
	 */
	this.init=function init ()
	{
		pointer.debug("THIS IS THE BASE INIT METHOD");
	};
	
	/**
	*
	*/	
	this.addSafeEventListener=function addSafeEventListener(aType, aFunction, aTarget)
	{
		pointer.debug ("addSafeEventListener ("+aType+")");
		
		pointer.debug ("Adding event listener to: " + aTarget);
		
		pointer.debug ("Pointing event listener to function: " + aFunction);
	
		if (aTarget!=null)
		{
			aTarget.addEventListener (aType,aFunction);
			return;
		}
	
		if (component!=null)
		{
			component.addEventListener(aType,aFunction);
		}
		else
		{
			pointer.debug ("Error: pointer to component is null, can't add event listener");
		}
		
		pointer.debug ("addSafeEventListener () done");
	};	
	
	//Wrapper functions for the CSS stuff - so user doesn't need to keep using the getter
	this.addCSSAttribute=function addCSSAttribute(attrib, val)
	{
		componentStyle.addCSSAttribute(attrib, val);
		this.render ();
	};
	
	/**
	*
	*/	
	this.render=function render ()
	{
		pointer.debug ("render ()");
    pointer.debug ("("+x+","+y+","+width+","+height+")");
	
		if (component!=null)
		{
			component.setAttribute('style', componentStyle.toCSSString());
      pointer.debug(componentStyle.toCSSString());
		}
		else
		{
			pointer.debug ("Internal error, html component not available for rendering");
		}
		
		pointer.debug ("render () done");
	};
	
	/**
	*
	*/	
	this.clearCSS=function clearCSS ()
	{
		componentStyle.clearCSS();
		this.render ();
	};
	
	/**
	*
	*/	
	this.addStringCSS=function addStringCSS(str) 
	{
		componentStyle.addStringCSS(str);
		this.render ();
	};
	
	/**
	*
	*/	
	this.addSelector=function addSelector(sel)
	{
		componentStyle.addSelector(sel);
	};
	
	/**
	*
	*/	
	this.addSelectorAttribute=function addSelectorAttribute(sel, attrib, val)
	{
		componentStyle.addSelectorAttribute(sel, attrib, val);
	};
	
	/**
	*
	*/	
	this.modifyCSSAttribute=function modifyCSSAttribute(attrib, val)
	{
		componentStyle.modifyCSSAttribute(attrib, val);
		this.render ();
	};
	
	/**
	*
	*/	
	this.getCSS=function getCSS()
	{
		return componentStyle.toCSSString();
	};
	
	/**
	*
	*/	
    this.setInitialized=function setInitialized(aInitialized) 
    {
		pointer.debug ("setInitialized ("+aInitialized+")");
	
        initialized = aInitialized;
        
        if((initialized==true) && (divWrapper==null))
        {
			//useDebugging=true;
		
        	pointer.debug ("Wrapping a component and appending it to the top container div if one was never set ...");
			
			var aClip=findPointOfAttachment (this.getName ());
			
			if (aClip!=null)
			{
				pointer.debug ("Attaching component to existing MovieClip ...");
				
				pointer.wrapComponent(aClip.getDivWrapper ());
			}
			else
			{
				pointer.debug ("Attaching component to main div ...");
			
				pointer.wrapComponent(getSafeElementById("container"));
			}
			
			//useDebugging=false;
        }
		else
		{
			pointer.debug ("Not wrapping, initialized=" + initialized + ", divWrapper = " + divWrapper);		
		}
		
		pointer.debug ("setInitialized () done");
    };
		
	/**
	*
	*/	
	function getKey (e)
	{
	     var key;     
	     
		 if (platform=="google")
		 {
			return (0);
		 }
		 
	     if(window.event)
	          key = window.event.keyCode; //IE
	     else
	          key = e.which; //firefox
	     
	     return (key);
	}

	/**
	*
	*/	
	this.drawComponent = function drawComponent() 
	{
	    //debug ("drawComponent ()");

	    // Nop
	};

	/**
	*
	*/	
	this.addComponentReference = function addComponentReference (aComponent,aDiv)
	{
		pointer.debug ("addComponentReference ("+aComponent.getName ()+" -> "+aDiv.getAttribute ("id")+")");
					
		var newRef=new CTATComponentReference (aComponent,aDiv);

		pointer.debug ("created new component reference");
											
		componentReferences.push (newRef);
		
		pointer.debug ("addComponentReference () done");
	};

	/**
	*
	*/	
	this.getComponentFromID = function getComponentFromID (anID)
	{
		pointer.debug ("getComponentFromID ("+anID+") -> " + componentReferences.length + " references");
				
		for (var i=0;i<componentReferences.length;i++)
		{
			var ref=componentReferences [i];
						
			if (ref.getDiv ().getAttribute ("id")==anID)
			{				
				if (ref.getElement ()==null)
				{
					pointer.debug ("Error: found component reference is null! ("+ref.componentReference+")");
					return (null);
				}
				
				pointer.debug ("Found component reference: " + ref.getElement ().getName () + " for div: " + anID);
											
				return (ref.getElement ());
			}
		}
		
		pointer.debug ("Bottoming out ...");
		
		return (null);
	};

	/**
	 * 
	 */
	this.configFromDescription=function configFromDescription ()
	{
		pointer.debug ("configFromDescription ()");
		
		if (grDescription==null)
		{
			pointer.debug ("Error: no deserialized component description available");
			return;
		}
		
		pointer.setName(grDescription.name);
		
		//>-----------------------------------------------------------------------------
		
		this.parameters=grDescription.params;
		
		if (this.parameters!=null)
		{		
			for(var i=0;i<this.parameters.length;i++)
			{
				var aParam=this.parameters [i];
				
				if (aParam.paramName=="ShowHintHighlight")
				{
					pointer.setHintHighlight(aParam.paramValue);
				}
				
				if (aParam.paramName=="DisableOnCorrect")
				{
					disableOnCorrect=aParam.paramValue;
				}
				
				if (aParam.paramName=="tutorComponent")
				{
					pointer.setTutorComponent(aParam.paramValue);
				}
				
				if (aParam.paramName=="group")
				{
					pointer.setComponentGroup(aParam.paramValue);
				}
			}
		}
		
		//>-----------------------------------------------------------------------------		
			
		this.styles=grDescription.styles;
		
		if (this.styles!=null)
		{
			pointer.debug ("Processing " + this.styles.length + " styles ...");
			
			for (var i=0;i<this.styles.length;i++)
			{
				var aStyle=this.styles [i]; // CTATStyle
				
				//pointer.debug ("Processing style " + aStyle.styleName + "," + aStyle.styleValue);	
				
				if (aStyle.styleName=="backgroundColor")
				{
					pointer.setBackgroundColor("#"+aStyle.styleValue);
				}
				
				if (aStyle.styleName=="BorderColor")
				{
					pointer.setBorderColor("#"+aStyle.styleValue);
				}
				
				if (aStyle.styleName=="FontName")
				{
					pointer.setFontFamily(aStyle.styleValue);
				}
				
				if (aStyle.styleName=="FontSize")
				{
					pointer.setFontSize(aStyle.styleValue);
				}
				
				if (aStyle.styleName=="FontColor")
				{
					pointer.setFontColor(aStyle.styleValue);
				}
				
				if (aStyle.styleName=="FontBold")
				{
					isBolded=aStyle.styleValue;
					
					if(isBolded=="true")
					{
						componentStyle.addCSSAttribute("font-weight", "bold");
						
						this.render ();
					}
				}
				
				if (aStyle.styleName=="FontItalic")
				{
					isItalicized=aStyle.styleValue;
					
					if(isItalicized=="true")
					{
						componentStyle.addCSSAttribute("font-style", "italic");
						
						this.render ();
					}
				}
				
				if (aStyle.styleName=="FontUnderlined")
				{
					isUnderlined=aStyle.styleValue;

					if(isUnderlined=="true")
					{
						componentStyle.addCSSAttribute("text-decoration", "underline");
						
						this.render ();
					}
				}
				
				if (aStyle.styleName=="TextAlign")
				{
					pointer.setAlign(aStyle.styleValue);
				}

				if (aStyle.styleName=="disabledBackgroundColor")
				{
					disabledBGColor=aStyle.styleValue;
				}
				
				if (aStyle.styleName=="disabledTextColor")
				{
					disabledTextColor=aStyle.styleValue;
				}
			}
		}
		
		//>-----------------------------------------------------------------------------
		
		pointer.debug ("configFromDescription () done");
	};
	
	/**
	 * 
	 */
	this.processSerialization=function processSerialization()
	{
		//pointer.debug ("processSerialization()");
		
		// implement in child class
	};
	
	/**
	 * Ported from AS3
	 * @param w
	 * @param h
	 */
	this.move=function move(newX,newY) 
	{
		//pointer.debug ("move ("+newX+","+newY+")");
						
		this.x=newX;
		this.y=newY;

		componentStyle.modifyCSSAttribute("left", this.x+"px");
		componentStyle.modifyCSSAttribute("top", this.y+"px");		
		
		this.render ();
	};	
	/**
	 * Ported from AS3
	 * @param w
	 * @param h
	 */
	this.setSize=function setSize(w,h) 
	{
		pointer.debug ("setSize ("+w+","+h+")");
				
		this.width=w;
		this.height=h;		
				
		this.setStyleAll ('width',w+'px');
		this.setStyleAll ('height',h+'px');
		
		this.render ();		
	};
	/**
	 * Changes the visibility of the object. Ported from AS3
	 * @param aValue true/false visible or not.
	 */
	this.SetVisible=function SetVisible (aValue)
	{
		pointer.debug ("SetVisible ("+aValue+")","graphics");
	};
	
	/**
	 * Changes the visibility of the object. Ported from AS3
	 * @param aValue true/false visible or not.
	 */
	this.setVisible=function setVisible (aValue)
	{
		if (aValue==true)
			canvasVisible='block';
		else	
			canvasVisible='hidden';
	
		subCanvas.setAttribute("style", "border: 0px; position: absolute; visibility:"+canvasVisible+"; left:"+x+"px; top:"+y+"px; z-index:"+canvasZIndex+";");
	};
	
	/**
	 *  Ported from AS3
	 */		
	this.showCorrect=function showCorrect()
	{
		pointer.debug("showCorrect("+correctColor+")");
	
	    fontColor=correctColor;
	    showHintHighlight=false;
	    componentStyle.removeStringCSS(globalGlowString);
		componentStyle.modifyCSSAttribute("color", correctColor);
		
		if(disableOnCorrect=="true")
		{
			disabledTextColor=correctColor;
			pointer.setEnabled (false);
		}
		
		if(initialized==true)
		{
			this.render ();
		}
	};
	/**
	 * Ported from AS3
	 */		
	this.showInCorrect=function showInCorrect()
	{
		pointer.debug("showInCorrect("+incorrectColor+")");

		fontColor=incorrectColor;
		componentStyle.modifyCSSAttribute("color", incorrectColor);

		if(initialized==true)
		{
			pointer.debug ("Style: " + componentStyle.toCSSString());
		
			this.render ();
		}
		else
			pointer.debug ("Not initialized");
	};	
	/**
	 * Ported from AS3
	 */
	this.setHintHighlight=function setHintHighlight(newValue)
	{
		pointer.debug("setHintHighlight (" + newValue + ")");
		
		if (newValue==true)	
		{	
			showHintHighlight=true;
			componentStyle.addStringCSS(globalGlowString);
		}
		
		else 
		{
			showHintHighlight=false;
			componentStyle.removeStringCSS(globalGlowString);
		}
		
		if(initialized==true)
		{
			this.render ();
		}
	};
	/**
	 * Implement in child object
	 */
	this.reset=function reset ()
	{

	};
	/**
	 * 
	 */
	this.setX=function setX (aX)
	{		
		x=aX;
		componentStyle.modifyCSSAttribute("left", x+"px");
		
		if(initialized==true)
		{
			this.render ();
		}
	};

	this.setY=function setY (aY)
	{
		y=aY;
		componentStyle.modifyCSSAttribute("top", y+"px");
		
		if(initialized==true)
		{
			this.render ();
		}
	};

	this.setWidth=function setWidth (aWidth)
	{
		width=aWidth;
		componentStyle.modifyCSSAttribute("width", width+"px");
		
		if(initialized==true)
		{
			this.render ();
		}
	};

	this.setHeight=function setHeight (aHeight)
	{
		height=aHeight;
		componentStyle.modifyCSSAttribute("height", height+"px");
		
		if(initialized==true)
		{
			this.render ();
		}
	};

	this.setBackgroundColor=function setBackgroundColor (aColor)
	{
		backgroundColor=aColor;
		componentStyle.modifyCSSAttribute("background-color", backgroundColor);
		
		if(initialized==true)
		{
			this.render ();
		}
	};

	this.setBorderColor=function setBorderColor (aColor)
	{
		borderColor=aColor;
		componentStyle.modifyCSSAttribute("border-color", borderColor);
		componentStyle.modifyCSSAttribute("border-width", 1+"px");
		
		if(initialized==true)
		{
			this.render ();
		}
	};
	
	this.setBorderStyle=function setBorderStyle(aStyle)
	{
		borderStyle=aStyle;
		componentStyle.modifyCSSAttribute("border-style", borderStyle);
		componentStyle.modifyCSSAttribute("border-width", 1+"px");
		
		if(initialized==true)
		{
			this.render ();
		}
	};

	this.setFontColor=function setFontColor (aColor)
	{	
		fontColor=aColor;
		componentStyle.modifyCSSAttribute("color", fontColor);
		
		if(initialized==true)
		{
		
			//We want to set the font color. A component may use the font color for its inner
			//html, but if we have a label, then we need to set the label's font color.
			
			if(label==null)
			{
				this.render ();
			}
			
			else
			{
				label.setAttribute('style', "color: "+fontColor);
			}
		}
	};

	this.setFontFamily=function setFontFamily (aFont)
	{
		fontFamily=aFont;
		componentStyle.modifyCSSAttribute("font-family", fontFamily);
		
		if(initialized==true)
		{
			this.render ();
		}
	};

	this.setFontSize=function setFontSize (aSize)
	{
		fontSize=aSize;
		componentStyle.modifyCSSAttribute("font-size", fontSize+"pt");
		
		if(initialized==true)
		{
			this.render ();
		}
	};

	this.setEnabled=function setEnabled(aValue) 
	{
		pointer.assignEnabled(aValue);
			
		if (component==null)
			return;
			
		component.disabled=!aValue;	
	};

	this.setShowBorder=function setShowBorder (aValue)
	{
		showBorder=aValue;

		if(showBorder==true)
		{
			componentStyle.modifyCSSAttribute("border-style", borderStyle);
			componentStyle.modifyCSSAttribute("border-width", 1+"px");
		}
		
		else
		{
			componentStyle.modifyCSSAttribute("border-style", "hidden");
		}
		
		if(initialized==true)
		{
			this.render ();
		}
	};

	this.setAlign=function setAlign (anAlign)
	{
		align=anAlign;
		componentStyle.modifyCSSAttribute("text-align", align);
		
		if(initialized==true)
		{
			this.render ();
		}
	};

	this.setText=function setText(aText) 
	{
	    //Overrode in child objects
	};

	this.getValue=function getValue ()
	{
		if (component!=null)
			return (component.value);
		
		return "";
	};

	/**
	 * This method is called when a component gets focused. So keep in mind that
	 * we want to grade the component that lost focus, or in other words the
	 * previously focused component.
	 */
	this.processFocus=function processFocus (e)
	{
		pointer.debug ("processFocus ()");
		
		var id=e.currentTarget.getAttribute ("id");
		var comp=pointer.getComponentFromID (id);
		
		if (comp==null)
		{
			pointer.debug ("Error: component reference is null");
			return;
		}
		
		if (mobileAPI!=null)
		{
			if (mobileAPI.getEnabled ()==true)
			{
				pointer.hideKeyboard ();
			}	
		}	
		
		if (commShell!=null)
		{
			commShell.processComponentFocus (comp);
		}
		
		if (oldComponentFocus!=null)
		{
			pointer.debug ("old focus: " + oldComponentFocus.getName () + ", new focus:" + comp.getName ());
		
			if (oldComponentFocus==comp)
			{
				pointer.debug ("We're already there!");
				return;
			}
	
			if (commShell!=null)
			{
				commShell.gradeComponent (oldComponentFocus);
			}
			
			oldComponentFocus.setHintHighlight(false);
		}
		else
			pointer.debug ("No previously focused component yet, can't grade");
		
		oldComponentFocus=pointer;			
	};
	
	/**
	*
	*/
	this.hideKeyboard=function hideKeyboard () 
	{
		document.activeElement.blur();
		$("input").blur();
	};	
}

CTATCompBase.prototype = Object.create(CTATBase.prototype);
CTATCompBase.prototype.constructor = CTATCompBase;
function CTATDataDisplayComponent()
{
	//Stub prototype
	CTATTutorableComponent.call(this);
}

CTATDataDisplayComponent.prototype = Object.create(CTATTutorableComponent.prototype);
CTATDataDisplayComponent.prototype.constructor = CTATDataDisplayComponent;/**------------------------------------------------------------------------------------
 $Author$ 
 $Date$ 
 $Header$ 
 $Name$ 
 $Locker$ 
 $Log$
 
 -
 License:
 -
 ChangeLog:
 -
 Notes:
 
*/


/**
 *  
 */
function CTATGroupingComponent(anInstance)
{
	CTATBase.call(this, "CTATGroupingComponent", anInstance);

	var pointer=this;	
	
	this.init=function init() 
	{
	    pointer.debug("init (" + pointer.getName() + ")");

	};		
	
	/**
	 * 
	 */
	this.processSerialization=function processSerialization()
	{
		pointer.debug ("processSerialization()");

	}		
}

CTATGroupingComponent.prototype = Object.create(CTATBase.prototype);
CTATGroupingComponent.prototype.constructor = CTATGroupingComponent;/**------------------------------------------------------------------------------------
 $Author$ 
 $Date$ 
 $Header$ 
 $Name$ 
 $Locker$ 
 $Log$
 
 -
 License:
 -
 ChangeLog:
 -
 Notes:
 
  Events: click, mousemove, mouseover, mouseout, keyup, keydown, 
  		  focus, blur, select, load

  CSS: http://tutobx.com/post/24806696944/raised-and-pressed-div-using-css
       http://stackoverflow.com/questions/5662178/opacity-of-divs-background-without-affecting-contained-element-in-ie-8
 
  Js:  http://www.quirksmode.org/js/this.html
       http://unschooled.org/2012/03/understanding-javascript-this/   
 
  CTAT:
  
 		[48] [07:14:14] [CTATTextField] Processing style labelTextValue,
		[49] [07:14:14] [CTATTextField] Processing style inspBackgroundColor,ffffff
		[50] [07:14:14] [CTATTextField] Processing style inspBorderColor,999999
		[51] [07:14:14] [CTATTextField] Processing style inspFontName,Arial
		[52] [07:14:14] [CTATTextField] Processing style inspFontSize,20
		[53] [07:14:14] [CTATTextField] Processing style inspFontColor,0
		[54] [07:14:14] [CTATTextField] Processing style inspBold,FALSE
		[55] [07:14:14] [CTATTextField] Processing style inspItalic,FALSE
		[56] [07:14:14] [CTATTextField] Processing style inspUnderline,FALSE
		[57] [07:14:14] [CTATTextField] Processing style inspAlignment,left
		[58] [07:14:14] [CTATTextField] Processing style inspShowHintHighlight,true
		[59] [07:14:14] [CTATTextField] Processing style blockOnCorrect,true
		[60] [07:14:14] [CTATTextField] Processing style _tutorComponent,Tutor
		[61] [07:14:14] [CTATTextField] Processing style disabledBackgroundColor,ffffff
		[62] [07:14:14] [CTATTextField] Processing style disabledTextColor,0
		[63] [07:14:14] [CTATTextField] Processing style tutorComponent,Tutor  
		
	Then you can also include base64 data in img tags like this

	<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAAWCAIAAABL1vtsAAAY		
*/

function CTATImageButtonComponent(aClassName, 
								  aName,
								  aDescription,
								  aX,
								  aY,
								  aWidth,
								  aHeight)
{
	CTATButtonBasedComponent.call(this,
					  			  aClassName, 
					  			  aName,
					  			  aDescription,
					 			  aX,
					 			  aY,
					 			  aWidth,
					 			  aHeight);

	var defaultImage="";
	var clickedImage="";
	var hoverImage="";
	var disabledImage="";
	
	var imgButton=null;
	
	/**
	 * In the case of the web, we don't need to worry about scaling from
	 * an image to a component, because the browser does this for us
	 * automatically. We do, however, have to scale from component to image.
	 */
	var scaling="Image to Component";
	
	var pointer=this;
	
	//this.setClickable(true);
	
	/**
	 * 
	 */
	this.getDefaultImage=function getDefaultImage()
	{
		return (defaultImage);
	};
	
	/**
	 * 
	 */
	this.setDefaultImage = function setDefaultImage(aImage) 
	{
	    defaultImage=aImage;
	};
	
	/**
	 * 
	 */	
	this.getHoverImage=function getHoverImage()
	{
		return (hoverImage);
	};
	
	/**
	 * 
	 */	
	this.setHoverImage = function setHoverImage(aImage) 
	{
	    hoverImage=aImage;
	};	
		
	/**
	 * 
	 */	
	this.setClickedImage = function setClickedImage(aImage) 
	{
	    clickedImage=aImage;
	};
	
	/**
	 * 
	 */	
	this.getClickedImage=function getClickedImage()
	{
		return (clickedImage);
	};
	
	/**
	 * 
	 */	
	this.setDisabledImage = function setDisabledImage(aImage) 
	{
	    disabledImage=aImage;
	};
	
	/**
	 * 
	 */	
	this.getDisabledImage=function getDisabledImage()
	{
		return (disabledImage);
	};
	
	/**
	 * 
	 */
	 this.setScaling=function setScaling(aScaling)
	 {
	 	scaling=aScaling;
	 };
	 
	/**
	 * 
	 */
	 this.getScaling=function getScaling()
	 {
	 	return (scaling);
	 };
	
	/**
	 * 
	 */
	this.assignImages=function assignImages(aDefault, aClicked, aHover, aDisabled) 
	{
	    pointer.debug("assignImages ()");
	    
	    defaultImage=aDefault;
	    clickedImage=aClicked;
	    hoverImage=aHover;
	    disabledImage=aDisabled;

	    if (pointer.getComponent() != null) 
	    {
	    	pointer.assignActiveImage (defaultImage);
	    }
	};
	
	/**
	 * 	
	 */
	this.assignActiveImage=function assignActiveImage (anImage)
	{
		//pointer.debug ("assignActiveImage ()")
		
   		pointer.getComponent().src=anImage;

   		if(scaling=="Component to Image")
   		{
   			var temp=new Image();
   			temp.src=anImage;
   			
   			pointer.setWidth(temp.width);
   			pointer.setHeight(temp.height);
   		}
	};
	
	/**
	 * Override the original setEnabled method
	 */
	this.setEnabled=function setEnabled (aValue)
	{
		pointer.debug("setEnabled ("+aValue+")");
		
		pointer.assignEnabled(aValue);
		
		if (pointer.getComponent()==null)
		{
			pointer.debug ("Error: pointer is null!");
			return;
		}
		
		if (pointer.getEnabled()==true)
			pointer.getComponent().disabled=false;
		else
			pointer.getComponent().disabled=true;
		
   		if(pointer.getEnabled()==false)
   		{   			
   			pointer.assignActiveImage (disabledImage);
   		}
   		else
   		{  			
   			pointer.assignActiveImage (defaultImage);
   		}
    };
    
    /**
     * 
     */
    this.processMouseOver = function processMouseOver(e) 
    {
        //pointer.debug("processMouseOver (" + e.currentTarget.getAttribute("id") + " -> " + e.eventPhase + ")");

        if (pointer.getEnabled ()==true)
        {
        	if (pointer != null)
        	{
        		pointer.assignActiveImage (hoverImage);
        	}
        	else
        		pointer.debug ("Error component is null");
        }
        else
        	pointer.debug ("Error component is disabled");
    };
        	
    /**
     * 
     */
    this.processMouseOut = function processMouseOut(e) 
    {
        //pointer.debug("processMouseOut (" + e.currentTarget.getAttribute("id") + " -> " + e.eventPhase + ")");

        if(pointer.getEnabled ()==true)
        {
        	if (pointer != null)
        	{
        		pointer.assignActiveImage (defaultImage);
        	}
        	else
        		pointer.debug ("Error component is null");        	
        }
    };
}

CTATImageButtonComponent.prototype = Object.create(CTATButtonBasedComponent.prototype);
CTATImageButtonComponent.prototype.constructor = CTATImageButtonComponent;
/**------------------------------------------------------------------------------------
 $Author$ 
 $Date$ 
 $Header$ 
 $Name$ 
 $Locker$ 
 $Log$
 
 -
 License:
 -
 ChangeLog:
 -
 Notes:
 
*/


/**
 *  
 */
function CTATMovieClip (anInstance,aX,aY,aWidth,aHeight)
{
	CTATBase.call(this, "CTATMovieClip", anInstance);

	var x=aX;
	var y=aY;
	var width=aWidth;
	var height=aHeight;	
			
	var topDivZIndex=currentZIndex;
	var topDivIDIndex=currentIDIndex;	
	
	var canvasZIndex=currentZIndex+1;
	var canvasIDIndex=currentIDIndex+1;
	
	var componentList=new Array ();
	
	var pointer=this;	
		
	var divWrapper=null;	
		
	/**
	 *
	 */
	this.wrapComponent=function wrapComponent(aParent)
	{
		divWrapper=document.createElement('div');
		divWrapper.setAttribute('id', ('ctatdiv' + topDivIDIndex));
		divWrapper.setAttribute('name', this.getName ());
		divWrapper.setAttribute('style', "z-index: "+topDivZIndex);
				
		divWrapper.setAttribute('width', width+"px");
		divWrapper.setAttribute('height', height+"px");

		divWrapper.setAttribute("style", "border: 0px; position: absolute; left:"+x+"px; top:"+y+"px; z-index:"+canvasZIndex+";");		
		divWrapper.setAttribute("style", "border: 0px; position: relative; left:"+x+"px; top:"+y+"px; z-index: inherit;");		
		
		aParent.appendChild(divWrapper);	

		return (divWrapper);		
	};
	
	/**
	*
	*/
	this.getDivWrapper=function getDivWrapper ()
	{
		return (divWrapper);
	};
	
	/**
	*
	*/
	this.addComponent=function addComponent (aComponentName)
	{
		pointer.debug ("addComponent ("+aComponentName+")");
		
		componentList.push(aComponentName);
	}
	/**
	*
	*/
	this.isRegistered=function isRegistered (aComponentName)
	{
		for (var i=0;i<componentList.length;i++)
		{
			if (componentList [i]==aComponentName)
			{
				return (true);
			}
		}	
	
		return (false);
	}
}

CTATMovieClip.prototype = Object.create(CTATBase.prototype);
CTATMovieClip.prototype.constructor = CTATMovieClip;
/**------------------------------------------------------------------------------------
 $Author$ 
 $Date$ 
 $Header$ 
 $Name$ 
 $Locker$ 
 $Log$
 
 -
 License:
 -
 ChangeLog:
 -
 Notes:
 
*/

/**
 * 
 */
function CTATTextBasedComponent(aClassName, aName, aDescription, aX, aY, aWidth, aHeight)
{

	CTATTutorableComponent.call(this,
					  			aClassName, 
					  			aName,
					  			aDescription,
					 			aX,
					 			aY,
					 			aWidth,
					 			aHeight);
					 			
	var pointer=this;				 			
	var text="";
	var tabOnEnter=false;
	var maxCharacters=255;
	var editable=true;
	
	this.assignText=function assignText(aText)
	{
		text=aText;
	};
	
	this.setTabOnEnter=function setTabOnEnter(aValue)
	{
		tabOnEnter=aValue;
	};
	
	this.assignEditable=function assignEditable(aEditable)
	{
		editable=aEditable;
	};
	
	this.setMaxCharacters=function setMaxCharacters(aMax)
	{
		maxCharacters=aMax;
	};
	
	this.getText=function getText()
	{
		return (text);
	};
	
	this.getEditable=function getEditable()
	{
		return (editable);
	};
	
	this.getTabOnEnter=function getTabOnEnter()
	{
		return (tabOnEnter);
	};
	
	this.getMaxCharacters=function getMaxCharacters()
	{
		return (maxCharacters);
	};
	
	function getKey (e)
	{
	     var key;     
	     
		 if (platform=="google")
		 {
			return (0);
		 }		 
		 
	     if(window.event)
	          key = window.event.keyCode; //IE
	     else
	          key = e.which; //firefox
	     
	     return (key);
	}
	
	/**
	 * 
	 * @param aValue
	 */
	this.setEditable=function setEditable(aValue)
	{
		pointer.assignEditable(aValue);
				
		if (pointer.getComponent()==null)
			return;
		
		if (pointer.getEditable()==true)
			pointer.getComponent().contentEditable='true';
		else
			pointer.getComponent().contentEditable='false';
			
		pointer.setFontColor(pointer.getDisabledTextColor());
		pointer.setBackgroundColor(pointer.getDisabledBGColor());
	};
	
	/**
	 * Override from CTATCompBase because for text based components
	 * we also have to set them non-editable
	 * 
	 * @param aValue
	 */
	this.setEnabled=function setEnabled(aValue) 
	{
		pointer.assignEnabled(aValue);
			
		if (pointer.getComponent()==null)
			return;
			
		pointer.getComponent().disabled=!aValue;
		
		this.setEditable (aValue);
	};

	this.processKeypress=function processKeypress (e)
	{
		pointer.debug ("processKeypress ()");
		
		var id=e.target.getAttribute ("id");
		pointer.debug(id);
		var comp=pointer.getComponentFromID (id);
		
		var textElement=pointer.getComponent();
		//alert(textElement.innerHTML);
		if (comp==null)
		{
			pointer.debug ("Error: component reference is null");
			return;
		}
		
		pointer.debug (comp.name + " keydown ("+getKey (e)+" -> "+e.eventPhase+") " + "ID: " + id);
								
		currentComponent=id;
		currentComponentPointer=comp;
		
	    switch (getKey (e)) 
	    {
	    	// key code for left arrow
	       	case 37:
	       			pointer.debug('left arrow key pressed!');
	       			break;
		        
	       			// key code for right arrow
	       	case 39:
	       			pointer.debug('right arrow key pressed!');
	       			break;
	       			
	       	case 13:
	       			pointer.debug('Enter key pressed!');
	       			
	       			if(tabOnEnter==true)
	       			{
	       				commShell.focusNextComponent (comp);
	       			}
	       			
	       			commShell.gradeComponent (comp);
	       			return (false);
	       			
	       	default:
	       			pointer.debug('Key pressed!');
	       			
	       			/*
	       			if(this.getComponent().innerHTML.length>maxCharacters)
	       			{
	       				this.getComponent().innerHTML=this.getComponent().innerHTML.substring(0, maxCharacters);
	       				alert("You have exceeded the maximum characters allowed: " + maxCharacters);
	       			}
	       			*/
	    }
	};
}

CTATTextBasedComponent.prototype = Object.create(CTATTutorableComponent.prototype);
CTATTextBasedComponent.prototype.constructor = CTATTextBasedComponent;/**------------------------------------------------------------------------------------
 $Author$ 
 $Date$ 
 $Header$ 
 $Name$ 
 $Locker$ 
 $Log$
 
 -
 License:
 -
 ChangeLog:
 -
 Notes:
 
*/

/**
 * 
 */
function CTATTutorableComponent (aClassName,
								 aName,
					 			 aDescription,
					 			 aX,
					 			 aY,
					 			 aWidth,
					 			 aHeight)
{	
	CTATClickableComponent.call(this,
								aClassName, 
								aName,
								aDescription,
								aX,
								aY,
								aWidth,
								aHeight);

	var TUTOR="Tutor";
	var TUTOR_NO_FEEDBACK="Tutor but no visual feedback";
	var DO_NOT_TUTOR="Do not tutor";
	
	var defaultTutorMe=true;
	var defaultRecordMe=true;

	var _tutorComponent="Tutor";
	
	this.setTutorComponent=function setTutorComponent (theValue)
	{
		_tutorComponent=theValue;
		
		switch (_tutorComponent) 
		{
			case TUTOR :
									defaultTutorMe=defaultRecordMe=true;
									showFeedback=true;
									break;
			case TUTOR_NO_FEEDBACK :
									defaultTutorMe=defaultRecordMe=true;
									showFeedback=false;
									break;
			case DO_NOT_TUTOR :
									defaultTutorMe=false;
									defaultRecordMe=true;
									break;
		}
	};
	
	this.getTutorComponent=function getTutorComponent ()
	{
		return (_tutorComponent);
	};						
}

CTATTutorableComponent.prototype = Object.create(CTATClickableComponent.prototype);
CTATTutorableComponent.prototype.constructor = CTATTutorableComponent;function CTATUnitDisplayComponent()
{
	//Stub prototype
	CTATDataDisplayComponent.call(this);
}

CTATUnitDisplayComponent.prototype = Object.create(CTATDataDisplayComponent.prototype);
CTATUnitDisplayComponent.prototype.constructor = CTATUnitDisplayComponent;/**------------------------------------------------------------------------------------
 $Author$ 
 $Date$ 
 $Header$ 
 $Name$ 
 $Locker$ 
 $Log$
 
 -
 License:
 -
 ChangeLog:
 -
 Notes:
 
  Events: click, mousemove, mouseover, mouseout, keyup, keydown, 
  		  focus, blur, select, load

  CSS: http://tutobx.com/post/24806696944/raised-and-pressed-div-using-css
       http://stackoverflow.com/questions/5662178/opacity-of-divs-background-without-affecting-contained-element-in-ie-8
 
  Js:  http://www.quirksmode.org/js/this.html
       http://unschooled.org/2012/03/understanding-javascript-this/   
 
  CTAT:
  
 		[48] [07:14:14] [CTATTextField] Processing style labelTextValue,
		[49] [07:14:14] [CTATTextField] Processing style inspBackgroundColor,ffffff
		[50] [07:14:14] [CTATTextField] Processing style inspBorderColor,999999
		[51] [07:14:14] [CTATTextField] Processing style inspFontName,Arial
		[52] [07:14:14] [CTATTextField] Processing style inspFontSize,20
		[53] [07:14:14] [CTATTextField] Processing style inspFontColor,0
		[54] [07:14:14] [CTATTextField] Processing style inspBold,FALSE
		[55] [07:14:14] [CTATTextField] Processing style inspItalic,FALSE
		[56] [07:14:14] [CTATTextField] Processing style inspUnderline,FALSE
		[57] [07:14:14] [CTATTextField] Processing style inspAlignment,left
		[58] [07:14:14] [CTATTextField] Processing style inspShowHintHighlight,true
		[59] [07:14:14] [CTATTextField] Processing style blockOnCorrect,true
		[60] [07:14:14] [CTATTextField] Processing style _tutorComponent,Tutor
		[61] [07:14:14] [CTATTextField] Processing style disabledBackgroundColor,ffffff
		[62] [07:14:14] [CTATTextField] Processing style disabledTextColor,0
		[63] [07:14:14] [CTATTextField] Processing style tutorComponent,Tutor  
*/

/**
 * 
 */
function CTATButton (aDescription,
					 aX,
					 aY,
					 aWidth,
					 aHeight)
{	
	CTATButtonBasedComponent.call(this,
								  "CTATButton", 
								  "aButton",
								  aDescription,
								  aX,
								  aY,
								  aWidth,
								  aHeight);

	var pointer=this;
	var borderRoundness=5;
	var buttonText="";
					
	this.debug ("CTATButton" + " ("+this.getX()+","+this.getY()+","+this.getWidth()+","+this.getHeight()+")");

	this.configFromDescription();

	this.init=function init() 
	{
	    pointer.debug("init (" + pointer.getName() + ")");
	    
	    pointer.setSAI ("this","ButtonPressed","-1");
	    
	    pointer.addCSSAttribute("z-index", currentZIndex);
		pointer.addCSSAttribute("width", pointer.getWidth()+"px");
		pointer.addCSSAttribute("height", pointer.getHeight()+"px");
		pointer.render ();
	
		button=document.createElement('button');
		button.value=pointer.getName();
	    button.name=pointer.getName(); // might be wrong
	    button.setAttribute('id', ('ctatdiv' + currentIDIndex));
	    button.setAttribute('onkeypress', 'return noenter(event)');
	    
	    pointer.setInitialized(true);
	    
	    pointer.setComponent(button);
	    pointer.addComponentReference(pointer, button);
	    pointer.getDivWrap().appendChild(button);

	    pointer.debug("Final location: " + pointer.getX() + "," + pointer.getY() + " with text: " + pointer.getText());

	    currentZIndex++;
	    currentIDIndex++;
	    
	    pointer.addSafeEventListener ('click',pointer.processClick,button);
	    pointer.addSafeEventListener ('focus', pointer.processFocus,button);
	};

	this.reset=function reset ()
	{
		pointer.configFromDescription();
		pointer.processSerialization();
		pointer.setEnabled(true);
	};

	/**
	 * 
	 */
	this.processSerialization=function processSerialization()
	{
		pointer.debug ("processSerialization()");

		// Process component specific pre-defined styles ...
		
		pointer.setText (this.label);
		
		// Process component custom styles ...		

		this.styles=pointer.getGrDescription().styles;
		
		pointer.debug ("Processing " + this.styles.length + " styles ...");
		
		for (var i=0;i<this.styles.length;i++)
		{
			var aStyle=this.styles [i]; // CTATStyle
			
			if (aStyle.styleName=="labelText")
			{
				pointer.setText(aStyle.styleValue);
			}
			
			if(aStyle.styleName=="borderRoundness")
			{
				borderRoundness=aStyle.styleValue;
				pointer.addCSSAttribute("border-radius", borderRoundness+"px");
			}
		}	
	};
	
	/**
	 * TPA 
	 */
	 this.ButtonPressed=function ButtonPressed ()
	 {
	 	pointer.debug ("ButtonPressed ()");
	 };
}

CTATButton.prototype = Object.create(CTATButtonBasedComponent.prototype);
CTATButton.prototype.constructor = CTATButton;
/**------------------------------------------------------------------------------------
 $Author$ 
 $Date$ 
 $Header$ 
 $Name$ 
 $Locker$ 
 $Log$
 
 -
 License:
 -
 ChangeLog:
 -
 Notes:
 
  Events: click, mousemove, mouseover, mouseout, keyup, keydown, 
  		  focus, blur, select, load

  CSS: http://tutobx.com/post/24806696944/raised-and-pressed-div-using-css
       http://stackoverflow.com/questions/5662178/opacity-of-divs-background-without-affecting-contained-element-in-ie-8
 
  Js:  http://www.quirksmode.org/js/this.html
       http://unschooled.org/2012/03/understanding-javascript-this/   
 
  CTAT:
  
 		[48] [07:14:14] [CTATTextField] Processing style labelTextValue,
		[49] [07:14:14] [CTATTextField] Processing style inspBackgroundColor,ffffff
		[50] [07:14:14] [CTATTextField] Processing style inspBorderColor,999999
		[51] [07:14:14] [CTATTextField] Processing style inspFontName,Arial
		[52] [07:14:14] [CTATTextField] Processing style inspFontSize,20
		[53] [07:14:14] [CTATTextField] Processing style inspFontColor,0
		[54] [07:14:14] [CTATTextField] Processing style inspBold,FALSE
		[55] [07:14:14] [CTATTextField] Processing style inspItalic,FALSE
		[56] [07:14:14] [CTATTextField] Processing style inspUnderline,FALSE
		[57] [07:14:14] [CTATTextField] Processing style inspAlignment,left
		[58] [07:14:14] [CTATTextField] Processing style inspShowHintHighlight,true
		[59] [07:14:14] [CTATTextField] Processing style blockOnCorrect,true
		[60] [07:14:14] [CTATTextField] Processing style _tutorComponent,Tutor
		[61] [07:14:14] [CTATTextField] Processing style disabledBackgroundColor,ffffff
		[62] [07:14:14] [CTATTextField] Processing style disabledTextColor,0
		[63] [07:14:14] [CTATTextField] Processing style tutorComponent,Tutor  
*/

/**
 * 
 */
function CTATCheckBox (aDescription,aX,aY,aWidth,aHeight)
{

	CTATTutorableComponent.call(this, 
					  "CTATCheckBox", 
					  "__undefined__",
					  aDescription,
					  aX,
					  aY,
					  aWidth,
					  aHeight);
	
	var checkbox=null;
	var label=null;
	var checkboxContainer=null;

	var pointer=this;

	this.getCheckBox=function getCheckBox()
	{
		return (checkbox);
	};

	this.setCheckBox=function setCheckBox(aCheckBox)
	{
		checkbox=aCheckBox;
	};
					
	this.debug (this.getClassName() + " ("+this.getX()+","+this.getY()+","+this.getWidth()+","+this.getHeight()+")");
	
	this.configFromDescription ();

	this.init=function init ()
	{
		pointer.debug ("init ("+pointer.getName ()+")");
													
		pointer.modifyCSSAttribute("z-index", currentZIndex);
		
		checkboxContainer=document.createElement('div');
		
		checkbox=document.createElement('input');
		checkbox.type='checkbox';
		checkbox.value=pointer.getName ();	    
		checkbox.name=pointer.getComponentGroup (); // might be wrong
		checkbox.setAttribute ('id', ('ctatdiv'+currentIDIndex));
		//component.setAttribute ('onkeypress','return noenter(event)');

		pointer.assignEnabled(true);
				
		if (pointer.getEnabled()==true)
			checkbox.disabled=false;
		else
			checkbox.disabled=true;
				
		pointer.debug ("Final location: " + pointer.getX() + "," + pointer.getY() + " with text: " + pointer.getText());		
		
		//component.innerHTML=text;
		
		pointer.setInitialized(true);
		
		pointer.addComponentReference (pointer,checkbox);
				
		pointer.getDivWrap().appendChild(checkboxContainer);
		
		label = document.createElement('label');
		label.htmlFor = "id";
		label.innerHTML=this.getName ();
		//label.appendChild(document.createTextNode('label'));
		
		pointer.setComponent(checkboxContainer);
		pointer.setLabel(label);
		
		checkboxContainer.appendChild (checkbox);
		checkboxContainer.appendChild (label);
		
	    checkboxContainer.setAttribute('style', pointer.getCSS());
				
		currentZIndex++;
		currentIDIndex++;
		
		pointer.addSafeEventListener ('click', pointer.processClick,checkbox);
		pointer.addSafeEventListener ('focus', pointer.processFocus,checkbox);
	};
	
	this.setText=function setText (aText)
	{		
		pointer.debug ("setText ("+aText+")");
		
		if (checkboxContainer!=null)
		{
			checkbox.value=aText;	
			label.innerHTML=aText;
		}	
		else
			pointer.debug ("Error: component is null, can't set label!");
	};
	
	this.showCorrect=function showCorrect()
	{
		pointer.debug("showCorrect("+correctColor+")");
		
		pointer.setFontColor(correctColor);
		pointer.setEnabled (false);
	};
	
	this.setEnabled=function setEnabled(aValue) 
	{
		if (checkbox==null)
			return;
		
		checkbox.disabled=!aValue;
	};
	
	this.getCheckBoxInput=function getCheckBoxInput ()
	{
		return (label.innerHTML+": "+checkbox.checked);
	};
	
	/**
	 * 
	 */
	this.processSerialization=function processSerialization()
	{
		pointer.debug ("processSerialization()");

		// Process component specific pre-defined styles ...
		
		// Process component custom styles ...		

		this.styles=pointer.getGrDescription().styles;
		
		pointer.debug ("Processing " + this.styles.length + " styles ...");
		
		for (var i=0;i<this.styles.length;i++)
		{
			var aStyle=this.styles [i]; // CTATStyle
			
			if(aStyle.styleName=="labelText")
			{
				pointer.setText(aStyle.styleValue);
			}
		}	
	};	
	
	this.reset=function reset ()
	{
		checkbox.checked=false;
		pointer.setEnabled(true);
		label.setAttribute("style", " ");
	};
}

CTATCheckBox.prototype = Object.create(CTATTutorableComponent.prototype);
CTATCheckBox.prototype.constructor = CTATCheckBox;/**------------------------------------------------------------------------------------
 $Author$ 
 $Date$ 
 $Header$ 
 $Name$ 
 $Locker$ 
 $Log$
 
 -
 License:
 -
 ChangeLog:
 -
 Notes:
 
  Events: click, mousemove, mouseover, mouseout, keyup, keydown, 
  		  focus, blur, select, load

  CSS: http://tutobx.com/post/24806696944/raised-and-pressed-div-using-css
       http://stackoverflow.com/questions/5662178/opacity-of-divs-background-without-affecting-contained-element-in-ie-8
 
  Js:  http://www.quirksmode.org/js/this.html
       http://unschooled.org/2012/03/understanding-javascript-this/   
 
  CTAT:
  
 		[48] [07:14:14] [CTATTextField] Processing style labelTextValue,
		[49] [07:14:14] [CTATTextField] Processing style inspBackgroundColor,ffffff
		[50] [07:14:14] [CTATTextField] Processing style inspBorderColor,999999
		[51] [07:14:14] [CTATTextField] Processing style inspFontName,Arial
		[52] [07:14:14] [CTATTextField] Processing style inspFontSize,20
		[53] [07:14:14] [CTATTextField] Processing style inspFontColor,0
		[54] [07:14:14] [CTATTextField] Processing style inspBold,FALSE
		[55] [07:14:14] [CTATTextField] Processing style inspItalic,FALSE
		[56] [07:14:14] [CTATTextField] Processing style inspUnderline,FALSE
		[57] [07:14:14] [CTATTextField] Processing style inspAlignment,left
		[58] [07:14:14] [CTATTextField] Processing style inspShowHintHighlight,true
		[59] [07:14:14] [CTATTextField] Processing style blockOnCorrect,true
		[60] [07:14:14] [CTATTextField] Processing style _tutorComponent,Tutor
		[61] [07:14:14] [CTATTextField] Processing style disabledBackgroundColor,ffffff
		[62] [07:14:14] [CTATTextField] Processing style disabledTextColor,0
		[63] [07:14:14] [CTATTextField] Processing style tutorComponent,Tutor  
*/

/**
 * 
 */
function CTATComboBox (aDescription,aX,aY,aWidth,aHeight)
{
	CTATTutorableComponent.call(this, 
					  			"CTATComboBox", 
					  			"__undefined__",
					  			aDescription,
					  			aX,
					  			aY,
					  			aWidth,
					  			aHeight);

	var pointer=this;
	var combobox=null;

	this.debug (pointer.getClassName() + " ("+pointer.getX()+","+pointer.getY()+","+pointer.getWidth()+","+pointer.getHeight()+")");

	this.configFromDescription();

	/**
	 * 
	 */
	this.init=function init() 
	{
	    pointer.debug("init (" + pointer.getName() + ")");

	    pointer.addCSSAttribute("z-index", currentZIndex);

	    combobox=document.createElement("select");
	    combobox.name=pointer.getName(); // might be wrong
	    combobox.setAttribute('id', ('ctatdiv' + currentIDIndex));
	    combobox.setAttribute('onkeypress', 'return noenter(event)');
	    //combobox.setAttribute('onchange','processComboSelection();');
	    combobox.onchange=this.processComboSelection;

		pointer.assignEnabled(true);

	    if (pointer.getEnabled()==true)
	        combobox.disabled=false;
	    else
	        combobox.disabled=true;

	    pointer.debug("Final location: " + pointer.getX() + "," + pointer.getY() + " with text: " + pointer.getText());

	    pointer.setInitialized(true);
	    
	    pointer.addComponentReference(pointer, combobox);
	    
	    pointer.setComponent(combobox);

	    pointer.getDivWrap().appendChild(combobox);
	    
		pointer.addCSSAttribute("width", pointer.getWidth());
		pointer.addCSSAttribute("height", pointer.getHeight());

	    pointer.render();

	    currentZIndex++;
	    currentIDIndex++;    	    
	};

	/**
	 * 
	 */
	this.getHTMLComponent=function getHTMLComponent ()
	{
		return (combobox);
	}
	
	/**
	 * 
	 * @param aValue
	 */
	this.addItem=function addItem(aValue) 
	{
	    pointer.debug("addItem (" + aValue + ")");

	    option=document.createElement("option");
	    option.setAttribute("value", aValue);
	    option.innerHTML=aValue;

	    combobox.appendChild(option);
	};	
	
	/**
	 * 
	 */
	this.processSerialization=function processSerialization()
	{
		//useDebugging=true;
		
		pointer.debug ("processSerialization()");

		if (combobox==null)
		{
			pointer.debug ("Error: Internal weirdness: combobox object is null in serialization method");
			return;
		}
		
		// Process component specific pre-defined styles ...
		

		
		// Process component custom styles ...		

		if (this.styles==null)
		{
			pointer.debug ("Error: styles structure is null");
			return;
		}
		
		var i=0;
		var aStyle=null;
		var splitCharacter=',';
				
		pointer.debug ("PRE Processing " + this.styles.length + " styles ...");
		
		for (i=0;i<this.styles.length;i++)
		{
			aStyle=this.styles [i]; // CTATStyle
			
			pointer.debug ("Processing style " + aStyle.styleName + "," + aStyle.styleValue);
			
			if (aStyle.styleName=="SplitCharacter")
			{
				pointer.debug ("Setting SplitCharacter to: " + aStyle.styleValue);
								
				splitCharacter=aStyle.styleValue;
			}	
		}
		
		pointer.debug ("Processing " + this.styles.length + " styles ...");
		
		for (i=0;i<this.styles.length;i++)
		{
			aStyle=this.styles [i]; // CTATStyle
			
			pointer.debug ("Processing style " + aStyle.styleName + "," + aStyle.styleValue);
			
			if (aStyle.styleName=="Labels")
			{
				pointer.debug ("Setting Labels to: " + aStyle.styleValue + " using split character: " + splitCharacter);
								
				var n=aStyle.styleValue.split(splitCharacter); 
				
				for (var j=0;j<n.length;j++)
				{
					try
					{
						var aLabel=n [j];
						
						pointer.debug ("label: " + aLabel);
				
						this.addItem (aLabel);											
					}
					catch (err)
					{
						pointer.debug ("Exception: " + err.message);
					}
				}	
			}	
		}	
		
		//useDebugging=false;
	};
	
	/**
	 * 
	 */
	this.processComboSelection=function processComboSelection ()
	{
		pointer.debug ("processComboSelection ()");

		commShell.gradeComponent (pointer);
	};
}

CTATComboBox.prototype = Object.create(CTATTutorableComponent.prototype);
CTATComboBox.prototype.constructor = CTATComboBox;/**------------------------------------------------------------------------------------
 $Author$ 
 $Date$ 
 $Header$ 
 $Name$ 
 $Locker$ 
 $Log$
 
 -
 License:
 -
 ChangeLog:
 -
 Notes:
 
*/

/**
 * 
 * click
 * mousemove
 * mouseover
 * mouseout
 * keyup
 * keydown
 * focus
 * blur
 * select
 * load
 * 
 */

/**
 * 
 */
function CTATComponent (aClassName,
					    aName,
					    aDescription,
					    aX,
					    aY,
					    aWidth,
					    aHeight)
{
	CTATCompBase.call(this,
					  aClassName,
					  aName,
					  aDescription,
					  aX,
					  aY,
					  aWidth,
					  aHeight);

	this.debug ("CTATComponent" + " ("+this.getX()+","+this.getY()+","+this.getWidth()+","+this.getHeight()+")");

	var moused=false;
	var pointer=this;	
	var images = {};
	var sources = 
	{
		buttonDefault: '',
		buttonHover: '',
		buttonClicked: '',
		buttonDisabled: ''			
	};	
	
	/**
	 * 
	 */
	this.assignImages=function assignImages (imageDefault,imageClicked,imageDisabled,imageHover)
	{
		pointer.debug ("assignImages ()");
		
	    for(src in sources) 
	    {
	    	pointer.debug ("Check: " + sources[src]);	  
	    }
			
		sources.buttonDefault=imageDefault;	
		sources.buttonClicked=imageClicked;
		sources.buttonDisabled=imageDisabled;
		sources.buttonHover=imageHover;
	};
	
	/**
	 *  
	 */
	this.loadImage=function loadImages ()
	{
		pointer.debug ("loadImages ()");
		
	    var loadedImages = 0;
	    var numImages = 0;
	    var src=null;
	    
	    for(src in sources) 
	    {
	    	numImages++;
	    }
	    
	    pointer.debug ("Loading " + numImages + " images ...");
	    
	    for(src in sources) 
	    {
	  		pointer.debug ("Loading: " + sources [src] + " ...");
	    	
	    	images[src] = new Image();
	  	    images[src].src = sources[src];	      
	    	images[src].onload = function() 
	    	{    	  
	    		pointer.debug ("Image " + images[src].src + " loaded");
	    		
	    		if(++loadedImages >= numImages) 
	    		{
	    			pointer.debug ("Images loaded!");
	    			
	    			hasImages=true;
	    			pointer.getGrCanvas().drawTutor ();
	    		}
	    	};	      	      
	    }
	};
	
	/**
	 * 
	 */

	
	
	
	/**
	 * 
	 */
	function click (mouseX,mouseY)
	{		
		pointer.debug ("click ("+mouseX+","+mouseY+")");
		
		setSelected (true);
	}
	
	/**
	 * 
	 */
	function hover (mouseX,mouseY)
	{		
		//debug ("hover ("+mouseX+","+mouseY+")");
						
	}
	
	/**
	 * 
	 */
	function mouseOut (mouseX,mouseY)
	{		
		pointer.debug ("mouseOut ("+mouseX+","+mouseY+")");
				
		setSelected (false);
		
		pointer.getGrCanvas().drawTutor ();
	}
	
	/**
	 * 
	 */
	function mouseIn (mouseX,mouseY)
	{		
		pointer.debug ("mouseIn ("+mouseX+","+mouseY+")");
						
		setSelected (true);
		
		pointer.getGrCanvas().drawTutor ();
	}
	
	/**
	 * 
	 */
	function setSelected (aVal)
	{
		pointer.debug ("setSelected ()");
		
		selected=aVal;
		
		if (selected==true)
		{			
			backgroundColor="#cccccc";
		}
		else
		{
			backgroundColor="#eeeeee";
		}
	}
	
	/**
	 * 
	 */
	this.init=init;
	function init ()
	{
		pointer.debug ("init ()");
		
		loadImages ();
		
		canvas.addEventListener('keydown', function(e) 
		{
			pointer.debug ("keydown ("+getKey (e)+")");
			
		    switch (getKey (e)) 
		    {
		    	// key code for left arrow
	        	case 37:
	        			pointer.debug('left arrow key pressed!');
	        			break;
	        
	        			// key code for right arrow
	        	case 39:
	        			pointer.debug('right arrow key pressed!');
	        			break;
		    }			
		});
		
		canvas.addEventListener('click', function(e) 
		{
			pointer.debug ("click ()");
			
			var mouseX=e.pageX-ctatcanvas.offsetLeft;
			var mouseY=e.pageY-ctatcanvas.offsetTop;
					
			if ((mouseX>pointer.getX()) && (mouseX<(pointer.getX()+pointer.getWidth())) && (mouseY>pointer.getY()) && (mouseY<(pointer.getY()+pointer.getHeight())))
			{
				click (mouseX,mouseY);
						
				pointer.getGrCanvas.drawTutor ();
			}		
		});

		canvas.addEventListener('mousemove', function(e) 
		{				
			//debug ("mousemove");
					
			var mouseX=e.pageX-ctatcanvas.offsetLeft;
			var mouseY=e.pageY-ctatcanvas.offsetTop;
							
			if ((mouseX>pointer.getX()) && (mouseX<(pointer.getX()+pointer.getWidth())) && (mouseY>pointer.getY()) && (mouseY<(pointer.getY()+pointer.getHeight())))
			{
				hover (mouseX,mouseY);
						
				if (moused==false)
				{
					mouseIn (mouseX,mouseY);
							
					moused=true;
				}			
			}	
			else
			{
				if (moused==true)
				{
					mouseOut (mouseX,mouseY);
						
					moused=false;
				}			
			}							
		});		
	}

	/**
	 * 
	 */
	this.CTATInvalidate=function CTATInvalidate ()
	{
		pointer.getGrCanvas.drawTutor ();
	}
}

CTATComponent.prototype = Object.create(CTATCompBase);
CTATComponent.prototype.constructor = CTATComponent;
/**------------------------------------------------------------------------------------
 $Author$ 
 $Date$ 
 $Header$ 
 $Name$ 
 $Locker$ 
 $Log$
 
 -
 License:
 -
 ChangeLog:
 -
 Notes:
  
*/

/**
 * 
 */
function CTATGroupingComponent (aDescription,aX,aY,aWidth,aHeight)
{		
	CTATTutorableComponent.call(this, 
					 			"CTATGroupingComponent", 
					  			"__undefined__",
					  			aDescription,
					  			aX,
					  			aY,
					  			aWidth,
					  			aHeight);

	var pointer=this;
	var targetClip=null;

	/**
	*
	*/
	this.init=function init() 
	{
	    pointer.debug("init (" + pointer.getName() + ")");

	    pointer.addCSSAttribute("z-index", currentZIndex);
		
		pointer.setInitialized (true);

	    currentZIndex++;
	    currentIDIndex++;
	};
		
	/**
	 * 
	 */
	this.processSerialization=function processSerialization()
	{
		pointer.debug ("processSerialization()");
	};

	/**
	*
	*/
	this.postProcess=function postProcess ()
	{
		pointer.debug ("postProcess ()");

		//useDebugging=true;

		// Process component specific pre-defined styles ...
		
		for(var j=0;j<this.parameters.length;j++)
		{
			var aParam=this.parameters [j];
			
			pointer.debug ("Checking style name: " + aParam.paramName);
			
			if (aParam.paramName=="TargetMovieClip")
			{
				pointer.debug ("Loading sub element: " + aParam.paramValue + " ...");
				
				var aClip=findMovieClip (aParam.paramValue);
				
				if (aClip!=null)
				{
					pointer.debug ("Found target movieclip, storing for future reference ...");
					
					targetClip=aClip;
				}
			}
		}	
						
		//useDebugging=false;	
	};
	
	/**
	 * Temporarily disables the component until tempLock(false) is called.
	 * This is for temporarily locking a component with the assumption that the flash
	 * tutor will automatically unlock it. This is to be used when user input is not
	 * wanted for a temporary amount of time (i.e. component already being graded, error
	 * scrim is up, tutor is disconnected). See permlock for action-driven locking.
	 * @param bool to lock or unlock
	 * @return true if perm or temp locked.
	 */
	this.setTempLock=function setTempLock(bool)
	{
		pointer.debug ("setTemplock ("+bool+")");
			 
		if (targetClip!=null)
		{
		
		}
		else
			pointer.debug ("Error: no target MovieClip assigned to this grouping component");			 
			 
		return (true);
	};

	/**
	 * Is a component disabled or not...
	 * @return is comp disabled
	 */		
	this.isLocked=function isLocked()
	{
		return (isPermLocked || isTempLocked);
	};	
	
	/**
	 * Overwrite from CTATCompBase
	 */
	this.move=function move(w,h) 
	{
		pointer.debug ("move ("+w+","+h+")");
				
		if (targetClip!=null)
		{
		
		}
		else
			pointer.debug ("Error: no target MovieClip assigned to this grouping component");
	};	
	
	/**
	 * Overwrite from CTATCompBase
	 */
	this.size=function size(w,h) 
	{
		this.setSize (w,h);
	};	
	
	/**
	 * Overwrite from CTATCompBase
	 */
	this.setSize=function setSize(w,h) 
	{
		pointer.debug ("setSize ("+w+","+h+")");
				
		if (targetClip!=null)
		{
		
		}
		else
			pointer.debug ("Error: no target MovieClip assigned to this grouping component");
	};
	
	/**
	 * Overwrite from CTATCompBase
	 */
	this.SetVisible=function SetVisible (aValue)
	{
		pointer.debug ("SetVisible ("+aValue+")","graphics");
		
		if (targetClip!=null)
		{
		
		}
		else
			pointer.debug ("Error: no target MovieClip assigned to this grouping component");		
	};
	
	/**
	 * Overwrite from CTATCompBase
	 */
	this.setVisible=function setVisible (aValue)
	{
		pointer.debug ("setVisible ("+aValue+")","graphics");
		
		if (targetClip!=null)
		{
		
		}
		else
			pointer.debug ("Error: no target MovieClip assigned to this grouping component");		
	};	
	
	this.configFromDescription ();
}

CTATGroupingComponent.prototype = Object.create(CTATTutorableComponent.prototype);
CTATGroupingComponent.prototype.constructor = CTATGroupingComponent;
/**------------------------------------------------------------------------------------
 $Author$ 
 $Date$ 
 $Header$ 
 $Name$ 
 $Locker$ 
 $Log$
 
 -
 License:
 -
 ChangeLog:
 -
 Notes:
 
  Events: click, mousemove, mouseover, mouseout, keyup, keydown, 
  		  focus, blur, select, load

  CSS: http://tutobx.com/post/24806696944/raised-and-pressed-div-using-css
       http://stackoverflow.com/questions/5662178/opacity-of-divs-background-without-affecting-contained-element-in-ie-8
 
  Js:  http://www.quirksmode.org/js/this.html
       http://unschooled.org/2012/03/understanding-javascript-this/   
 
  CTAT:
  
 		[48] [07:14:14] [CTATTextField] Processing style labelTextValue,
		[49] [07:14:14] [CTATTextField] Processing style inspBackgroundColor,ffffff
		[50] [07:14:14] [CTATTextField] Processing style inspBorderColor,999999
		[51] [07:14:14] [CTATTextField] Processing style inspFontName,Arial
		[52] [07:14:14] [CTATTextField] Processing style inspFontSize,20
		[53] [07:14:14] [CTATTextField] Processing style inspFontColor,0
		[54] [07:14:14] [CTATTextField] Processing style inspBold,FALSE
		[55] [07:14:14] [CTATTextField] Processing style inspItalic,FALSE
		[56] [07:14:14] [CTATTextField] Processing style inspUnderline,FALSE
		[57] [07:14:14] [CTATTextField] Processing style inspAlignment,left
		[58] [07:14:14] [CTATTextField] Processing style inspShowHintHighlight,true
		[59] [07:14:14] [CTATTextField] Processing style blockOnCorrect,true
		[60] [07:14:14] [CTATTextField] Processing style _tutorComponent,Tutor
		[61] [07:14:14] [CTATTextField] Processing style disabledBackgroundColor,ffffff
		[62] [07:14:14] [CTATTextField] Processing style disabledTextColor,0
		[63] [07:14:14] [CTATTextField] Processing style tutorComponent,Tutor   
*/
 
//Holds the components local to the Hint Window.
var localComponents=new Array();
 
//A hard-coded ComponentDescription that will be used for components with no description
var genDesc=new CTATComponentDescription();

genDesc.name="Generic name";
genDesc.styles.push(new CTATStyle("inspBackgroundColor", "#ffffff"));
genDesc.styles.push(new CTATStyle("BorderColor", "#999999"));
genDesc.styles.push(new CTATStyle("FontName", globalFontFamily));
genDesc.styles.push(new CTATStyle("FontSize", globalFontSize));
genDesc.styles.push(new CTATStyle("FontColor", globalFontColor));
genDesc.styles.push(new CTATStyle("FontBold", false));
genDesc.styles.push(new CTATStyle("FontItalic", false));
genDesc.styles.push(new CTATStyle("FontUnderlined", false));
genDesc.styles.push(new CTATStyle("TextAlign", globalAlign));
genDesc.styles.push(new CTATStyle("ShowHintHighlight", false));
genDesc.styles.push(new CTATStyle("blockOnCorrect", false));
genDesc.styles.push(new CTATStyle("disabledBackgroundColor", "#999999"));
genDesc.styles.push(new CTATStyle("disabledTextColor", "#999999"));
genDesc.styles.push(new CTATStyle("tutorComponent", null));

/**
 * 
 */
function CTATHintWindow (aDescription,aX,aY,aWidth,aHeight)
{		
	CTATCompBase.call(this, 
					  "CTATHintWindow", 
					  "__undefined__",
					  aDescription,
					  aX,
					  aY,
					  aWidth,
					  aHeight);	
	var alpha=0.0;
	var pointer=this;
	var hintContent=null;
	var previous=null;
	var next=null;
	var hintwindow=null;
	var outerBorderColor="#408080";
	var borderRoundness=5;
	
	var graphicsTools=null;
	
	this.getAlpha=function getAlpha()
	{
		return (alpha);
	};
	
	this.setAlpha=function setAlpha()
	{
		alpha=aAlpha;
	};
				
	this.debug (this.getClassName() + " ("+this.getX()+","+this.getY()+","+this.getWidth()+","+this.getHeight()+")");
	
	this.configFromDescription ();

	/**
	*
	*/
	this.init=function init() 
	{
	    pointer.debug("init (" + pointer.getName() + ")");

		pointer.setCanvasVisibility("visible");
	    pointer.addCSSAttribute("z-index", currentZIndex);

	    hintwindow=document.createElement('div');

	    hintwindow.setAttribute('id', ('ctatdiv' + currentIDIndex));
	    hintwindow.setAttribute('onkeypress', 'return noenter(event)');
	    pointer.setComponent(hintwindow);

	    pointer.addComponentReference(pointer, hintwindow);

	    pointer.debug("Final location: " + pointer.getX() + "," + pointer.getY() + " with text: " + pointer.getText());

	    pointer.setInitialized(true);
	    
	    graphicsTools=new CTATGraphicsTools(pointer.getSubCanvasCtx());

	    pointer.getDivWrap().appendChild(hintwindow);
		
	    currentZIndex++;
	    currentIDIndex++;
				
	    //> ------------- Hintwindow specific code ---------------------------------------
	    
		genDesc.name="hintcontent";
		genDesc.type="CTATTextField";
				
		hintContent=new CTATTextField (genDesc,aX+4,4,aWidth-8-4,aHeight-21-12);
		//hintContent=new CTATTextField (genDesc,4,4,aWidth-8-4,aHeight-21-12);
		hintContent.setName("hintcontent");
		//hintContent.setInitialized (true);		
		hintContent.wrapComponent(hintwindow);
		hintContent.setCanvasVisibility("hidden");
		hintContent.setAlpha(1.0);
		hintContent.setShowBorder (true);
		hintContent.setBackgroundColor ('#ffffff');
		hintContent.addCSSAttribute("overflow", "auto");
		pointer.addComponent (hintContent);
				
		pointer.debug ("Jumping out of init ()");		
				
		//> ------------- Previous button specific code ----------------------------------		
		
		genDesc.name="previous";
		genDesc.type="CTATImageButton";
				
		previous=new CTATImageButton (genDesc,aX+4,aHeight-24,82,21);
		previous.setName("previous");
		//previous.setInitialized (true);  // Don't call this
		previous.wrapComponent(hintwindow);
		previous.setCanvasVisibility("hidden");
				
		/*
		previous.assignImages (hintPreviousDefault,
							   hintPreviousHover,
							   hintPreviousHover,
							   hintPreviousDisabled);
		*/
							   
		previous.assignImages ("https://qa.pact.cs.cmu.edu/images/skindata/Hint-Previous.png",
							   "https://qa.pact.cs.cmu.edu/images/skindata/Hint-Previous-Hover.png",
							   "https://qa.pact.cs.cmu.edu/images/skindata/Hint-Previous-Hover.png",
							   "https://qa.pact.cs.cmu.edu/images/skindata/Hint-Previous-Disabled.png");							   
							   
		pointer.addComponent (previous);
		//previous.addSafeEventListener ('click',previous.processPreviousButton);
		
		//> ------------- Next specific code ---------------------------------------
		
		genDesc.name="next";
		genDesc.type="CTATImageButton";
		
		next=new CTATImageButton (genDesc,aX+aWidth-82-windowPadding,aHeight-24,82,21);
		next.setName("next");
		//next.setInitialized (true); // Don't call this
		next.wrapComponent(hintwindow);
		next.setCanvasVisibility("hidden");
		
		/*
		next.assignImages (hintNextDefault,
						   hintNextHover,
						   hintNextHover,
						   hintNextDisabled);
		*/
						   
		next.assignImages ("https://qa.pact.cs.cmu.edu/images/skindata/Hint-Next.png",
						   "https://qa.pact.cs.cmu.edu/images/skindata/Hint-Next-Hover.png",
						   "https://qa.pact.cs.cmu.edu/images/skindata/Hint-Next-Hover.png",
						   "https://qa.pact.cs.cmu.edu/images/skindata/Hint-Next-Disabled.png");						   
						   
		pointer.addComponent (next);
		//next.addSafeEventListener ('click',next.processNextButton);
		
	    //> ------------------------------------------------------------------------		
				
		feedbackComponents.push(this);
		
		pointer.debug("Disabling previous and next ...");
		
		previous.setEnabled (false);
		next.setEnabled (false);
	};
	/**
	*
	*/	
	this.processSerialization=function processSerialization()
	{
		pointer.debug ("processSerialization()");

		// Process component specific pre-defined styles ...
		
		pointer.setText (this.label);
		
		// Process component custom styles ...
		this.styles=aDescription.styles;

		this.styles=pointer.getGrDescription().styles;
		
		if (this.styles!=null)
		{		
			pointer.debug ("Processing " + this.styles.length + " styles ...");
			
			for (var i=0;i<this.styles.length;i++)
			{
				var aStyle=this.styles [i]; // CTATStyle

				if(aStyle.styleName=="borderRoundness")
				{
					borderRoundness=aStyle.styleValue;
				}

				if(aStyle.styleName=="OuterBorderColor")
				{
					outerBorderColor=aStyle.styleValue;
				}
			}	
		}	
	};
	
	/**
	*
	*/		
	this.showFeedback=function showFeedback (aMessage)
	{	
		pointer.debug("showFeedback ("+aMessage+")");
				
		hintContent.setText (aMessage);
		
		previous.setEnabled (false);
		next.setEnabled (false);
	};	
	
	/**
	 * 
	 * @param hintList
	 */
	this.showHint=function showHint (hintList)
	{	
		pointer.debug("showHint ()");
		
		hints=hintList;
		hintIndex=0;
		
		previous.setEnabled (false);
		next.setEnabled (false);
		
		hintContent.setText (hints [hintIndex]); // Show first hint
		
		if (hints.length>1)
		{
			next.setEnabled (true);
		}
	};
	
	/**
	 * Not sure if we need to override this
	 * @param aValue
	 */	
	this.setEnabled=function setEnabled(aValue)
	{
		pointer.assignEnabled(aValue);
		
		if (pointer.getComponent()==null)
			return;
		
		/*
		if (pointer.getEnabled()==true)
			pointer.getComponent().contentEditable='true';
		else
			pointer.getComponent().contentEditable='false';
		*/	
	};

	/**
	 * 
	 */
	this.addComponent=function addComponent (aComponent)
	{
		pointer.debug ("addComponent ()");

		localComponents.push (aComponent);

		aComponent.processSerialization ();		
		aComponent.init ();
		
		pointer.debug ("addComponent () done");
	};
	
	/**
	 * 
	 */
	this.goPrevious=function goPrevious ()
	{
		pointer.debug ("addComponent ()");
		
		hintIndex--;
		
		previous.setEnabled (true);
		next.setEnabled (true);
		
		if (hintIndex<=0)
		{
			hintIndex=0;
						
			previous.setEnabled (false);			
		}
		
		hintContent.setText (hints [hintIndex]);
	};
	
	/**
	 * 
	 */
	this.goNext=function goNext ()
	{
		pointer.debug ("goNext ()");
		
		hintIndex++;
		
		previous.setEnabled (true);
		next.setEnabled (true);
		
		if (hintIndex>(hints.length-1))
		{
			hintIndex=(hints.length-1);			
		}	
		
		if (hintIndex>(hints.length-2))
		{
			next.setEnabled (false);
		}
		
		hintContent.setText (hints [hintIndex]);
	};
	
	/**
	*
	*/
	this.drawComponent=function drawComponent()
	{
		//pointer.debug ("drawComponent + ("+pointer.getX()+","+pointer.getY()+","+pointer.getWidth()+","+pointer.getHeight()+")");
		
		//pointer.debug ("drawComponent - ("+xOffset+","+yOffset+","+pointer.getWidth()+","+pointer.getHeight()+")");
		
		graphicsTools.setLineColor(outerBorderColor);

		graphicsTools.drawRoundedRectFilled (1,1,
									   		 pointer.getWidth(),
									   		 pointer.getHeight(),
									  		 5);
	};
}

CTATHintWindow.prototype = Object.create(CTATCompBase.prototype);
CTATHintWindow.prototype.constructor = CTATHintWindow;
/**------------------------------------------------------------------------------------
 $Author$ 
 $Date$ 
 $Header$ 
 $Name$ 
 $Locker$ 
 $Log$
 
 -
 License:
 -
 ChangeLog:
 -
 Notes:
 
  Events: click, mousemove, mouseover, mouseout, keyup, keydown, 
  		  focus, blur, select, load

  CSS: http://tutobx.com/post/24806696944/raised-and-pressed-div-using-css
       http://stackoverflow.com/questions/5662178/opacity-of-divs-background-without-affecting-contained-element-in-ie-8
 
  Js:  http://www.quirksmode.org/js/this.html
       http://unschooled.org/2012/03/understanding-javascript-this/   
 
  CTAT:
  
 		[48] [07:14:14] [CTATTextField] Processing style labelTextValue,
		[49] [07:14:14] [CTATTextField] Processing style inspBackgroundColor,ffffff
		[50] [07:14:14] [CTATTextField] Processing style inspBorderColor,999999
		[51] [07:14:14] [CTATTextField] Processing style inspFontName,Arial
		[52] [07:14:14] [CTATTextField] Processing style inspFontSize,20
		[53] [07:14:14] [CTATTextField] Processing style inspFontColor,0
		[54] [07:14:14] [CTATTextField] Processing style inspBold,FALSE
		[55] [07:14:14] [CTATTextField] Processing style inspItalic,FALSE
		[56] [07:14:14] [CTATTextField] Processing style inspUnderline,FALSE
		[57] [07:14:14] [CTATTextField] Processing style inspAlignment,left
		[58] [07:14:14] [CTATTextField] Processing style inspShowHintHighlight,true
		[59] [07:14:14] [CTATTextField] Processing style blockOnCorrect,true
		[60] [07:14:14] [CTATTextField] Processing style _tutorComponent,Tutor
		[61] [07:14:14] [CTATTextField] Processing style disabledBackgroundColor,ffffff
		[62] [07:14:14] [CTATTextField] Processing style disabledTextColor,0
		[63] [07:14:14] [CTATTextField] Processing style tutorComponent,Tutor  
		
	Then you can also include base64 data in img tags like this

	<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAAWCAIAAABL1vtsAAAY		
*/

/**
 * 
 */
function CTATImageButton (aDescription,aX,aY,aWidth,aHeight)
{			
	CTATImageButtonComponent.call(this, 
					  			  "CTATImageButton",
					  			  "__undefined__",
					  			  aDescription,
					  			  aX,
					  			  aY,
					  			  aWidth,
					  			  aHeight);
		
	var pointer=this;
	var imgButton=null;
					
	this.debug (this.getClassName() + " ("+this.getX()+","+this.getY()+","+this.getWidth()+","+this.getHeight()+")");
	
	this.configFromDescription ();

	this.init=function init() 
	{
	    pointer.debug("init (" + pointer.getName() + ")");
	    
	    imgButton=new Image();
	    imgButton.name=pointer.getName(); // might be wrong
	    imgButton.setAttribute('id', ('ctatdiv' + currentIDIndex));
	    imgButton.setAttribute('onkeypress', 'return noenter(event)');
	    
	    pointer.setComponent(imgButton);

	    pointer.addComponentReference(pointer, imgButton);
	    
	    pointer.debug("Final location: " + pointer.getX() + "," + pointer.getY() + " with text: " + pointer.getText());

	    pointer.setInitialized(true);
	    
	    pointer.getDivWrap().appendChild(imgButton);

		pointer.assignActiveImage(pointer.getDefaultImage());
		
	    pointer.addCSSAttribute("z-index", currentZIndex);
		pointer.addCSSAttribute("width", pointer.getWidth());
		pointer.addCSSAttribute("height", pointer.getHeight());
		pointer.render();

		/*
		pointer.addSafeEventListener ('mouseover', pointer.processMouseOver,imgButton);
		pointer.addSafeEventListener ('mouseout', pointer.processMouseOut,imgButton);
		pointer.addSafeEventListener ('focus', pointer.processFocus,imgButton);
		*/
		
	    currentZIndex++;
	    currentIDIndex++;
	};
	
	/**
	 * 
	 */
	this.processSerialization=function processSerialization()
	{
		pointer.debug ("processSerialization()");

		// Process component specific pre-defined styles ...
		
		pointer.setText (this.label);
		
		// Process component custom styles ...
		this.styles=aDescription.styles;

		this.styles=pointer.getGrDescription().styles;
		
		if (this.styles!=null)
		{		
			pointer.debug ("Processing " + this.styles.length + " styles ...");
			
			for (var i=0;i<this.styles.length;i++)
			{
				var aStyle=this.styles [i]; // CTATStyle
				
				if(aStyle.styleName=="labelText")
				{
					pointer.setText(aStyle.styleValue);
				}
				
				if(aStyle.styleName=="normalName")
				{
					if(aStyle.styleValue.length > 0)
					{
						pointer.setDefaultImage(aStyle.styleValue);
					}
				}
				
				if(aStyle.styleName=="hoverName")
				{
					if(aStyle.styleValue.length > 0)
					{
						pointer.setHoverImage(aStyle.styleValue);
					}
				}
				
				if(aStyle.styleName=="clickName")
				{
					if(aStyle.styleValue.length > 0)
					{
						pointer.setClickedImage(aStyle.styleValue);
					}
				}
				
				if(aStyle.styleName=="disabledName")
				{
					if(aStyle.styleValue.length > 0)
					{
						pointer.setDisabledImage(aStyle.styleValue);
					}
				}
				
				if(aStyle.styleName=="Scaling")
				{
					pointer.setScaling(aStyle.styleValue);
				}
			}	
		}	
	};	
}

CTATImageButton.prototype = Object.create(CTATImageButtonComponent.prototype);
CTATImageButton.prototype.constructor = CTATImageButton;
function CTATPlayButton()
{
	CTATBase.call(this, "CTATPlayButton", "__undefined__");
	
	//Enumerate the different parts of the overall component
	var playButton=null;
	var playCircle=null;
	var playTriangle=null;
	var playBackground=null;
	
	//This is where we will create the object
	var playDiv=null;
	
	//Event handlers for the play button
	function playOver()
	{
		playTriangle.setFillColor("black");
		playTriangle.drawTriangleFilled();
		
		playCircle.setFillColor("rgb(36, 85, 00)");
		playCircle.drawCircleFilled();
	}
	
	function playOut()
	{
		playTriangle.setFillColor("white");
		playTriangle.drawTriangleFilled();
		
		playCircle.setFillColor("green");
		playCircle.drawCircleFilled();
	}
	
	function playTutor()
	{
		playButton.removeComponent();
		getSafeElementById('container').removeChild(playDiv);
		initTutor ();
	}
	
	function init()
	{
		var mainCanvas=getSafeElementById("main-canvas");
	
		playDiv=document.createElement("div");
		playDiv.id='ctatdivPlayTutor';
		
		//These are not real div attributes. They are here for ease of access.
		playDiv.width=mainCanvas.width;
		playDiv.height=mainCanvas.height;
		
		playDiv.setAttribute("style", "width: "+mainCanvas.width+"px; height: "+mainCanvas.height+
									  "px; left: "+0+"px; top: "+0+"px; position:absolute");
		getSafeElementById('container').appendChild(playDiv);
	}
	
	function drawPlayButton()
	{
		playButton=new CTATCanvasComponent();
		
		var playCircleRadius=playDiv.height/3;
		
		playBackground=new CTATShape("PlayTutor",
									 "play background",
									 0, 0, playDiv.width+1, playDiv.height+1);
									 
		playBackground.addPoint(0, 0);
									 
		playBackground.setFillColor("rgb(66, 0, 66)");
		playBackground.drawRectangleFilled();

		playCircle=new CTATShape("PlayTutor", 
								 "play circle",
								 ((playDiv.width/2)-playCircleRadius),
								 ((playDiv.height/2)-playCircleRadius), 
								 playCircleRadius*2,
								 playCircleRadius*2);

		playCircle.addPoint(0, 0);
		
		playCircle.setFillColor("green");
		playCircle.setRadius(playCircleRadius);
		playCircle.drawCircleFilled();
		
		var scale=1/4;
		var offset=5;
		
		playTriangle=new CTATShape("PlayTutor",
								   "play triangle",
								   playCircle.getXOffset()+(playCircle.getWidth()*scale)-offset,
								   playCircle.getYOffset()+(playCircle.getHeight()*scale)-offset,
								   playCircle.getWidth()-(playCircle.getWidth()*scale),
								   playCircle.getHeight()*(3/5));
								   
		playTriangle.addPoint(0, 0);
		playTriangle.addPoint(0, playTriangle.getHeight());
		playTriangle.addPoint(playTriangle.getWidth(), playTriangle.getHeight()/2);
								   
		playTriangle.setFillColor("white");
		playTriangle.drawTriangleFilled();
		
		playButton.addShape(playBackground);
		playButton.addShape(playCircle);
		playButton.addShape(playTriangle);
		
		playCircle.addEventListener('mouseover', playOver);
		playCircle.addEventListener('mouseout', playOut);
		playTriangle.addEventListener('mouseover', playOver);
		playTriangle.addEventListener('mouseout', playOut);
	
		playTriangle.addEventListener('click', playTutor);
		playCircle.addEventListener('click', playTutor);
	}
	
	init();
	drawPlayButton();
}

CTATPlayButton.prototype = Object.create(CTATBase.prototype);
CTATPlayButton.prototype.constructor = CTATPlayButton;/**------------------------------------------------------------------------------------
 $Author$ 
 $Date$ 
 $Header$ 
 $Name$ 
 $Locker$ 
 $Log$
 
 -
 License:
 -
 ChangeLog:
 -
 Notes:
 
*/

function CTATRadioButton(aDescription, aX, aY, aWidth, aHeight)
{
	CTATTutorableComponent.call(this, 
					  			"CTATRadioButton", 
					  			"__undefined__",
					  			aDescription,
					  			aX,
					  			aY,
					  			aWidth,
					  			aHeight);
					  
	this.debug (this.getClassName() + " ("+this.getX()+","+this.getY()+","+this.getWidth()+","+this.getHeight()+")");

	this.configFromDescription();
	
	var pointer=this;
	var radiobutton=null;
	var radioContainer=null;
	var label;
	var radioGroup;
	var radioText="";
	
	this.init=function init()
	{
		pointer.debug ("init ("+pointer.getName ()+")");
		
		pointer.addCSSAttribute("z-index", currentZIndex);
		
		radioContainer=document.createElement('div');

		radiobutton=document.createElement('input');
		radiobutton.type='radio';
		radiobutton.value=pointer.getName();
		radiobutton.name=pointer.getComponentGroup();
		radiobutton.setAttribute('id', ('ctatdiv'+currentIDIndex));

		pointer.assignEnabled(true);
		
		if (pointer.getEnabled()==true)
			radiobutton.disabled=false;
		else
			radiobutton.disabled=true;
				
		pointer.debug ("Final location: " + pointer.getX() + "," + pointer.getY() + " with text: " + pointer.getText());
		
		pointer.setInitialized(true);
		
		pointer.addComponentReference(pointer, radioContainer);
				
		pointer.getDivWrap().appendChild(radioContainer);
		
		label = document.createElement('label');
		label.htmlFor = "id";
		label.innerHTML=pointer.getText ();
		//label.appendChild(document.createTextNode('label'));
		
		pointer.setComponent(radioContainer);
		pointer.setLabel(label);
		
		radioContainer.appendChild (radiobutton);
		radioContainer.appendChild (label);
		
	    pointer.render ();
				
		currentZIndex++;
		currentIDIndex++;

		pointer.addSafeEventListener ('click',pointer.processClick,radiobutton);
		pointer.addSafeEventListener ('focus', pointer.processFocus,radiobutton);			
	};
	
	this.setText=function setText (aText)
	{		
		pointer.debug ("setText ("+aText+")");
		
		radioText=aText;
		
		if (radioContainer!=null)
		{
			radiobutton.value=aText;	
			label.innerHTML=aText;
		}
	};
	
	this.getText=function getText ()
	{
		return (radioText);
	}
	
	this.showCorrect=function showCorrect()
	{
		pointer.debug("showCorrect("+correctColor+")");
		
		pointer.setFontColor(correctColor);
		pointer.setEnabled (false);
	};
	
	/**
	 * Radiobutton groups are disabled when they are correct. We need to
	 * disable them when we received a CorrectAction. The action parameter
	 * is needed for this case, and is otherwise optional.
	 */
	this.setEnabled=function setEnabled(aValue, action) 
	{
		if (action==undefined)
		{
			if (radiobutton==null)
				return;
		
			radiobutton.disabled=!aValue;
		}
		
		else if (action=="CorrectAction")
		{
			for (var i=0;i<components.length;i++)
			{
				var aDesc=components [i];
				
				if(aDesc.groupName=="")
				{
					pointer.setEnabled(false);
				}
			}
		}
	};
	
	this.setChecked=function setChecked(aValue)
	{
		if (radiobutton==null)
			return;
		
		radiobutton.checked=aValue;
	};
	
	this.getChecked=function getChecked()
	{
		return (radiobutton.checked);
	};
	
	//SAI Input
	this.getRadioInput=function getRadioInput ()
	{
		return (pointer.getName()+": "+label.innerHTML);
	};
	
	/**
	 * 
	 */
	this.processSerialization=function processSerialization()
	{
		pointer.debug ("processSerialization()");

		// Process component specific pre-defined styles ...
		// Process component custom styles ...		

		this.styles=pointer.getGrDescription().styles;
		
		pointer.debug ("Processing " + this.styles.length + " styles ...");
		
		for (var i=0;i<this.styles.length;i++)
		{
			var aStyle=this.styles [i]; // CTATStyle
			
			if(aStyle.styleName=="buttonLabel")
			{
				pointer.setText(aStyle.styleValue);
			}
		}	
	};	
	
	this.reset=function reset ()
	{
		pointer.debug (" reset ( " + pointer.getName () + ")");

		radiobutton.checked=false;
		pointer.setEnabled(true);
		label.setAttribute("style", " ");
	};
	
	/**
	 * TPA 
	 */
	 this.UpdateRadioButton=function UpdateRadioButton ()
	 {
	 	pointer.debug ("UpdateRadioButton ()");
	 };
}

CTATRadioButton.prototype = Object.create(CTATTutorableComponent.prototype);
CTATRadioButton.prototype.constructor = CTATRadioButton;/**------------------------------------------------------------------------------------
 $Author$ 
 $Date$ 
 $Header$ 
 $Name$ 
 $Locker$ 
 $Log$
 
 -
 License:
 -
 ChangeLog:
 -
 Notes:
  
*/

/**
 * 
 */
function CTATScrollPaneComponent (aDescription,aX,aY,aWidth,aHeight)
{		
	CTATTutorableComponent.call(this, 
					 			"CTATScrollPaneComponent", 
					  			"__undefined__",
					  			aDescription,
					  			aX,
					  			aY,
					  			aWidth,
					  			aHeight);

	var hints=new Array ();
	var alpha=0.0;
	var pointer=this;
	var scrollpane=null;

	var skillSet=new Array ();
	
	/**
	*
	*/
	this.getAlpha=function getAlpha()
	{
		return (alpha);
	};
	/**
	*
	*/
	this.setAlpha=function setAlpha()
	{
		alpha=aAlpha;
	};
	/**
	*
	*/
	this.init=function init() 
	{
	    pointer.debug("init (" + pointer.getName() + ")");

	    pointer.addCSSAttribute("z-index", currentZIndex);
		//pointer.addCSSAttribute("overflow-y","scroll");

	    pointer.debug("Final location: " + pointer.getX() + "," + pointer.getY() + " with text: " + pointer.getText());
		
		pointer.setInitialized (true);

	    pointer.debug("Final location: " + pointer.getX() + "," + pointer.getY() + " with text: " + pointer.getText());		

	    currentZIndex++;
	    currentIDIndex++;
	};
		
	/**
	 * 
	 */
	this.processSerialization=function processSerialization()
	{
		pointer.debug ("processSerialization()");
	};

	/**
	*
	*/
	this.postProcess=function postProcess ()
	{
		pointer.debug ("postProcess ()");

		//useDebugging=true;

		// Process component specific pre-defined styles ...
		
		for(var j=0;j<this.parameters.length;j++)
		{
			var aParam=this.parameters [j];
			
			pointer.debug ("Checking style name: " + aParam.paramName);
			
			if (aParam.paramName=="TargetMovieClip")
			{
				pointer.debug ("Loading sub element: " + aParam.paramValue + " ...");
				
				var aClip=findMovieClip (aParam.paramValue);
				
				if (aClip!=null)
				{
					pointer.debug ("Found target movieclip, temporarily removing ...");

					if (aClip.getDivWrapper ().parentNode!=null)
					{
						try
						{
							aClip.getDivWrapper ().parentNode.removeChild (aClip.getDivWrapper ());
						}
						catch (err)
						{
							ctatscrim.errorScrimUp (err.message);
							return;
						}
					
						// First let's remove the canvas for this component, it is only in the way
						
						pointer.getSubCanvas ().parentNode.removeChild (pointer.getSubCanvas ());
					
						pointer.getDivWrap().setAttribute('id', 'scrollsubdiv');
						pointer.getDivWrap().setAttribute("style", "overflow-y: scroll; border: 4px; position: absolute; visibility: block; left:"+pointer.getX ()+"px; top: "+pointer.getY ()+"px; width:"+pointer.getWidth ()+"px; height: "+pointer.getHeight ()+"px; z-index:"+pointer.getCanvasZIndex ()+";");
					
						pointer.debug ("Adding ...");
																					
						pointer.getDivWrap().appendChild (aClip.getDivWrapper ());
						
						var index=pointer.getCanvasZIndex (); // slightly wrong because the canvas doesn't exist anymore
												
						index++;

						var xDiff=aClip.getDivWrapper ().style.left;
						var yDiff=aClip.getDivWrapper ().style.top;
						
						aClip.getDivWrapper ().style.left="0px";
						aClip.getDivWrapper ().style.top="0px";

						pointer.debug ("Moving canvas from: " + xDiff + "," + yDiff + " to: 0,0");
																																										
						var childNodes = aClip.getDivWrapper ().childNodes;

						for(var i=0; i<childNodes.length; i++) 
						{
							var aNode=childNodes[i];
							
							index++;							
						}
					}				
				}
				else
					pointer.debug ("Unable to find the target movieclip to reparent the content from");
			}
		}
		
		//useDebugging=false;	
	};
	
	this.configFromDescription ();
}

CTATScrollPaneComponent.prototype = Object.create(CTATTutorableComponent.prototype);
CTATScrollPaneComponent.prototype.constructor = CTATScrollPaneComponent;
/**------------------------------------------------------------------------------------
 $Author$ 
 $Date$ 
 $Header$ 
 $Name$ 
 $Locker$ 
 $Log$
 
 -
 License:
 -
 ChangeLog:
 -
 Notes:
 
*/

/**
 * 
 */
function CTATSkill ()
{
	var skillName= "";
	var displayName= "";
	var category= "";
	var modelName= "";
	var level= 0;
	var description= "";
	var touched= false;

	var pGuess= "";
	var pSlip= "";
	var pKnown= "";
	var pLearn= "";
		
	var label=null;
	
	/**
	 * Sets the Skill's name.
	 * @param	n	The skill's name.
	 */
	this.setSkillName=function setSkillName(n)
	{
		skillName = n;
	};
	
	/**
	 * Sets the skill's display name.
	 * @param	n	If a skill does not have a display new it will use its name instead.
	 */
	this.setDisplayName=function setDisplayName(n) 
	{
		displayName = n;
	};
	
	/**
	 * Sets the skill's model
	 * @param	model	The model that the skill belongs to.
	 */
	this.setModelName=function setModelName(model) 
	{
		modelName = model;
	}
	
	/**
	 * Sets the skill's category.
	 * @param	cat	The category that the skill belongs to.
	 */
	this.setCategory=function setCategory(cat) 
	{
		category = cat;
	};
	
	/**
	 * Sets the current profficiency level of the skill.
	 * @param	lvl	The level of the skill.
	 */
	this.setLevel=function setLevel(lvl) 
	{
		if (isNaN (lvl)==true)
		{
			debug ("Error: attempting to set a level to NaN");
			return;				
		}
		
		level = lvl;
		
		this.setPKnown(String(level));
	};
	
	/**
	 * Sets a long ofrm description of the skill.
	 * @param	desc	The Skill's long form description.
	 */
	this.setDescription=function setDescription(desc) 
	{
		description = desc;
	};
	
	/**
	 * Returns the skill's name.
	 * @return	The skill's name.
	 */
	this.getSkillName=function getSkillName() 
	{
		return skillName;
	};
	
	/**
	 * Returns the skill's displayName.
	 * <p>If a skill has no display name it will use its given name.</p>
	 * @return	The skill's display name, or its given name if it has none.
	 */	
	this.getDisplayName=function getDisplayName() 
	{
		//return (hasDisplayName() ?  name : displayName);
		return (displayName);
	};
	
	/**
	 * Returns whether or not the skill has a displayName.
	 * @return	<code>true</code> if the skill has a display name, <code>false</code> otherwise.
	 */
	this.hasDisplayName=function hasDisplayName() 
	{
		return (displayName != "" && displayName != null);
	};
	
	/**
	 * Returns the name of skill's model.
	 * @return	The skill's model.
	 */
	this.getModelName=function getModelName() 
	{
		return modelName;
	};
	
	/**
	 * Returns whether or not the skill has a category value.
	 * @return	<code>true</code> if the skill has a category, <code>false</code> otherwise.
	 */
	this.hasCategory=function hasCategory() 
	{
		return category != "";
	};
	
	/**
	 * Returns whether or not the skill has a model name.
	 * @return	<code>true</code> if the skill has a model, <code>false</code> otherwise.
	 */
	this.hasModelName=function hasModelName() 
	{
		return modelName != "";
	};
	
	/**
	 * Returns the category of the skill.
	 * @return	The skill's category.
	 */
	this.getCategory=function getCategory() 
	{
		return category;
	};
	
	/**
	 * Returns the current level of the skill.
	 * @return	The skill's level.
	 */
	this.getLevel=function getLevel() 
	{
		return level;
	};
	
	/**
	 * Returns the long form description of the skill.
	 * @return	The skill's description.
	 */
	this.getDescription=function getDescription()	
	{
		return description;
	};
	
	/**
	 * @private
	 * @param	touch
	 */
	this.setTouched=function setTouched(touch) 
	{
		touched = touch
	};
	
	/**
	 * @private
	 * @return
	 */
	this.getTouched=function getTouched() 
	{
		return touched;
	};
	
	/**
	 * Returns and empty string?
	 */		
	this.toXMLString=function toXMLString() 
	{
		return "";
	};
	
	/**
	 * Returns an xml string of the skill formatted as it is expected to be in a SetPreferences message.
	 * @return	An XML String of the skill.
	 */
	this.toSetPreferencesXMLString=function toSetPreferencesXMLString() 
	{
		var string = '<skill label="' + displayName + '" pSlip="' + pSlip + '" description="' + description;
		string += '" pKnown="' +pKnown + '" category="' + category + '" pLearn="' + pLearn + '" name="' + skillName + '" pGuess="' + pGuess + '" />';
		
		return string;
	};
	/**
	 *
	 */		
	this.setPGuess=function setPGuess(guess)
	{ 
		pGuess = guess; 
	};
	/**
	 *
	 */		
	this.getPGuess=function getPGuess()
	{ 
		return pGuess; 
	};
	/**
	 *
	 */		
	this.setPSlip=function setPSlip(slip) 
	{
		pSlip = slip; 
	};
	/**
	 *
	 */		
	this.getPSlip=function getPSlip()
	{ 
		return pSlip; 
	};
	/**
	 *
	 */				
	this.setPLearn=function setPLearn(learn)
	{ 
		pLearn = learn; 
	};
	/**
	 *
	 */		
	this.getPLearn=function getPLearn()
	{ 
		return pLearn; 
	};
	/**
	 *
	 */		
	this.setPKnown=function setPKnown(known)
	{ 
		pKnown = known; 
	};
	/**
	 *
	 */		
	this.getPKnown=function getPKnown()
	{ 
		return pKnown; 
	};	
}
/**------------------------------------------------------------------------------------
 $Author$ 
 $Date$ 
 $Header$ 
 $Name$ 
 $Locker$ 
 $Log$
 
 -
 License:
 -
 ChangeLog:
 -
 Notes:
 
The AssociatedRules msg looks like this; the delimiters in the <Skills> values are backquotes:

<?xml version="1.0" encoding="UTF-8"?>
<message>
 <verb>SendNoteProperty</verb>
 <properties>
  <MessageType>AssociatedRules</MessageType>
  <Indicator>Correct</Indicator>
  <Selection><value>firstDenConv</value></Selection>
  <Action><value>UpdateTextArea</value></Action>
  <Input><value>6</value></Input>
  <StudentSelection><value>firstDenConv</value></StudentSelection>
  <StudentAction><value>UpdateTextArea</value></StudentAction>
  <StudentInput><value>6</value></StudentInput>
  <Actor>Student</Actor>
  <Rules>
    <value>determine-lcd fraction-addition</value>
    <value>multiply-denominators fraction-addition</value>
  </Rules>
  <Skills>
    <value>multiply-denominators fraction-addition`0.50609756`0</value>
    <value>determine-lcd fraction-addition`0.50609756`0</value>
  </Skills>
  <skillBarDelimiter>`</skillBarDelimiter>
  <StepID>1</StepID>
  <tool_selection>firstDenConv</tool_selection>
  <transaction_id>445F8E49FAF09641</transaction_id>
  <LogAsResult>true</LogAsResult>
  <end_of_transaction>true</end_of_transaction>
 </properties>
</message> 
 
*/

/**
 * 
 */
function CTATSkillSet ()
{	
	CTATBase.call(this, "CTATSkillSet","skills");
	
	this.skillSet=new Array ();
	
	/**
	*
	*/
	this.fromXMLString=function fromXMLString (aSkills)
	{
		this.debug("fromXMLString ()");
		
		if (aSkills==null)
		{		
			this.debug ("Warning: skill object is null");
			return;
		}
		
		if (aSkills=="")
		{
			this.debug ("Info: empty skill string provided, bump");
			return;
		}
				
		//useDebugging=true;
		
		//this.debug ("Raw: " + aSkills);		
		
		var decoded=decodeURIComponent(aSkills.replace(/\+/g,  " "));
		
		//this.debug ("Decoded: " + decoded);

		var valuePattern= new RegExp ("/<value>.+<\/value>");
		
		if (valuePattern.exec(decoded)!=null)
		{
			//fromXMLData (null,decoded);
			parseByValue (decoded);
		}
		else
		{
			var parser=new CTATXML ();
			var root=parser.parseXML (decoded);
		
			this.parseByAttributes(root,decoded);
		}		
				
		//useDebugging=false;
		
		this.debug("fromXMLString () done");
	};

	/**
	 * Parses an XML String into a SkillSet. 
	 * <p>This method is written to support both of the possible configurations of a skill based XML String.
	 * One is of the form &#60;Skills&#62;&#60;value&#62;<i>name</i> <i>category</i>`<i>level</i>`<i>mastery</i>`<i>DisplayName</i>&#60;/value&#62;&#60;/Skills&#62;.
	 * The other is of the form &#60;Skills&#62;&#60;skill name="<i>name</i> <i>category</i>" level="<i>level</i>" mastery="<i>mastery</i>" description="<i>description</i>" label="displayName"/&#62;&#60;/Skills&#62;
	 * There is capability to deal with different capitalization of "value" and "Skill" but the two presented are the prefered formating.</p>
	 * @param	xml	An XMLList containing skills of either of the accepted formats.
	 */
	this.fromXMLData=function fromXMLData (xml,raw)
	{
		this.debug("fromXMLData ()");
			
		// this is a way better parsing system than what we used before.
		
		var valuePattern= new RegExp ("/<value>.+<\/value>");
		
		if (valuePattern.exec(raw)!=null)
		{
			this.parseByValue(raw);
		}
		else
		{
			this.parseByAttributes(xml);
		}
		
		this.debug("fromXMLData () done");
	};
	/**
	 *
	 */
	this.parseByValue=function parseByValue(aSkills) 
	{
		//this.debug("parseByValue("+aSkills.nodeName+" -> " + aSkills.childNodes.length + ")");
		this.debug("parseByValue()");
		
		if (aSkills==null)
		{
			pointer.debug ("Error: aSkills is null");
			return;
		}
				
		var slist=aSkills.childNodes;
		
		var parser=new CTATXML ();
		
		for (var k=0;k<slist.length;k++)
		{
			var testSkill=slist [k];
			
			var skillString=parser.getNodeTextValue (testSkill);
			
			var aSkill = skillString.split("`");
			
			var pair=aSkill[0].split(" ");
			
			//I have seen cases where skills don't come with a display name, hence the first condition.
			if (aSkill.length==4)
				this.addSkill(pair[0], aSkill[1], aSkill[2], aSkill[3], aSkill[3], pair[1]);
			else
				this.addSkill(pair[0], aSkill[1], aSkill[2], aSkill[3], aSkill[4], pair[1]);			
		}
	};
	
	/**
	 * <skill opportunitycount="2" name="determine-lcd" label="determine-lcd" category="main" pknown="0.25"/>
	 */		
	this.parseByAttributes=function parseByAttributes(aSkills) 
	{
		this.debug("parseByAttributes()");
		
		if (aSkills==null)
		{
			pointer.debug ("Error: aSkills is null");
			return;
		}		
								
		var x=aSkills.childNodes;
		
		if (x==null)
		{
			this.debug ("Error: list of skill xml elements is null");
			return;		
		}
		
		for (var i=0;i<x.length;i++)
		{
			var elem=x [i];
			
			if (elem.nodeName=="Skill")
			{
				this.debug ("Parsing node ("+i+"): " + elem.nodeName + " -> " + elem.nodeValue)
			
				this.addSkill (elem.attributes.getNamedItem("name").value,
							   elem.attributes.getNamedItem("pKnown").value,
							   .95,
							   elem.attributes.getNamedItem("label").value,
							   elem.attributes.getNamedItem("label").value,
							   elem.attributes.getNamedItem("category").value,
							   elem.attributes.getNamedItem("pGuess").value,
							   elem.attributes.getNamedItem("pLearn").value,
							   elem.attributes.getNamedItem("pSlip").value);			
			}	
		}			
	};
	/**
	 * Returns the current list of skills within the set.
	 * @return	The current set of skills.
	 */
	this.getSkillSet=function getSkillSet() 
	{
		return this.skillSet;
	};
	
	/**
	 * Returns the number of skills in the collection.
	 */
	this.getSize=function getSize() 
	{
		return this.skillSet.length;
	};		
	/**
	 * Adds a CTATSkill to the SkillSet.
	 * <p>If a skill by the same name already exists within the set then the values will be updated with those provided.</p>
	 * @param	aName			The name of the skill
	 * @param	aLevel			The level of the skill
	 * @param	aMastery		The master level for the skill
	 * @param	aDescription	The long form description of the skill
	 * @param	aDisplayName	The display name of the skill
	 * @param	aCategory		The category of the skill
	 * @param	pGuess			The pGuess value of the skill
	 * @param	pLearn			The pLearn value of the skill
	 * @param	pSlip			The pSlip value of the skill
	 * @return	The CTATSkill that was added.
	 */
	this.addSkill=function addSkill(aName, 
							 		aLevel, 
							 		aMastery, 
							 		aDescription, 
							 		aDisplayName, 
							 		aCategory,
							 		pGuess, 
							 		pLearn, 
							 		pSlip) 
	{
		this.debug("addSkill() name = " + aName + " level = " +aLevel + " mastery = " +aMastery + " aDescription = " + aDescription
				+ " adisplayName = " + aDisplayName + " aCategory = " + aCategory + " pguess= " + pGuess +" plearn = " + pLearn
				+ " pslip = " + pSlip);
		
		//var newSkill=new CTATSkill ();
		
		var newSkill=this.setSkillLevel (aName,aLevel,aMastery);
		
		this.debug ("Configuring " + newSkill.getDisplayName ());
		
		if(aDescription!="" && aDescription!=null)
			newSkill.setDescription(aDescription);
			
		if(aDisplayName!="" && aDisplayName!=null)
			newSkill.setDisplayName(aDisplayName);
			
		if(aCategory!="" && aCategory!=null)
			newSkill.setCategory(aCategory);
		
		if(pGuess != "") 
		{
			newSkill.setPGuess(pGuess);
			newSkill.setPLearn(pLearn);
			newSkill.setPSlip(pSlip);
		}
		
		return newSkill;
	};	
	
	/**
	 * Searched the list for a skill of the given name and updates its level.
	 * <p>If not skill by that name exists it will create a new Skill</p>
	 * @param	aName		The name of skill
	 * @param	aLevel		The level of the skill
	 * @param	aMastery	The mastery level of the skill
	 * @return	The updated CTATSkill, or a new one if it did not exist.
	 */
	this.setSkillLevel=function setSkillLevel(aName, aLevel, aMastery) 
	{
		this.debug("setSkillLevel ("+aName+")");
		
		var skill=this.getSkill (aName);
		
		if (skill==null) 
		{
			this.debug ("Skill not found, creating new one ...");
			
			skill = new CTATSkill ();
			skill.setSkillName(aName);
			
			if (aMastery == 1)
				skill.setLevel(1);
			else
				skill.setLevel(aLevel);
			
			this.skillSet.push(skill);
		}
		else 
		{
			this.debug ("Skill found, adjusting ...");
			
			if (aMastery == 1)
				skill.setLevel(1);
			else
				skill.setLevel(aLevel);			
		}
		
		skill.setTouched(true);
		
		return skill;
	};
	
	/**
	 * Returns a skill by name
	 * @param	aName	The name of a skill
	 * @return	The CTATSkill in the CTATSkillSet with the desired name
	 */
	this.getSkill=function getSkill(aName) 
	{
		this.debug ("getSkill ("+aName+") -> " + this.skillSet.length);
		
		if (aName == null || aName == "") 
		{
			return null;
		}
		
		for (var i=0;i<this.skillSet.length;i++)
		{
			var skill=this.skillSet [i];
			
			if (skill.getSkillName ()==aName)
			{
				this.debug ("Returning: " + i);
				return (skill);
			}	
		}		
				
		return null;
	};
	/**
	 * Returns the skillLevel of a given skill. 
	 * <p>If the skill does not exist in the SkillSet it will return <code>-Infinity</code>.</p>
	 * @param	aName	The name of a skill
	 * @return	The level of the Skill, or <code>-Infinity</code> if the skill is not in the set.
	 */
	this.getSkillLevel=function getSkillLevel (aName) 
	{
		if (aName == null || aName == "")
			return -1;
		
		for (var skill in this.skillSet)
		{
			if (skill.getSkillName ()==aName)
				return (skill.getLevel ());
		}
				
		return -1;
	};
	
	/**
	 * Returns all of the skills that have been changed since the last time untouchSkills was called.
	 * @return	Returns a subset of skills that were changed since the last untouchSkills was called.
	 */
	this.getTouched=function getTouched() 
	{
		this.debug ("getTouched ()");
		
		var touchedList=new Array ();
		
		for (var i=0;i<this.skillSet.length;i++)
		{
			var skill=this.skillSet [i];
			
			if (skill.getTouched ()==true)
			{
				this.debug ("Adding touched skill: " + skill.getSkillName());
			
				touchedList.push (skill);
			}
		}		
				
		return (touchedList);
	};
	
	/**
	 * Reset the touched status of all the skills in the set.
	 */
	this.untouchSkills=function untouchSkills() 
	{
		this.debug ("untouchSkills ()");
		
		for (var i=0;i<this.skillSet.length;i++)
		{
			var skill=this.skillSet [i];
			
			skill.setTouched (false);
		}					
	};
	
	/**
	 * Returns an XMLString of the entire skillset in the format expected by a SetPreferences message
	 * @return	An XMLString of the entire skillSet.
	 */
	this.toSetPreferencesXMLString=function toSetPreferencesXMLString() 
	{
		var message="<skills>";
		
		for (var i=0;i<this.skillSet.length;i++)
		{
			var skill=this.skillSet [i];
			
			message += skill.toSetPreferencesXMLString();
		}			
				
		message += "</skills>";
		
		return message;		
	};
}

CTATSkillSet.prototype = Object.create(CTATBase.prototype);
CTATSkillSet.prototype.constructor = CTATSkillSet;
/**------------------------------------------------------------------------------------
*
*/

/**
 * 
 */
function CTATSkillWindow (aDescription,aX,aY,aWidth,aHeight)
{		
	CTATCompBase.call(this, 
					  "CTATSkillWindow", 
					  "__undefined__",
					  aDescription,
					  aX,
					  aY,
					  aWidth,
					  aHeight);

	var hints=new Array ();
	var alpha=0.0;
	var pointer=this;
	var graphicsTools=null;
	
	// Skill window specific variables
	
	var marginX		   =6;
	var marginY		   =6;
	var barDistance	   =4;
	var barHeight	   =15;
	var barMaxX		   =150;
	var borderRoundness =5;
	
	var spThreshold	=0.95;
	
	var inspSkillBarBorderColor   ="#cccccc";		
	var inspSkillBarColor         ="#ffffcc";		
	var inspSkillBarThresholdColor="#66cc33";		
	var inspSkillVerticalStroke   =true;
	var outerBorderColor="#408080";

	var skillwindow=null;

	this.getAlpha=function getAlpha()
	{
		return (alpha);
	};
	
	this.setAlpha=function setAlpha()
	{
		alpha=aAlpha;
	};
				
	this.debug (this.getClassName() + " ("+this.getX()+","+this.getY()+","+this.getWidth()+","+this.getHeight()+")");
	
	this.configFromDescription ();

	this.init=function init() 
	{
	    pointer.debug("init (" + pointer.getName() + ")");
	    
	    pointer.setCanvasVisibility("visible");

	    pointer.debug("Final location: " + pointer.getX() + "," + pointer.getY() + " with text: " + pointer.getText());

	    pointer.setInitialized(true);
	    
		graphicsTools=new CTATGraphicsTools(pointer.getSubCanvasCtx());

	    currentZIndex++;
	    currentIDIndex++;
		
		this.drawComponent ();		
	};
		
	/**
	 * 
	 */
	this.assignSkillSet=function assignSkillSet (aSkillSet)
	{
		skillSet=aSkillSet;
		
		this.drawComponent ();
	};
	
	/**
	 * 
	 */
	this.processSerialization=function processSerialization()
	{
		pointer.debug ("processSerialization()");

		// Process component specific pre-defined styles ...
		
		pointer.setText (this.label);
		
		// Process component custom styles ...
		this.styles=aDescription.styles;

		this.styles=pointer.getGrDescription().styles;
		
		if (this.styles!=null)
		{
			pointer.debug ("Processing " + this.styles.length + " styles ...");
			
			for (var i=0;i<this.styles.length;i++)
			{
				var aStyle=this.styles [i]; // CTATStyle
				
				if(aStyle.styleName=="SkillBarBorderColor")
				{
					inspSkillBarBorderColor=aStyle.styleValue;
				}
				
				if(aStyle.styleName=="SkillBarColor")
				{
					inspSkillBarColor=aStyle.styleValue;
				}
				
				if(aStyle.styleName=="SkillMasteryColor")
				{
					inspSkillBarThresholdColor=aStyle.styleValue;
				}
				
				if(aStyle.styleName=="SkillBarWidth")
				{
					barMaxX=aStyle.styleValue;
				}
				
				if(aStyle.styleName=="borderRoundness")
				{
					borderRoundness=aStyle.styleValue;
				}
				
				if(aStyle.styleName=="OuterBorderColor")
				{
					outerBorderColor=aStyle.styleValue;
				}
			}	
		}	
	};
	
	/**
	 * Override from CTATComponent.js 
	 */
	this.drawComponent=function drawComponent ()
	{	
		pointer.debug ("drawComponent ()");
		
		if (skillSet==null)
		{
			debug ("Info: no skillSet object available, bumping out");
			return;
		}

		graphicsTools.save();
		
		graphicsTools.setLineColor(outerBorderColor);

		//For some reason, using borderRoundness will mess this function up...
		graphicsTools.drawRoundedRectFilled (1,1,
									   		pointer.getWidth(),
									   		pointer.getHeight(),
									  		5);

		graphicsTools.clip();
		
		var top=marginY;
		
		// Draw each skill, one at a time ...
		
		var skillList=skillSet.getSkillSet ();
		
		if (skillList==null)
		{
			pointer.debug ("Error: list of skills is null in skills object");
			return;
		}
		
		if (skillList.length==0)
		{
			pointer.debug ("Error: list of skills is 0 length");
			return;
		}		
						
		for (var i=0;i<skillList.length;i++)
		{
			var skill=skillList [i];
			
			pointer.debug ("Drawing skill "+i+" "+skill.getDisplayName () + " level: " + skill.getLevel ()+" ...");
						
			graphicsTools.setLineColor(inspSkillBarBorderColor);
			graphicsTools.drawRectangle (marginX,top,barMaxX,barHeight);
			
			if (skill.getDisplayName() == null)
			{
				graphicsTools.setLineColor("#000000");
				graphicsTools.drawText (marginX+1+barMaxX+2,top+(barHeight/2),"no-name");
			}	
			else
			{
				graphicsTools.setLineColor("#000000");
				graphicsTools.drawText (marginX+1+barMaxX+2,top+(barHeight/2),skill.getDisplayName());
			}	
					
			if (skill.getLevel ()>spThreshold)
			{
				graphicsTools.setFillColor(inspSkillBarThresholdColor);
				graphicsTools.drawRectangleFilled (marginX+1,top+1,skill.getLevel ()*(barMaxX-2),barHeight-2);
				//this.drawRect (marginX+1,top+1,skill.getLevel ()*(barMaxX-2),barHeight-2,'#000000');				
			}
			else
			{		
				graphicsTools.setFillColor(inspSkillBarColor);		
				graphicsTools.drawRectangleFilled (marginX+1,top+1,skill.getLevel ()*(barMaxX-2),barHeight-2);
				//this.drawRect (marginX+1,top+1,skill.getLevel ()*(barMaxX-2),barHeight-2,'#000000');
			}
			
			/*
			if (inspSkillVerticalStroke==true)
			{
				//sTools.lineColor=inspSkillBarThresholdColor;
				//this.drawLine (marginX+1+calcWidth (skill.getLevel (),barMaxX-2),top+1,marginX+1+calcWidth (skill.getLevel (),barMaxX-2),top+1+barHeight-2);
			}
			*/

			top+=(barHeight+barDistance);
		}
		
		graphicsTools.restore();
	};	
}

CTATSkillWindow.prototype = Object.create(CTATCompBase.prototype);
CTATSkillWindow.prototype.constructor = CTATSkillWindow;
/**------------------------------------------------------------------------------------
 $Author$ 
 $Date$ 
 $Header$ 
 $Name$ 
 $Locker$ 
 $Log$
 
 -
 License:
 -
 ChangeLog:
 -
 Notes:
 
	http://quocity.com/colresizable/
 
*/


/**
 *  
 */
function CTATTable (aDescription,aX,aY,aWidth,aHeight)
{		
	CTATCompBase.call(this,
					  "CTATTable", 
					  "__undefined__",
					  aDescription,
					  aX,
					  aY,
					  aWidth,
					  aHeight);
					  
	var pointer=this;					  
	var table=null;
	var nrRows=2;
	var nrColumns=2;
	var nameCheck="";
	var headerHeight=25;
	
	this.init=function init() 
	{
	    pointer.debug("init (" + pointer.getName() + ")");
		
	    pointer.addCSSAttribute("z-index", currentZIndex);
		
		nameCheck=('ctatdiv' + currentIDIndex);
		
		var body=document.body;
		table=document.createElement('table');
		table.style.width='100%';		
	    table.setAttribute('id', nameCheck);
		table.setAttribute('class', 'resizable');
	    
	    pointer.setComponent(table);
	    pointer.debug("Final location: " + pointer.getX() + "," + pointer.getY() + " with text: " + pointer.getText());
	    pointer.setInitialized(true);	    
	    pointer.addComponentReference(pointer, table);
	    pointer.getDivWrap().appendChild(table);

		pointer.addCSSAttribute("width", pointer.getWidth()+"px");
		pointer.addCSSAttribute("height", pointer.getHeight()+"px");
		
		pointer.modifyCSSAttribute("border", "0px");
		pointer.modifyCSSAttribute("border-spacing", "0px");
		pointer.modifyCSSAttribute("border-collapse", "separate");
		
	    pointer.render();
		
	    currentZIndex++;
	    currentIDIndex++;
	};
	/**
	 * 
	 */
	this.configFromDescription=function configFromDescription ()
	{
		pointer.debug ("configFromDescription ()");
		
	};
	/**
	 * 
	 */
	this.processSerialization=function processSerialization()
	{
		//useDebugging=true;
	
		pointer.debug ("processSerialization()");

		// Process component specific pre-defined styles ...
		
		
		
		// Process component custom styles ...		

		this.styles=pointer.getGrDescription().styles;
		
		pointer.debug ("Processing " + this.styles.length + " styles ...");
		
		for (var i=0;i<this.styles.length;i++)
		{
			var aStyle=this.styles [i]; // CTATStyle
			
			if(aStyle.styleName=="num_rows")
			{
				nrRows=aStyle.styleValue;
				
				pointer.debug ("Setting number of rows to: " + aStyle.styleValue);
			}			
			
			if(aStyle.styleName=="num_cols")
			{
				nrColumns=aStyle.styleValue;
				
				pointer.debug ("Setting number of columns to: " + aStyle.styleValue);
			}	

			if(aStyle.styleName=="HeaderHeight")
			{
				headerHeight=aStyle.styleValue;
				
				pointer.debug ("Setting the header height to: " + aStyle.styleValue);
			}				
		}
		
		//useDebugging=false;
	};	
	/**
	* This method is called from CTATTutor in postProcess and will grab all
	* the separate text input components and reparents them in the appropriate
	* table cells.
	* 
	* Uses http://quocity.com/colresizable/
	*/
	this.adjustTableContents=function adjustTableContents ()
	{					
		//useDebugging=true;
					
		pointer.debug ("adjustTableContents()");
		
		//listComponentReferences ();
				
		var head=null;
		var tr=null;		

		//>-----------------------------------------------------------------------------
		// First create the table, this allows it to resize to a stable configuration...
		
		for (var i=0;i<nrRows;i++)
		{
			if (i==0)
			{
				head=table.createTHead();			
				tr=head.insertRow();
			}
			else
			{	head=table.createTBody();
				tr=head.insertRow(); 
			}
					
			for (var j=0;j<nrColumns;j++)
			{			
				if (i==0)
				{
					td=document.createElement('th');
					tr.appendChild(td);
				}
				else	
					td=tr.insertCell();
										
				td.setAttribute('style', 'border: 1px solid black; padding: 0px; margin: 0px;');														
			}
		}
		
		//>-----------------------------------------------------------------------------
		// Make the table resizable
		
		//pointer.debug ('Making table colums (#'+nameCheck+') resizable ...');
		//$('#'+nameCheck).colResizable();
		//$('table').colResizable();
				
		//>-----------------------------------------------------------------------------
		// Get the cell size	

		var row = table.rows[0];
		var cell = row.cells[0];
		
		var cellWidth=cell.offsetWidth;
		var cellHeight=cell.offsetHeight;

		pointer.debug ("Determined cell size to be: " + cellWidth + "x" + cellHeight);

		var missingCells="";
		
		//>-----------------------------------------------------------------------------
		// Relocate the text components into the table cells ...
		
		for (var i = 0, row; row = table.rows[i]; i++) 
		{
			for (var j = 0, cell; cell = row.cells[j]; j++) 
			{		
				var formatted=(pointer.getName()+".R"+i+"C"+j);
								
				var comp=findComponent (formatted);
				
				if (comp!=null)
				{				
					comp.setCellContainer (cell);
				
					var divver=comp.getDivWrap();
					
					if (divver!=null)
					{						
						divver.parentNode.removeChild (divver);
						
						cell.appendChild (divver);

						//debug ("Resizing to: " + cellWidth + "," + cellWidth);
						
						comp.move (0,0);						
						comp.setStyleAll ("position","relative");
						comp.setSize (cellWidth-4,cellHeight-4);
					}
					else
					{
						pointer.debug ("Error: unable to get div wrapper from component");
					}	
				}
				else
				{
					missingCells+=(' ,'+formatted);
				}
			}  
		}
		
		if (missingCells!="")
		{
			pointer.debug ("The following cells could not be mapped to components: " + missingCells);
		}
		
		//>-----------------------------------------------------------------------------
		
		// All done
		
		//useDebugging=false;
	};
}

CTATTable.prototype = Object.create(CTATCompBase.prototype);
CTATTable.prototype.constructor = CTATTable;
/**------------------------------------------------------------------------------------
 $Author$ 
 $Date$ 
 $Header$ 
 $Name$ 
 $Locker$ 
 $Log$
 
 -
 License:
 -
 ChangeLog:
 -
 Notes:
 
  Events: click, mousemove, mouseover, mouseout, keyup, keydown, 
  		  focus, blur, select, load

  CSS: http://tutobx.com/post/24806696944/raised-and-pressed-div-using-css
       http://stackoverflow.com/questions/5662178/opacity-of-divs-background-without-affecting-contained-element-in-ie-8
 
  Js:  http://www.quirksmode.org/js/this.html
       http://unschooled.org/2012/03/understanding-javascript-this/   
 
  CTAT:
  
 		[48] [07:14:14] [CTATTextField] Processing style labelTextValue,
		[49] [07:14:14] [CTATTextField] Processing style inspBackgroundColor,ffffff
		[50] [07:14:14] [CTATTextField] Processing style inspBorderColor,999999
		[51] [07:14:14] [CTATTextField] Processing style inspFontName,Arial
		[52] [07:14:14] [CTATTextField] Processing style inspFontSize,20
		[53] [07:14:14] [CTATTextField] Processing style inspFontColor,0
		[54] [07:14:14] [CTATTextField] Processing style inspBold,FALSE
		[55] [07:14:14] [CTATTextField] Processing style inspItalic,FALSE
		[56] [07:14:14] [CTATTextField] Processing style inspUnderline,FALSE
		[57] [07:14:14] [CTATTextField] Processing style inspAlignment,left
		[58] [07:14:14] [CTATTextField] Processing style inspShowHintHighlight,true
		[59] [07:14:14] [CTATTextField] Processing style blockOnCorrect,true
		[60] [07:14:14] [CTATTextField] Processing style _tutorComponent,Tutor
		[61] [07:14:14] [CTATTextField] Processing style disabledBackgroundColor,ffffff
		[62] [07:14:14] [CTATTextField] Processing style disabledTextColor,0
		[63] [07:14:14] [CTATTextField] Processing style tutorComponent,Tutor   
*/

/**
 * 
 */
function CTATTextField (aDescription,
						aX,
						aY,
						aWidth,
						aHeight)
{
	CTATTextBasedComponent.call(this, 
					  			"CTATTextBasedComponent", 
					  			"__undefined__",
					  			aDescription,
					  			aX,
					  			aY,
					  			aWidth,
					  			aHeight);									
	var editable=true;
	var alpha=0.0;
	var pointer=this;
	var textfield=null;
	
	pointer.debug ("Base class initialized, continuing ...");

	this.getAlpha=function getAlpha()
	{
		return (this.alpha);
	};
	
	this.setAlpha=function setAlpha(anAlpha)
	{
		this.alpha=anAlpha;
	};
				
	this.debug (this.getClassName() + " ("+this.getX()+","+this.getY()+","+this.getWidth()+","+this.getHeight()+")");

	this.configFromDescription ();

	/**
	*
	*/
	this.init=function init() 
	{
	    pointer.debug("init (" + pointer.getName() + ")");

	    pointer.addCSSAttribute("z-index", currentZIndex);

	    textfield=document.createElement('div');

	    textfield.title=pointer.getName();
	    textfield.name=pointer.getName();
	    textfield.setAttribute('id', ('ctatdiv' + currentIDIndex));
	    textfield.setAttribute('onkeypress', 'return noenter(event)');
	    
	    pointer.setComponent(textfield);

	    pointer.debug("Final location: " + pointer.getX() + "," + pointer.getY() + " with text: " + pointer.getText());

	    textfield.innerHTML=pointer.getText();

	    pointer.setInitialized(true);
	    
	    pointer.addComponentReference(pointer, textfield);
		
		if (pointer.getDivWrap()==null)
		{
			pointer.debug ("Internal error: no div wrapper avaialble yet to add component to");
			return;
		}
		else
		{
			pointer.debug ("We have a div wrapper, using ..");
		}
		
	    pointer.getDivWrap().appendChild(textfield);
		
		pointer.debug ("We're wrapped now");
		
		var bgColor=pointer.getBackgroundColor();
		var backgroundColorString="rgba(" + hexToRgb (bgColor).r + "," + hexToRgb (bgColor).r + "," + hexToRgb (bgColor).r + "," + pointer.getAlpha() + ")";
		
		pointer.modifyCSSAttribute("background-color", backgroundColorString);
		//pointer.addStringCSS("filter: alpha(opacity=1);");
		
		pointer.addCSSAttribute("width", pointer.getWidth()+"px");
		pointer.addCSSAttribute("height", pointer.getHeight()+"px");
		
		pointer.debug ("Pre-render ...");
		
	    pointer.render();
		
		pointer.debug ("Render done");
		
		//pointer.debug ("Adding keypress listener ...");		
	    //pointer.addSafeEventListener ('keypress', pointer.processKeyPress,textfield);
		//pointer.debug ("Adding focus listener ...");
		
	    //pointer.addSafeEventListener ('focus', pointer.processFocus,textfield);
		
		pointer.debug ("init () done");
	};
	
	/**
	 * 
	 * @param aValue
	 */
	this.assignEditable=function assignEditable(aValue)
	{
		editable=aValue;
	};	
	
	/**
	 * 
	 * @param aText
	 */
	this.setText=function setText(aText)
	{
		pointer.debug("setText (" + aText + ")");
	
		pointer.assignText(aText);
		
		if (textfield!=null)
		{
			textfield.innerHTML=aText;
	    }
	};
	
	/**
	 * Override from CTATCompBase because for text based components
	 * we also have to set them non-editable
	 *  
	 * @param aValue
	 */
	this.setEnabled=function setEnabled(aValue) 
	{
		pointer.assignEnabled(aValue);
			
		if (textfield==null)
			return;
			
		textfield.disabled=!aValue;
		
		setEditable (aValue);
	};	
	/**
	 * 
	 * @param aValue
	 */
	this.setEditable=function setEditable(aValue)
	{
		pointer.assignEditable(aValue);
		
		if (textfield==null)
			return;
		
		if (pointer.getEditable()==true)
			textfield.contentEditable='true';
		else 
		{
			textfield.contentEditable='false';
			pointer.setFontColor(pointer.getDisabledTextColor());
			pointer.setBackgroundColor(pointer.getDisabledBGColor());
		}
	};
	
	/**
	 * 
	 */
	this.processSerialization=function processSerialization()
	{
		pointer.debug ("processSerialization()");

		// Process component specific pre-defined styles ...
		
		
		
		// Process component custom styles ...		

		this.styles=pointer.getGrDescription().styles;
		
		pointer.debug ("Processing " + this.styles.length + " styles ...");
		
		for (var i=0;i<this.styles.length;i++)
		{
			var aStyle=this.styles [i]; // CTATStyle
			
			if(aStyle.styleName=="labelText")
			{
				pointer.setText(aStyle.styleValue);
			}
			
			if(aStyle.styleName=="Enabled")
			{
				pointer.setEditable(aStyle.styleValue);
			}
			
			if(aStyle.styleName=="ShowScrollbars")
			{
				if(aStyle.styleValue=="true")
				{
					pointer.modifyCSSAttribute("overflow", "scroll");
				}
				
				else
				{
					pointer.modifyCSSAttribute("overflow", "hidden");
				}
			}
			
			if(aStyle.styleName=="BorderStyle")
			{
				pointer.setBorderStyle(aStyle.styleValue);
			}
			
			if(aStyle.styleName=="TabOnEnter")
			{
				pointer.setTabOnEnter(aStyle.styleValue);
			}
			
			if(aStyle.styleName=="MaxCharacters")
			{
				pointer.setMaxCharacters(aStyle.styleValue);
			}
		}
	};
}

CTATTextField.prototype = Object.create(CTATTextBasedComponent.prototype);
CTATTextField.prototype.constructor = CTATTextField;
/**------------------------------------------------------------------------------------
 $Author$ 
 $Date$ 
 $Header$ 
 $Name$ 
 $Locker$ 
 $Log$
 
 -
 License:
 -
 ChangeLog:
 -
 Notes:
 
  Events: click, mousemove, mouseover, mouseout, keyup, keydown, 
  		  focus, blur, select, load

  CSS: http://tutobx.com/post/24806696944/raised-and-pressed-div-using-css
       http://stackoverflow.com/questions/5662178/opacity-of-divs-background-without-affecting-contained-element-in-ie-8
 
  Js:  http://www.quirksmode.org/js/this.html
       http://unschooled.org/2012/03/understanding-javascript-this/   
 
  CTAT:
  
 		[48] [07:14:14] [CTATTextField] Processing style labelTextValue,
		[49] [07:14:14] [CTATTextField] Processing style inspBackgroundColor,ffffff
		[50] [07:14:14] [CTATTextField] Processing style inspBorderColor,999999
		[51] [07:14:14] [CTATTextField] Processing style inspFontName,Arial
		[52] [07:14:14] [CTATTextField] Processing style inspFontSize,20
		[53] [07:14:14] [CTATTextField] Processing style inspFontColor,0
		[54] [07:14:14] [CTATTextField] Processing style inspBold,FALSE
		[55] [07:14:14] [CTATTextField] Processing style inspItalic,FALSE
		[56] [07:14:14] [CTATTextField] Processing style inspUnderline,FALSE
		[57] [07:14:14] [CTATTextField] Processing style inspAlignment,left
		[58] [07:14:14] [CTATTextField] Processing style inspShowHintHighlight,true
		[59] [07:14:14] [CTATTextField] Processing style blockOnCorrect,true
		[60] [07:14:14] [CTATTextField] Processing style _tutorComponent,Tutor
		[61] [07:14:14] [CTATTextField] Processing style disabledBackgroundColor,ffffff
		[62] [07:14:14] [CTATTextField] Processing style disabledTextColor,0
		[63] [07:14:14] [CTATTextField] Processing style tutorComponent,Tutor  
*/

/**
 * 
 */
function CTATTextInput (aDescription,
						aX,
						aY,
						aWidth,
						aHeight)
{	

	CTATTextBasedComponent.call(this, 
					  			"CTATTextInput", 
					  			"__undefined__",
					  			aDescription,
					  			aX,
					  			aY,
					  			aWidth,
					  			aHeight);

	var pointer=this;
	var textinput=null;
	var cellContainer=null;

	this.debug (this.getClassName() + " ("+this.getX()+","+this.getY()+","+this.getWidth()+","+this.getHeight()+")");

	this.configFromDescription();

	/**
	 * 
	 */
	this.init=function init() 
	{
	    this.debug("init (" + pointer.getName() + ")");

	    this.addCSSAttribute("z-index", currentZIndex);

	    textinput=document.createElement("input");	    
	    textinput.type="text";
	    textinput.name=aDescription.name;
	    textinput.setAttribute('maxlength', pointer.getMaxCharacters());
	    textinput.setAttribute('id', ('ctatdiv' + currentIDIndex));
	    textinput.setAttribute('onkeypress', 'return noenter(event)');
	    
	    pointer.setComponent(textinput);
	    
		/*
	    if (pointer.getEnabled() == true)
	        pointer.getComponent().contentEditable='true';
	    else
	        pointer.getComponent().contentEditable='false';

	    pointer.getComponent().contentEditable='true';
		*/

	    this.debug("Final location: " + pointer.getX() + "," + pointer.getY() + " with text: " + pointer.getText());

	    textinput.value=this.getText();

	    pointer.setInitialized(true);
	    
	    pointer.addComponentReference(pointer, textinput);

	    pointer.getDivWrap().appendChild(textinput);

		//this.addCSSAttribute("width", pointer.getWidth()+"px");
		//this.addCSSAttribute("height", pointer.getHeight()+"px");

	    pointer.render();

	    currentZIndex++;
	    currentIDIndex++;

	    pointer.addSafeEventListener ('keypress', pointer.processKeypress,textinput);
	    pointer.addSafeEventListener ('focus', pointer.processFocus,textinput);
	    pointer.addSafeEventListener ('click',pointer.processClick,textinput);
	};
	
	this.setCellContainer=function setCellContainer(aContainer) 
	{
		cellContainer=aContainer;
	};

	this.getCellContainer=function getCellContainer()
	{
		return (cellContainer);
	};	
	
	/**
	 * 
	 */
	this.setText = function setText(aText) 
	{
	    pointer.debug("setText (" + aText + ")");
	    
 		pointer.assignText(aText);
 		textinput.value=aText;
 		
 		// this.redraw (); // Very very experimental
	};


	this.reset=function reset ()
	{
		pointer.configFromDescription();
		pointer.processSerialization();
		textinput.value="";
	}
	
	/**
	 * 
	 */
	this.processSerialization=function processSerialization()
	{
		pointer.debug ("processSerialization()");

		// Process component specific pre-defined styles ...
		
		this.styles=pointer.getGrDescription().styles;
		
		// Process component custom styles ...		

		if (this.styles==null)
		{
			pointer.debug ("Error: styles structure is null");
			return;
		}
		
		pointer.debug ("Processing " + this.styles.length + " styles ...");
		
		for (var i=0;i<this.styles.length;i++)
		{
			var aStyle=this.styles [i]; // CTATStyle
			
			if(aStyle.styleName=="MaxCharacters")
			{
				pointer.setMaxCharacters(aStyle.styleValue);
			}
			
			if(aStyle.styleName=="showBorder")
			{
				pointer.setShowBorder(true);
			}
			
			if(aStyle.styleName=="BorderStyle")
			{
				pointer.setBorderStyle(aStyle.styleValue);
			}
			
			if(aStyle.styleName=="SolidBorderColor")
			{
				pointer.setBorderColor(aStyle.styleValue);
			}
			
			/*
			if(aStyle.styleName=="DisplayHTMLText")
			{
				
			}
			*/
		}	
	};	
	/**
	 * TPA 
	 */
	this.UpdateTextArea=function UpdateTextArea (aText)
	{
		pointer.debug ("UpdateTextArea ("+aText+")");
		this.setText(aText);
	}
}

CTATTextInput.prototype = Object.create(CTATTextBasedComponent.prototype);
CTATTextInput.prototype.constructor = CTATTextInput;
/**------------------------------------------------------------------------------------
 $Author$ 
 $Date$ 
 $Header$ 
 $Name$ 
 $Locker$ 
 $Log$
 
 -
 License:
 -
 ChangeLog:
 -
 Notes:
 
 http://dev.opera.com/articles/view/custom-html5-video-player-with-css3-and-jquery/
 
*/

/**
 * 
 */
function CTATVideo (aDescription,aX,aY,aWidth,aHeight)
{		
	CTATTutorableCompponent.call(this, 
					  			 "CTATVideo", 
					  			 "__undefined__",
					  			 aDescription,
					  			 aX,
					  			 aY,
					  			 aWidth,
					  			 aHeight);

	var hints=new Array ();
	var alpha=0.0;
	var pointer=this;
	var video=null;

	var skillSet=new Array ();
	
	this.getAlpha=function getAlpha()
	{
		return (alpha);
	};
	
	this.setAlpha=function setAlpha()
	{
		alpha=aAlpha;
	};
				
	this.debug (this.getClassName() + " ("+this.getX()+","+this.getY()+","+this.getWidth()+","+this.getHeight()+")");
	
	this.configFromDescription ();

	this.init=function init() 
	{
	    pointer.debug("init (" + pointer.getName() + ")");

	    pointer.addCSSAttribute("z-index", currentZIndex);

	    video=document.createElement('video');
	    //pointer.getComponent().title=pointer.getName();
	    video.src="http://augustus.pslc.cs.cmu.edu/ProportionalDistanceExercise.mp4";
	    video.controls=true;
	    video.autocontrols=false; // doesn't work
	    video.autoplay=true;	    
	    video.name=pointer.getName();
	    video.setAttribute('id', ('ctatdiv' + currentIDIndex));
	    video.setAttribute('onkeypress', 'return noenter(event)');
	    //pointer.getComponent ().conceal=function(){ /* nothing */ };

	    pointer.addComponentReference(pointer, video);

	    pointer.debug("Final location: " + pointer.getX() + "," + pointer.getY() + " with text: " + pointer.getText());

	    pointer.setInitialized(true);

	    pointer.getDivWrap().appendChild(video);

		var bgColor=pointer.getBackgroundColor();
		var backgroundColorString="rgba (" + hexToRgb (bgColor).r + "," + hexToRgb (bgColor).r + "," + hexToRgb (bgColor).r + "," + 0 + ")";
		
		pointer.modifyCSSAttribute("background-color", backgroundColorString);
		pointer.addStringCSS("filter: alpha(opacity=0);");

		pointer.addCSSAttribute("width", pointer.getWidth());
		pointer.addCSSAttribute("height", pointer.getHeight());

	    video.setAttribute('style', pointer.getCSS());

	    currentZIndex++;
	    currentIDIndex++;
	};
		
	/**
	 * 
	 */
	this.processSerialization=function processSerialization()
	{
		pointer.debug ("processSerialization()");

		// Process component specific pre-defined styles ...
		
		
		
		// Process component custom styles ...		

		this.styles=pointer.getGrDescription().styles;
		
		pointer.debug ("Processing " + this.styles.length + " styles ...");
		
		for (var i=0;i<this.styles.length;i++)
		{
			var aStyle=this.styles [i]; // CTATStyle
			
			if(aStyle.styleName=="borderRoundness")
			{
				borderRoundness=aStyle.styleValue;
				pointer.addCSSAttribute("border-radius", borderRoundess);
			}
		}	
	};		
}

CTATVideo.prototype = Object.create(CTATTutorableComponent.prototype);
CTATVideo.prototype.constructor = CTATVideo;
/**------------------------------------------------------------------------------------
 $Author$ 
 $Date$ 
 $Header$ 
 $Name$ 
 $Locker$ 
 $Log$
 
 -
 License:
 -
 ChangeLog:
 -
 Notes:
 
*/

/**
*
*/
function CTATArgument ()
{		
	var value="Undefined";
	var type="String";
	var format="text";
		
	/**
	*
	*/
	this.setValue=function setValue(aValue) 
	{
		value=aValue;
	};
	/**
	*	
	*/
	this.getValue=function getValue()
	{
		return value;			
	};
	/**
	*
	*/
	this.setType=function setType(aType) 
	{
		type=aType;
	};
	/**
	*	
	*/
	this.getType=function getType() 
	{
		return type;
	};
	/**
	*
	*/
	this.setFormat=function setFormat(aFormat) 
	{
		format=aFormat;
	};
	/**
	*	
	*/
	this.getFormat=function getFormat() 
	{
		return format;
	};
}
/**------------------------------------------------------------------------------------
 $Author$ 
 $Date$ 
 $Header$ 
 $Name$ 
 $Locker$ 
 $Log$
 
 -
 License:
 -
 ChangeLog:
 -
 Notes:
 
 http://stackoverflow.com/questions/6486307/default-argument-values-in-javascript-functions
 
*/

/**
*
*/
function CTATComplexSAI (aSelection,anAction,anInput,aPrompt) 
{
	CTATBase.call(this, "CTATComplexSAI","complexsai");
	
		
}

CTATComplexSAI.prototype = Object.create(CTATBase.prototype);
CTATComplexSAI.prototype.constructor = CTATComplexSAI;
/**------------------------------------------------------------------------------------
 $Author$ 
 $Date$ 
 $Header$ 
 $Name$ 
 $Locker$ 
 $Log$
 
 -
 License:
 -
 ChangeLog:
 -
 Notes:
 
*/

/**
 * 
 */
function CTATStyle (name, value)
{
	this.styleName=name;
	this.styleValue=value;
}

/**
 * 
 */
function CTATParameter (name, value)
{
	this.paramName=name;
	this.paramValue=value;
}

/**
 *  
 */
function CTATComponentDescription ()
{
	CTATBase.call(this, "CTATComponentDescription", "");
	
	this.type="Unknown";
	this.name="Unknown";
	this.groupName="Unknown"; //For things like radio buttons
	this.x=0;
	this.y=0;
	this.width=0;
	this.height=0;
	this.styles=new Array ();
	this.params=new Array ();

	this.pointer=this;
	
	this.componentPointer=null;

	/**
	 * 
	 */
	this.addStyle=function addStyle (aStyle)
	{
		pointer.debug ("addStyle ()");
		
		this.styles.push(aStyle);
	};
	
	/**
	 * 
	 */
	this.setComponentPointer=function setComponentPointer (aPointer)
	{
		this.componentPointer=aPointer;
	};
	
	/**
	 * 
	 */
	this.getComponentPointer=function getComponentPointer ()
	{
		return (this.componentPointer);
	};
}

CTATComponentDescription.prototype = Object.create(CTATBase.prototype);
CTATComponentDescription.prototype.constructor = CTATComponentDescription;/**------------------------------------------------------------------------------------
 $Author$ 
 $Date$ 
 $Header$ 
 $Name$ 
 $Locker$ 
 $Log$
 
 -
 License:
 -
 ChangeLog:
 -
 Notes:
 
*/

/**
 *  
 */
function CTATComponentReference (aRef,aDiv)
{		
	var compReference=aRef;
	var div=aDiv;
	
	/** 
	 * @param aComponent
	 */
	this.setElement=function setElement (aComponent)
	{
		compReference=aComponent;
	};
	/**
	 * 
	 * @returns
	 */
	this.getElement=function getElement ()
	{
		return (compReference);
	};
	/**
	 * 
	 * @param aDiv
	 */
	this.setDiv=function setDiv (aDiv)
	{
		div=aDiv;
	};
	/**
	 * 
	 * @returns
	 */
	this.getDiv=function getDiv ()
	{
		return (div);
	};
}
/**------------------------------------------------------------------------------------
 $Author$ 
 $Date$ 
 $Header$ 
 $Name$ 
 $Locker$ 
 $Log$
 
 -
 License:
 -
 ChangeLog:
 -
 Notes:
 
 http://stackoverflow.com/questions/6486307/default-argument-values-in-javascript-functions
 
*/

/**
 *    This is a relatively new class for CTAT and only exists in AS3 and HTML5. It's meant to 
 *    become the base unit of transaction for methods related to SAI's, instead of passing 
 *    around 3 Strings to methods you can pass a single SAI object and extract relevant data 
 *    from it. Also, every component will have an instance of SAI that can be used as a way of 
 *    recording state as well as sending new actions. 
 *
 *    There is currently no support in the hierarchy for individual elements of the SAI to have 
 *    the type and id values used in the dataShop specs for the selection, action, and input 
 *    fields of evet_descriptors.
 * 
 *    see: http://pslcdatashop.web.cmu.edu/dtd/guide/tool_message.html#element.event_descriptor
 */
function CTATSAI(aSelection,anAction,anInput,aPrompt) 
{
    CTATBase.call(this, "CTATSAI","sai");

    // we use the instance name as the selection
        
    var action="undefined";        
    var prompt="undefined";
    var inputFlattened="";
    var tools=new CTATStringUtil ();
    var internalArguments=new Array ();

    /**
     * 
     */
    this.getArguments=function getArguments ()
    {
        return (internalArguments);
    };
    /**
     * Processes the sai_arguments so that an array of the sai_arguments cast into
     * the appropriate type is returned.
     * @return an array of the sai_arguments cast into their appropriate type.
     * 
     */
    this.getArgumentsTyped=function getArgumentsTyped()
    {
        var i=0;
        var sai_arguments = new Array();
            
        for (i=0;i<this.internalArguments.length;i++)
        {
                var arg=internalArguments [i];
            
                if (arg.getType()==="Boolean") 
                {
                    this.debug ("Adding Boolean argument ("+arg.getValue()+") ...");
                    
                    sai_arguments.push(tools.String2Boolean(arg.getValue()));
                } 
                else if (arg.getType() === "Number") 
                {
                    this.debug ("Adding Number argument ("+arg.getValue()+") ...");
                    sai_arguments.push(new Number(arg.getValue()));
                }
                else if (arg.getType() === "String") 
                {
                    if (arg.getValue()==="No_Value") 
                    {
                        this.debug ("Detected default argument ("+arg.getValue()+"), setting contents to null instead");
                        
                        sai_arguments.push(null);
                    } 
                    else 
                    {
                        sai_arguments.push(new String(arg.getValue()));
                    }
                } 
                else 
                {
                    this.debug ("Unrecognized argument type: "+arg.getType()+" in "+this.toSerializedString()+" IGNORING IT!!!");
                }
        }
        
        return sai_arguments;
    };
    /**
     * 
     */
    this.getArgument=function getArgument (anIndex)
    {                        
        var arg=internalArguments [anIndex];
                
        return (arg);
    };
    /**
     * 
     */
    this.checkDefaultArgument=function checkDefaultArgument ()
    {
        this.debug ("checkDefaultArgument ()");
            
        if (internalArguments.length===0)
        {
            this.debug ("Adding default argument ...");
            
            var defaultArgument=new CTATArgument ();
            internalArguments.push (defaultArgument);
        }                        
    };
    /**
     * 
     */
    this.setArgument=function setArgument (anIndex,aValue)
    {    
        checkDefaultArgument ();
            
        var tempArgument=internalArguments [anIndex];
        
        tempArgument.value=aValue;
        
        return (tempArgument);
    };    
    /**
     * 
     */
    this.addArgument=function addArgument (aValue,aType,aFormat)
    {
        //this.debug ("addArgument ()");
        
        var tempArgument=new CTATArgument ();
        tempArgument.value=aValue;
        tempArgument.type=aType;
        tempArgument.format=aFormat;
        internalArguments.push(tempArgument);
        
        return (tempArgument);
    };
    /**
     * 
     */
    this.addExistingArgument=function addExistingArgument (anArgument)
    {
        //this.debug ("addExistingArgument ()");
        
        internalArguments.push(anArgument);
        
        return (anArgument);
    };
    /**
    *    Changes the current selection, action, and input values
    */        
    this.setSAI=function setSAI (newSelection,
                                 newAction,
                                 newInput,
                                 aType,
                                 aPrompt)
    {
        this.setName(newSelection);
        action=newAction;
        prompt=aPrompt;
        
        this.setInput(newInput);
        this.setType(aType);
    };
    /**
    *    Changes the current input value
    */
    this.setInput=function setInput(newInput) 
    {
        this.debug("setInput("+newInput+")");

        this.checkDefaultArgument ();                        
        
        var arg=this.getArgument (0);            
                                    
        var parser=new CTATHTMLManager ();
        
        arg.setValue(parser.htmlDecode (newInput));
    };
    /**
    *    Returns the primary selection value
    */
    this.getInput=function getInput() 
    {
        this.debug ("getInput()");
            
        if (internalArguments.length===0)
		{
            return ("");            
		}
            
        var arg=this.getArgument (0);
        
        return arg.getValue();
    };
    /**
    *
    */
    this.setType=function setType(aType) 
    {
        this.debug("setType()");
        
        this.checkDefaultArgument ();
        
        var arg=this.getArgument (0);
        arg.type=aType;
    };
    /**
     *    Returns the primary selection value
     */
    this.getType=function getType() 
    {
        this.debug("getType()");
            
        if (internalArguments.length===0)
		{
            return ("");
		}	
            
        var arg=this.getArgument (0);
        return arg.type;
    };
    /**
     *
     */
    this.setFormat=function setFormat(aFormat) 
    {
        this.debug("setFormat()");
            
        this.checkDefaultArgument ();            
            
        var arg=this.getArgument (0);
        arg.setFormat (aFormat);
    };
    /**
     *    Returns the primary selection value
     */
    this.getFormat=function getFormat() 
    {
        this.debug("getFormat()");
        
        if (internalArguments.length===0)
		{
            return ("");
		}	
            
        var arg=this.getArgument (0);
        
        return arg.getFormat ();
    };
    /**
    *    Changes the current input value
    */
    this.setSelection=function setSelection(newInput) 
    {
        this.debug("setSelection("+newInput+")");
        
        this.setName(newInput);
    };
    /**
    *    Returns the primary selection value
    */
    this.getSelection=function getSelection() 
    {
        this.debug("getSelection()");
        
        return (this.getName());
    };
    /**
    *
    */
    this.setAction=function setAction(newInput) 
    {
        this.debug("setAction("+newInput+")");
        
        action = newInput;
    };
    /**
    *    Returns the primary action value
    */
    this.getAction=function getAction() 
    {
        this.debug("getAction()");
        
        return action;
    };
    /**
    *
    */
    this.setPrompt=function setPrompt(newInput) 
    {
        this.debug("setPrompt("+newInput+")");
        
        prompt = newInput;
    };
    /**
    *    Returns the primary action value
    */
    this.getPrompt=function getPrompt() 
    {
        this.debug("getPrompt()");
        
        return prompt;
    };
    /**
     *    
     */
    this.propagate=function propagate (source)        
    {
        this.debug ("propagate ()");
            
        var sourceArguments=source.getArguments ();
            
        for (var i=0;i<sourceArguments.length;i++)
        {
            var fromArg=sourceArguments [i];
            var toArg=internalArguments [i];
                
            if ((fromArg===null) || (toArg===null))
            {
                this.debug ("Internal error: argument lists do not align between received SAI and source SAI");
                return;
            }
                
            toArg.setValue(fromArg.getValue ());
        }
    };
    /**
    *    
    */        
    this.fromString=function fromString (aStream)
    {
        var parser=new CTATXML ();
        
        var rootNode=parser.parseXML (aStream);
        
        this.fromXML (rootNode);
    };
    /**
    * Provided to the parse method is a single node, which can have any node name.
    * The code below will then search in that node for the selection, action, input
    * fields, etc.    
    */    
    this.fromXML=function fromXML (aNode)
    {
        this.debug ("fromXML ()");
                          
        var parser=new CTATXML ();
        
        internalArguments=new Array ();

        var entries=aNode.childNodes;

        inputFlattened="";

        for (var t=0;t<entries.length;t++)
        {
            var entry=entries [t];
            
            //>-----------------------------------------------------------------------------

            if ((entry.nodeName==="selection") || (entry.nodeName==="Selection"))
            {
                //this.debug ("Parsing selection");
                
                var vals=entry.childNodes;
                    
                var nameMatched=false;
                    
                for (var i=0;i<vals.length;i++)
                {
                    var val=vals [i];
                    
                    if (val.nodeName==="value")
                    {
                        //this.debug ("Parsing value: " + parser.getNodeTextValue (val));
                        
                        nameMatched=true;
                        this.setSelection (parser.getNodeTextValue (val));
                    }                            
                }
                
                if (nameMatched===false)
                {
                    //this.debug ("Parsing value: " + parser.getNodeTextValue (entry));
                    
                    this.setSelection (parser.getNodeTextValue (entry));
                }    
            }
            
            //>-----------------------------------------------------------------------------
            
            if ((entry.nodeName==="action") || (entry.nodeName==="Action"))
            {
                var acts=entry.childNodes;
                    
                var actionMatched=false;
                    
                for (var j=0;j<acts.length;j++)
                {
                    var act=acts [j];
                    
                    if (act.nodeName==="value")
                    {
                        actionMatched=true;
                        this.setAction (parser.getNodeTextValue (act));    
                    }                            
                }

                if (actionMatched===false)
				{
                    this.setAction (parser.getNodeTextValue (entry));
				}	
            }
            
            //>-----------------------------------------------------------------------------
                
            if ((entry.nodeName==="internalArguments") || (entry.nodeName==="value") || (entry.nodeName==="Input"))
            {
                var args=entry.childNodes;
                var newValue=null;
				
                internalArguments=new Array ();
                    
                var formatter=new CTATHTMLManager ();
                var newArgument=new CTATArgument ();                    
                var ind=0;
                    
                internalArguments.push (newArgument);
                    
                for (var k=0;k<args.length;k++)
                {                
                    var argument=args [k];
                    
                    if (argument.nodeName==="value")
                    {
                        if (argument.childNodes !== null)
                        {
                            this.debug ("Parsing SAI input ...");

                            this.debug ("Childnodes: " + argument.childNodes.length);

                            if (argument.childNodes.length===1)
                            {
                                newValue=formatter.htmlDecode (parser.getNodeTextValue(argument));
                                
                                this.debug ("Setting new value to: " + newValue);
                                
                                newArgument.setValue (newValue);
                            }
                            else
                            {
                                if (ind>0)
								{
                                    inputFlattened+=",";
								}	
                                                        
                                newValue=formatter.htmlDecode (parser.getNodeTextValue(argument));
                                
                                this.debug ("Setting new value to: " + newValue);
                                
                                newArgument.setValue (newValue);

                                // If available ...

                                newArgument.setName (argument.attributes.getNamedItem("name").value);
                                newArgument.setType (argument.attributes.getNamedItem("type").value);
                                newArgument.setFormat (argument.attributes.getNamedItem("format").value);

                                inputFlattened+=newValue;

                                ind++;                            
                            }    
                        }
                        else
                        {                            
                            newVal=formatter.htmlDecode (parser.getNodeTextValue(argument));
                            
                            this.debug ("Setting new value to: " + newVal);
                            
                            newArgument.setValue (newVal);
                        }
                    }
                }
            }
            
            //>-----------------------------------------------------------------------------
            
            if ((entry.nodeName==="prompt") || (entry.nodeName==="Prompt"))
            {                    
                this.debug ("Parsing prompt ...");
                                
                this.setPrompt (parser.getNodeTextValue (entry));
            }                                
            
            //>-----------------------------------------------------------------------------
        }
            
        this.checkDefaultArgument ();
    };
    /**
    * Provided to the parse method is a single node, which can have any node name.
    * The code below will then search in that node for the selection, action, input
    * fields, etc.    
    */    
    this.fromXMLInternal=function fromXMLInternal (aNode)
    {
        this.debug ("fromXMLInternal ()");
                          
        var parser=new CTATXML ();
        
        internalArguments=new Array ();

        var entries=aNode.childNodes;

        inputFlattened="";

        for (var t=0;t<entries.length;t++)
        {
            var entry=entries [t];
            
            //>-----------------------------------------------------------------------------

            if ((entry.nodeName==="selection") || (entry.nodeName==="Selection"))
            {
                //this.debug ("Parsing selection");
                
                var vals=entry.childNodes;
                    
                var nameMatched=false;
                    
                for (var i=0;i<vals.length;i++)
                {
                    var val=vals [i];
                    
                    if (val.nodeName==="value")
                    {
                        //this.debug ("Parsing value: " + parser.getNodeTextValue (val));
                        
                        nameMatched=true;
                        this.setSelection (parser.getNodeTextValue (val));
                    }                            
                }
                
                if (nameMatched===false)
                {
                    //this.debug ("Parsing value: " + parser.getNodeTextValue (entry));
                    
                    this.setSelection (parser.getNodeTextValue (entry));
                }    
            }
            
            //>-----------------------------------------------------------------------------
            
            if ((entry.nodeName==="action") || (entry.nodeName==="Action"))
            {
                var acts=entry.childNodes;
                    
                var actionMatched=false;
                    
                for (var j=0;j<acts.length;j++)
                {
                    var act=acts [j];
                    
                    if (act.nodeName==="value")
                    {
                        actionMatched=true;
                        this.setAction (parser.getNodeTextValue (act));    
                    }                            
                }

                if (actionMatched===false)
				{
                    this.setAction (parser.getNodeTextValue (entry));
				}	
            }
            
            //>-----------------------------------------------------------------------------
                
            if ((entry.nodeName==="internalArguments") || (entry.nodeName==="value") || (entry.nodeName==="Input"))
            {
                var args=entry.childNodes;
                
                internalArguments=new Array ();
                    
                var formatter=new CTATHTMLManager ();
                var newArgument=new CTATArgument ();                    
                var ind=0;
				var newValue=null;
                    
                internalArguments.push (newArgument);
                    
                for (var k=0;k<args.length;k++)
                {                
                    var argument=args [k];
                    
                    if (argument.nodeName==="value")
                    {
                        if (argument.childNodes !== null)
                        {
                            this.debug ("Parsing SAI input ...");

                            this.debug ("Childnodes: " + argument.childNodes.length);

                            if (argument.childNodes.length===1)
                            {
                                newValue=formatter.htmlDecode (parser.getNodeTextValue(argument));
                                
                                this.debug ("Setting new value to: " + newValue);
                                
                                newArgument.setValue (newValue);
                            }
                            else
                            {
                                if (ind>0)
								{
                                    inputFlattened+=",";
								}	
                                                        
                                newValue=formatter.htmlDecode (parser.getNodeTextValue(argument));
                                
                                this.debug ("Setting new value to: " + newValue);
                                
                                newArgument.setValue (newValue);

                                // If available ...

                                newArgument.setName (argument.attributes.getNamedItem("name").value);
                                newArgument.setType (argument.attributes.getNamedItem("type").value);
                                newArgument.setFormat (argument.attributes.getNamedItem("format").value);

                                inputFlattened+=newValue;

                                ind++;                            
                            }    
                        }
                        else
                        {                            
                            newVal=formatter.htmlDecode (parser.getNodeTextValue(argument));
                            
                            this.debug ("Setting new value to: " + newVal);
                            
                            newArgument.setValue (newVal);
                        }
                    }
                }
            }
            
            //>-----------------------------------------------------------------------------
            
            if ((entry.nodeName==="prompt") || (entry.nodeName==="Prompt"))
            {                    
                this.debug ("Parsing prompt ...");
                                
                this.setPrompt (parser.getNodeTextValue (entry));
            }                                
            
            //>-----------------------------------------------------------------------------
        }
            
        this.checkDefaultArgument ();
    };
    /**
    *    Returns the primary SAI in the XML String format used by datashop specs. 
    *     NOTE: None of the fmt, name, or type fields should be here it will confuse datashop.
    */        
    this.toXMLString=function toXMLString(logMessageFormat) 
    {
        if (logMessageFormat)
		{
            return this.toLSxmlString();
		}	
        else
		{
            return this.toTSxmlString();
		}	
    };
    /**
    *
    */
    this.toLSxmlString=function toLSxmlString() 
    {
        var formatter="";
    
        formatter+="<selection>"+name+"</selection><action>"+action+"</action><input>";
        
        for (var i=0;i<internalArguments.length;i++)
        {
            var arg=internalArguments [i];
            formatter+="<![CDATA["+arg.getValue()+"]]>";
        }
        
        formatter+="</input>";
            
        return (formatter);
    };
    /**
    *    Returns the primary SAI in XML string form, should be good for simple components
    */        
    this.toTSxmlString=function toTSxmlString() 
    {        
        var formatter="";
        
        formatter+="<Selection><value>"+this.getName ()+"</value></Selection><Action><value>"+this.getAction ()+"</value></Action><Input>";
            
        if (internalArguments.length>1)
        {
            for (var i=0;i<internalArguments.length;i++)
            {
                var arg=internalArguments [i];
        
                formatter+="<value fmt=\"text\" name=\""+arg.getName ()+"\" type=\""+arg.getType ()+"\"><![CDATA["+arg.getValue()+"]]></value>";
            }
        }
        else
		{
            formatter+="<value>"+this.getInput()+"</value>";
		}	
            
        formatter+="</Input>";
                        
        return (formatter);            
    };
    /**
    *    Returns the primary SAI in XML string form, should be good for simple components
    */
    this.toSerializedString=function toSerializedString() 
    {
        var formatter="";
        
        formatter+=getClassOpen ()+"<selection>"+this.getName ()+"</selection><action>"+this.getAction()+"</action><internalArguments>";
        
        for (var i=0;i<internalArguments.length;i++)
        {
            var arg=internalArguments [i];
            formatter+="<value fmt=\"text\" name=\""+arg.getName ()+"\" type=\""+arg.getType ()+"\">"+arg.getValue()+"</value>";
        }
        
        formatter+="</internalArguments>"+getClassClose ();
                
        return (formatter);
    };
    
    if ((aSelection!==null) && (aSelection!==""))
	{
        this.setSelection(aSelection);
	}	
    
    if (aSelection!==null)
    {
        this.setSAI(aSelection,anAction,anInput,"String",aPrompt);
	}	
}

CTATSAI.prototype = Object.create(CTATBase.prototype);
CTATSAI.prototype.constructor = CTATSAI;
/**------------------------------------------------------------------------------------
 $Author$ 
 $Date$ 
 $Header$ 
 $Name$ 
 $Locker$ 
 $Log$

 -------------------------------------------------------------------------------------
 License:
 -------------------------------------------------------------------------------------
 ChangeLog:
 -------------------------------------------------------------------------------------
 Notes:
 ------------------------------------------------------------------------------------
*/

/**
 * 
 */
function CTATGuid () 
{		
	/**
	 * 
	 * @returns
	 */
	this.s4=function s4() 
	{
		return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
	};

	/**
	 * 
	 * @returns {String}
	 */
	this.guid=function guid() 
	{
		return this.s4() + this.s4() + '-' + this.s4() + '-' + this.s4() + '-' + this.s4() + '-' + this.s4() + this.s4() + this.s4();
	};
}	
/**------------------------------------------------------------------------------------
 $Author$ 
 $Date$ 
 $Header$ 
 $Name$ 
 $Locker$ 
 $Log$

 -------------------------------------------------------------------------------------
 License:
 -------------------------------------------------------------------------------------
 ChangeLog:
 -------------------------------------------------------------------------------------
 Notes:
 ------------------------------------------------------------------------------------
*/

/**
 *
 */
function CTATNameTranslator () 
{	
	CTATBase.call(this, "CTATNameTranslator","translator");
	
	/**
	* Input for this method would for example be: spreadsheet.R14C8
	* The resulting output would be: spreadsheet.H14 or with the
	* noNamespace flag you would get just H14
	*/
	this.translateFromCTAT=function translateFromCTAT (inName, noNamespace)
	{
		//useDebugging=true;
	
		debug ("translateFromCTAT ("+inName+")");
		
		if (inName.indexOf (".R")!=-1)
		{
			var outName="";
			
			var pieces=inName.split (".");
			
			var RC=pieces [1].split ("C");
			
			if (RC.length==0)
			{
				RC=pieces [1].split ("c");
			}
			
			if (RC.length==0)
			{
				debug ("Info: incoming name does not need translation");
			}
			else
			{
				var colOriginal=RC[1];
				var rowOriginal=RC[0].substr (1);
					
				debug ("Original row: " + rowOriginal + " original col: " + colOriginal);
					
				if (noNamespace==true)
					outName=colName (colOriginal).toUpperCase ()+rowOriginal;
				else
					outName=pieces [0]+"."+colName (colOriginal).toUpperCase()+rowOriginal;
					
				debug ("Translated: " + outName);
			}
		}
		else
			debug ("Info: incoming name does not need translation");		
		
		//useDebugging=false;		
		
		return (inName);
	}
	/**
	* use: var colNumber = colOrignal.match(/(\d+)/)[1];
	*/
	this.translateToCTAT=function translateToCTAT (inName)
	{

		return (inName);
	};
}

CTATNameTranslator.prototype = Object.create(CTATBase.prototype);
CTATNameTranslator.prototype.constructor = CTATNameTranslator;/**
 * 
 */
function CTATShellTools ()
{	
	CTATBase.call(this, "CTATShellTools","shelltools");
	
	var pointer=this;
	
	/**
	 * 
	 */
	this.listComponents=function listComponents ()
	{
		var getDebugger = new CTATBase("", "");
		
		getDebugger.debug ("listComponents ()");
		
		for (var i=0;i<components.length;i++)
		{
			var ref=components [i];
			
			getDebugger.debug ("Obtaining component for " + ref.name + " with type: " + ref.type);
			
			var component=ref.getComponentPointer ();
			
			if (component!=null)
			{
				getDebugger.debug ("Component: " + component.getName () + " of instance: " + component.getClassName ());
			}
			else
				getDebugger.debug ("Error: component pointer is null");
		}	
	};
	/**
	 * Helper function to get the current date in milliseconds.
	 * @return number of milliseconds in current time.
	 */
	this.getCurrentMs=function getCurrentMs()
	{
		var now = new Date();
	
		return (now.valueOf());
	};	
	
	/**
	 * Used to grab the component name from <value> tag in the SAI for
	 * grouped components such as radio buttons. This allows us to include
	 * colons in a group name (provided it is allowed in AS3).
	 */
	 this.getNameFromGroup=function getNameFromGroup (nameLabelPair)
	 {
	 	var pair=nameLabelPair.split(" ");
	 	return (pair[0].substring(0, pair[0].length-1));
	 };
	
	/**
	 * aCompName is only needed for component groups such as radio buttons. We only
	 * get the name of the component group, which is only half useful. The actual
	 * component name is also needed.
	 */
	this.findComponent=function findComponent (aName, aCompName)
	{
		pointer.debug("findComponent("+aName+") -> " + components.length);

		for (var i=0;i<components.length;i++)
		{
			var aDesc=components [i];

			if (aDesc==null)
			{
				pointer.debug ("Internal error parsing component at index " + i);
				return;
			}
			
			if (aDesc.name==null)
			{

				pointer.debug ("Internal error parsing component at index " + i + " (no name attribute available)");
				return;
			}
									
			if (aDesc.name==aName)
			{
				pointer.debug ("Found a component description, returning pointer ...");
				return (aDesc.getComponentPointer ());
			}
			
			//Needed for things like radio buttons, and check boxes
			//*In this case, aName is the group name, not component name
			if (aDesc.groupName==aName)
			{
				pointer.debug ("Found the component group, searching for component ...");
				
				if(aDesc.name==pointer.getNameFromGroup (aCompName))
				{
					return (aDesc.getComponentPointer ());
				}
			}
		}
		
		return (null);
	};
	/**
	 * 
	 */
	this.findComponentByClass=function findComponentByClass (aClass)
	{
		pointer.debug("findComponentByClass("+aClass+") -> " + components.length);
		
		for (var i=0;i<components.length;i++)
		{
			var aDesc=components [i];

			if (aDesc==null)
			{
				pointer.debug ("Internal error parsing component at index " + i);
				return;
			}
			
			if (aDesc.getComponentPointer ()!=null)
			{
				if (aDesc.getComponentPointer ().getClassName ()==aClass)
				{
					pointer.debug ("Found a component description, returning pointer ...");
				
					return (aDesc.getComponentPointer ());
				}
			}	
		}
		
		return (null);
	};
}

CTATShellTools.prototype = Object.create(CTATBase.prototype);
CTATShellTools.prototype.constructor = CTATShellTools;
/**------------------------------------------------------------------------------------
 $Author$ 
 $Date$ 
 $Header$ 
 $Name$ 
 $Locker$ 
 $Log$

 -------------------------------------------------------------------------------------
 License:
 -------------------------------------------------------------------------------------
 ChangeLog:
 -------------------------------------------------------------------------------------
 Notes:
 ------------------------------------------------------------------------------------
*/

/**
 * 
 */
function CTATVariable () 
{		
	this.name="";
	this.value="";
}
/**------------------------------------------------------------------------------------
 $Author$ 
 $Date$ 
 $Header$ 
 $Name$ 
 $Locker$ 
 $Log$

 -------------------------------------------------------------------------------------
 License:
 -------------------------------------------------------------------------------------
 ChangeLog:
 -------------------------------------------------------------------------------------
 Notes:
 
 http://stackoverflow.com/questions/22512097/parsexml-returns-invalid-xml-in-google-apps-script
 
 ------------------------------------------------------------------------------------
*/

/**
 * 
 */
function CTATXML () 
{	
	CTATBase.call(this, "CTATXML","xml");
	
	/**
	 * 
	 * @returns
	 */
	this.parseXML=function parseXML (aMessage)
	{
		this.debug ("parseXML ()");
		
		//this.debug ("message: " + aMessage);
				
		var xmlDoc=null;
						
		try
		{
			xmlDoc = $.parseXML(aMessage);
		}
		catch (err)
		{
			if (xmlDoc!=null)
			{
				this.debug ("JQuery could not process the provided XML: " + err.message + " ("+xmlDoc.parseError.errorCode+") ("+xmlDoc.parseError.reason + ") (" + xmlDoc.parseError.line + ")");
			}
			else
			{
				this.debug ("JQuery could not process the provided XML (xmlDoc==null): " + err.message);
			}			
			
			return (null);		
		}
		
		this.debug ("Parsing complete, checking and converting ...");
		
		if (xmlDoc==null)
		{
			this.debug ("Unspecified error parsing xml message. xmlDoc is null");
			
			return (null);
		}
				 
		$xml=$(xmlDoc);
		
		this.debug ("parseXML () done");
				
		return (xmlDoc.documentElement);
	};	
	/**
	*
	*/
	this.getElementName=function getElementName (anElement)
	{
		return (anElement.nodeName);
	};
	/**
	*
	*/
	this.getElementValue=function getElementValue (anElement)
	{
		return (anElement.nodeValue);
	};	
	/**
	*
	*/
	this.getElementChildren=function getElementChildren (anElement)
	{
		return (anElement.childNodes);
	};	
	/**
	 * This method can handle the following cases:
	 * 
	 *	<Action>UpdateTextField</Action> 
	 * 
	 *	<Action>
	 *		<value>UpdateTextField</value>
	 *	</Action>
	 */
	this.getNodeTextValue=function getNodeTextValue (aNode)
	{
		if (aNode==null)
		{
			//this.debug ("Node argument is null");
			return ("");
		}
		
		if (aNode.childNodes==null)
		{
			//this.debug ("Node does not have any children");
			return ("");
		}	
		
		if (aNode.childNodes.length==0)
		{
			//this.debug ("Node has children size of 0");
			return ("");
		}	
		
		//this.debug ("First do a check to see if it has a 'value' sub element");
		
		var entries=aNode.childNodes;

		for (var t=0;t<entries.length;t++)
		{
			var entry=entries [t];
			
			if ((entry.nodeName=="value") || (entry.nodeName=="Value"))
			{
				if(entry.childNodes.length==1)
				{
					//this.debug ("Data: ("+entry.childNodes[0].nodeName+")" + entry.childNodes[0].nodeValue);
								
					return (entry.childNodes[0].nodeValue);
				}
				else
				{
					//this.debug ("Data: ("+entry.childNodes[1].nodeName+")" + entry.childNodes[1].nodeValue);
					
					return (entry.childNodes[1].nodeValue);					
				}
			}
		}	
		
		//this.debug ("Bottoming out ...");
		
		return (aNode.childNodes[0].nodeValue);
	};
	
	/**
	*
	*/
	this.xmlToString=function xmlToString(xmlData) 
	{	
		this.debug ("xmlToString ()");
		
		if (xmlData==null)
		{
			this.debug ("Error: xml data is null");
			return (null);
		}
	
		var xmlString=null;
		
		//IE
		if (window.ActiveXObject)
		{
			xmlString = xmlData.xml;
		}
		// code for Mozilla, Firefox, Opera, etc.
		else
		{
			xmlString = (new XMLSerializer()).serializeToString(xmlData);
		}
		return xmlString;
	};
}	

CTATXML.prototype = Object.create(CTATBase.prototype);
CTATXML.prototype.constructor = CTATXML;
/**
 * This script gives you the zone info key representing your device's time zone setting.
 *
 * @name jsTimezoneDetect
 * @version 1.0.5
 * @author Jon Nylander
 * @license MIT License - http://www.opensource.org/licenses/mit-license.php
 *
 * For usage and examples, visit:
 * http://pellepim.bitbucket.org/jstz/
 *
 * Copyright (c) Jon Nylander
 */

/*jslint undef: true */
/*global console, exports*/

(function(root) {
  /**
   * Namespace to hold all the code for timezone detection.
   */
  var jstz = (function () {
      'use strict';
      var HEMISPHERE_SOUTH = 's',
          
          /**
           * Gets the offset in minutes from UTC for a certain date.
           * @param {Date} date
           * @returns {Number}
           */
          get_date_offset = function (date) {
              var offset = -date.getTimezoneOffset();
              return (offset !== null ? offset : 0);
          },

          get_date = function (year, month, date) {
              var d = new Date();
              if (year !== undefined) {
                d.setFullYear(year);
              }
              d.setMonth(month);
              d.setDate(date);
              return d;
          },

          get_january_offset = function (year) {
              return get_date_offset(get_date(year, 0 ,2));
          },

          get_june_offset = function (year) {
              return get_date_offset(get_date(year, 5, 2));
          },

          /**
           * Private method.
           * Checks whether a given date is in daylight saving time.
           * If the date supplied is after august, we assume that we're checking
           * for southern hemisphere DST.
           * @param {Date} date
           * @returns {Boolean}
           */
          date_is_dst = function (date) {
              var is_southern = date.getMonth() > 7,
                  base_offset = is_southern ? get_june_offset(date.getFullYear()) : 
                                              get_january_offset(date.getFullYear()),
                  date_offset = get_date_offset(date),
                  is_west = base_offset < 0,
                  dst_offset = base_offset - date_offset;
                  
              if (!is_west && !is_southern) {
                  return dst_offset < 0;
              }

              return dst_offset !== 0;
          },

          /**
           * This function does some basic calculations to create information about
           * the user's timezone. It uses REFERENCE_YEAR as a solid year for which
           * the script has been tested rather than depend on the year set by the
           * client device.
           *
           * Returns a key that can be used to do lookups in jstz.olson.timezones.
           * eg: "720,1,2". 
           *
           * @returns {String}
           */

          lookup_key = function () {
              var january_offset = get_january_offset(),
                  june_offset = get_june_offset(),
                  diff = january_offset - june_offset;

              if (diff < 0) {
                  return january_offset + ",1";
              } else if (diff > 0) {
                  return june_offset + ",1," + HEMISPHERE_SOUTH;
              }

              return january_offset + ",0";
          },

          /**
           * Uses get_timezone_info() to formulate a key to use in the olson.timezones dictionary.
           *
           * Returns a primitive object on the format:
           * {'timezone': TimeZone, 'key' : 'the key used to find the TimeZone object'}
           *
           * @returns Object
           */
          determine = function () {
              var key = lookup_key();
              return new jstz.TimeZone(jstz.olson.timezones[key]);
          },

          /**
           * This object contains information on when daylight savings starts for
           * different timezones.
           *
           * The list is short for a reason. Often we do not have to be very specific
           * to single out the correct timezone. But when we do, this list comes in
           * handy.
           *
           * Each value is a date denoting when daylight savings starts for that timezone.
           */
          dst_start_for = function (tz_name) {

            var ru_pre_dst_change = new Date(2010, 6, 15, 1, 0, 0, 0), // In 2010 Russia had DST, this allows us to detect Russia :)
                dst_starts = {
                    'America/Denver': new Date(2011, 2, 13, 3, 0, 0, 0),
                    'America/Mazatlan': new Date(2011, 3, 3, 3, 0, 0, 0),
                    'America/Chicago': new Date(2011, 2, 13, 3, 0, 0, 0),
                    'America/Mexico_City': new Date(2011, 3, 3, 3, 0, 0, 0),
                    'America/Asuncion': new Date(2012, 9, 7, 3, 0, 0, 0),
                    'America/Santiago': new Date(2012, 9, 3, 3, 0, 0, 0),
                    'America/Campo_Grande': new Date(2012, 9, 21, 5, 0, 0, 0),
                    'America/Montevideo': new Date(2011, 9, 2, 3, 0, 0, 0),
                    'America/Sao_Paulo': new Date(2011, 9, 16, 5, 0, 0, 0),
                    'America/Los_Angeles': new Date(2011, 2, 13, 8, 0, 0, 0),
                    'America/Santa_Isabel': new Date(2011, 3, 5, 8, 0, 0, 0),
                    'America/Havana': new Date(2012, 2, 10, 2, 0, 0, 0),
                    'America/New_York': new Date(2012, 2, 10, 7, 0, 0, 0),
                    'Europe/Helsinki': new Date(2013, 2, 31, 5, 0, 0, 0),
                    'Pacific/Auckland': new Date(2011, 8, 26, 7, 0, 0, 0),
                    'America/Halifax': new Date(2011, 2, 13, 6, 0, 0, 0),
                    'America/Goose_Bay': new Date(2011, 2, 13, 2, 1, 0, 0),
                    'America/Miquelon': new Date(2011, 2, 13, 5, 0, 0, 0),
                    'America/Godthab': new Date(2011, 2, 27, 1, 0, 0, 0),
                    'Europe/Moscow': ru_pre_dst_change,
                    'Asia/Amman': new Date(2013, 2, 29, 1, 0, 0, 0),
                    'Asia/Beirut': new Date(2013, 2, 31, 2, 0, 0, 0),
                    'Asia/Damascus': new Date(2013, 3, 6, 2, 0, 0, 0),
                    'Asia/Jerusalem': new Date(2013, 2, 29, 5, 0, 0, 0),
                    'Asia/Yekaterinburg': ru_pre_dst_change,
                    'Asia/Omsk': ru_pre_dst_change,
                    'Asia/Krasnoyarsk': ru_pre_dst_change,
                    'Asia/Irkutsk': ru_pre_dst_change,
                    'Asia/Yakutsk': ru_pre_dst_change,
                    'Asia/Vladivostok': ru_pre_dst_change,
                    'Asia/Baku': new Date(2013, 2, 31, 4, 0, 0),
                    'Asia/Yerevan': new Date(2013, 2, 31, 3, 0, 0),
                    'Asia/Kamchatka': ru_pre_dst_change,
                    'Asia/Gaza': new Date(2010, 2, 27, 4, 0, 0),
                    'Africa/Cairo': new Date(2010, 4, 1, 3, 0, 0),
                    'Europe/Minsk': ru_pre_dst_change,
                    'Pacific/Apia': new Date(2010, 10, 1, 1, 0, 0, 0),
                    'Pacific/Fiji': new Date(2010, 11, 1, 0, 0, 0),
                    'Australia/Perth': new Date(2008, 10, 1, 1, 0, 0, 0)
                };

              return dst_starts[tz_name];
          };

      return {
          determine: determine,
          date_is_dst: date_is_dst,
          dst_start_for: dst_start_for 
      };
  }());

  /**
   * Simple object to perform ambiguity check and to return name of time zone.
   */
  jstz.TimeZone = function (tz_name) {
      'use strict';
        /**
         * The keys in this object are timezones that we know may be ambiguous after
         * a preliminary scan through the olson_tz object.
         *
         * The array of timezones to compare must be in the order that daylight savings
         * starts for the regions.
         */
      var AMBIGUITIES = {
              'America/Denver':       ['America/Denver', 'America/Mazatlan'],
              'America/Chicago':      ['America/Chicago', 'America/Mexico_City'],
              'America/Santiago':     ['America/Santiago', 'America/Asuncion', 'America/Campo_Grande'],
              'America/Montevideo':   ['America/Montevideo', 'America/Sao_Paulo'],
              'Asia/Beirut':          ['Asia/Amman', 'Asia/Jerusalem', 'Asia/Beirut', 'Europe/Helsinki','Asia/Damascus'],
              'Pacific/Auckland':     ['Pacific/Auckland', 'Pacific/Fiji'],
              'America/Los_Angeles':  ['America/Los_Angeles', 'America/Santa_Isabel'],
              'America/New_York':     ['America/Havana', 'America/New_York'],
              'America/Halifax':      ['America/Goose_Bay', 'America/Halifax'],
              'America/Godthab':      ['America/Miquelon', 'America/Godthab'],
              'Asia/Dubai':           ['Europe/Moscow'],
              'Asia/Dhaka':           ['Asia/Yekaterinburg'],
              'Asia/Jakarta':         ['Asia/Omsk'],
              'Asia/Shanghai':        ['Asia/Krasnoyarsk', 'Australia/Perth'],
              'Asia/Tokyo':           ['Asia/Irkutsk'],
              'Australia/Brisbane':   ['Asia/Yakutsk'],
              'Pacific/Noumea':       ['Asia/Vladivostok'],
              'Pacific/Tarawa':       ['Asia/Kamchatka', 'Pacific/Fiji'],
              'Pacific/Tongatapu':    ['Pacific/Apia'],
              'Asia/Baghdad':         ['Europe/Minsk'],
              'Asia/Baku':            ['Asia/Yerevan','Asia/Baku'],
              'Africa/Johannesburg':  ['Asia/Gaza', 'Africa/Cairo']
          },

          timezone_name = tz_name,
          
          /**
           * Checks if a timezone has possible ambiguities. I.e timezones that are similar.
           *
           * For example, if the preliminary scan determines that we're in America/Denver.
           * We double check here that we're really there and not in America/Mazatlan.
           *
           * This is done by checking known dates for when daylight savings start for different
           * timezones during 2010 and 2011.
           */
          ambiguity_check = function () {
              var ambiguity_list = AMBIGUITIES[timezone_name],
                  length = ambiguity_list.length,
                  i = 0,
                  tz = ambiguity_list[0];

              for (; i < length; i += 1) {
                  tz = ambiguity_list[i];

                  if (jstz.date_is_dst(jstz.dst_start_for(tz))) {
                      timezone_name = tz;
                      return;
                  }
              }
          },

          /**
           * Checks if it is possible that the timezone is ambiguous.
           */
          is_ambiguous = function () {
              return typeof (AMBIGUITIES[timezone_name]) !== 'undefined';
          };

      if (is_ambiguous()) {
          ambiguity_check();
      }

      return {
          name: function () {
              return timezone_name;
          }
      };
  };

  jstz.olson = {};

  /*
   * The keys in this dictionary are comma separated as such:
   *
   * First the offset compared to UTC time in minutes.
   *
   * Then a flag which is 0 if the timezone does not take daylight savings into account and 1 if it
   * does.
   *
   * Thirdly an optional 's' signifies that the timezone is in the southern hemisphere,
   * only interesting for timezones with DST.
   *
   * The mapped arrays is used for constructing the jstz.TimeZone object from within
   * jstz.determine_timezone();
   */
  jstz.olson.timezones = {
      '-720,0'   : 'Pacific/Majuro',
      '-660,0'   : 'Pacific/Pago_Pago',
      '-600,1'   : 'America/Adak',
      '-600,0'   : 'Pacific/Honolulu',
      '-570,0'   : 'Pacific/Marquesas',
      '-540,0'   : 'Pacific/Gambier',
      '-540,1'   : 'America/Anchorage',
      '-480,1'   : 'America/Los_Angeles',
      '-480,0'   : 'Pacific/Pitcairn',
      '-420,0'   : 'America/Phoenix',
      '-420,1'   : 'America/Denver',
      '-360,0'   : 'America/Guatemala',
      '-360,1'   : 'America/Chicago',
      '-360,1,s' : 'Pacific/Easter',
      '-300,0'   : 'America/Bogota',
      '-300,1'   : 'America/New_York',
      '-270,0'   : 'America/Caracas',
      '-240,1'   : 'America/Halifax',
      '-240,0'   : 'America/Santo_Domingo',
      '-240,1,s' : 'America/Santiago',
      '-210,1'   : 'America/St_Johns',
      '-180,1'   : 'America/Godthab',
      '-180,0'   : 'America/Argentina/Buenos_Aires',
      '-180,1,s' : 'America/Montevideo',
      '-120,0'   : 'America/Noronha',
      '-120,1'   : 'America/Noronha',
      '-60,1'    : 'Atlantic/Azores',
      '-60,0'    : 'Atlantic/Cape_Verde',
      '0,0'      : 'UTC',
      '0,1'      : 'Europe/London',
      '60,1'     : 'Europe/Berlin',
      '60,0'     : 'Africa/Lagos',
      '60,1,s'   : 'Africa/Windhoek',
      '120,1'    : 'Asia/Beirut',
      '120,0'    : 'Africa/Johannesburg',
      '180,0'    : 'Asia/Baghdad',
      '180,1'    : 'Europe/Moscow',
      '210,1'    : 'Asia/Tehran',
      '240,0'    : 'Asia/Dubai',
      '240,1'    : 'Asia/Baku',
      '270,0'    : 'Asia/Kabul',
      '300,1'    : 'Asia/Yekaterinburg',
      '300,0'    : 'Asia/Karachi',
      '330,0'    : 'Asia/Kolkata',
      '345,0'    : 'Asia/Kathmandu',
      '360,0'    : 'Asia/Dhaka',
      '360,1'    : 'Asia/Omsk',
      '390,0'    : 'Asia/Rangoon',
      '420,1'    : 'Asia/Krasnoyarsk',
      '420,0'    : 'Asia/Jakarta',
      '480,0'    : 'Asia/Shanghai',
      '480,1'    : 'Asia/Irkutsk',
      '525,0'    : 'Australia/Eucla',
      '525,1,s'  : 'Australia/Eucla',
      '540,1'    : 'Asia/Yakutsk',
      '540,0'    : 'Asia/Tokyo',
      '570,0'    : 'Australia/Darwin',
      '570,1,s'  : 'Australia/Adelaide',
      '600,0'    : 'Australia/Brisbane',
      '600,1'    : 'Asia/Vladivostok',
      '600,1,s'  : 'Australia/Sydney',
      '630,1,s'  : 'Australia/Lord_Howe',
      '660,1'    : 'Asia/Kamchatka',
      '660,0'    : 'Pacific/Noumea',
      '690,0'    : 'Pacific/Norfolk',
      '720,1,s'  : 'Pacific/Auckland',
      '720,0'    : 'Pacific/Tarawa',
      '765,1,s'  : 'Pacific/Chatham',
      '780,0'    : 'Pacific/Tongatapu',
      '780,1,s'  : 'Pacific/Apia',
      '840,0'    : 'Pacific/Kiritimati'
  };

  if (typeof exports !== 'undefined') {
    exports.jstz = jstz;
  } else {
    root.jstz = jstz;
  }
})(this);
