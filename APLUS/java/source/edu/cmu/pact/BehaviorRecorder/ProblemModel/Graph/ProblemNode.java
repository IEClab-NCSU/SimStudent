/*
 * Created on Mar 9, 2005
 *
 */
package edu.cmu.pact.BehaviorRecorder.ProblemModel.Graph;

import java.awt.Rectangle;
import java.awt.geom.Rectangle2D;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.Iterator;
import java.util.List;
import java.util.Vector;

import org.jdom.Element;
import org.jgraph.graph.GraphLayoutCache;

import edu.cmu.pact.BehaviorRecorder.Controller.BR_Controller;
import edu.cmu.pact.BehaviorRecorder.ProblemModel.ProblemModel;
import edu.cmu.pact.BehaviorRecorder.ProblemModel.ProblemStateWriter;
import edu.cmu.pact.BehaviorRecorder.View.BRPanel;
import edu.cmu.pact.BehaviorRecorder.View.NodeView;
import edu.cmu.pact.BehaviorRecorder.jgraphwindow.BR_JGraphNode;
import edu.cmu.pact.BehaviorRecorder.jgraphwindow.BR_JGraphVertexView;
import edu.cmu.pact.BehaviorRecorder.jgraphwindow.JGraphController;
import edu.cmu.pact.BehaviorRecorder.jgraphwindow.JGraphPanel;
import edu.cmu.pact.Utilities.Utils;
import edu.cmu.pact.Utilities.trace;
import edu.cmu.pact.miss.Rule;

public class ProblemNode implements Serializable {
	private static final long serialVersionUID = -1362273373937073806L;

	/** Tag name for element generated by {@link #toElement()}. */
    public static final String ELEMENT_NAME = "node";

    private NodeView nodeView;
    private int outDegree;
    private int nodeOrder;
    private int uniqueID;

    // A parent node whose out going edge is coming into this node.

    // Note to Other People: Whoever created these names managed to add new nodes backwards
    // Meaning, the firstNode in ProblemGraph will always be set to the newest node, and hence
    // this is why prevNode and nextNode are like this. -kzhao

    // The name "next" is not appropriate. 
    private ProblemNode nextNode;

    // A child node where an edge from this node is coming into.
    // The name "prev" is quite confusing.  
    private ProblemNode prevNode;

    /** Principal link to the rest of the system. */
    private ProblemModel problemModel;
    private BR_JGraphNode jGraphNode;
    private boolean doneState = false;

    /** Node name as it appears on the graph and in the <text> child of the BRD's <node> element. */
    private String name;

    /**
     * @return {@link #getName()}
     * @see java.lang.Object#toString()
     */
    public String toString() {
        return getName();
    }

    // ////////// Constructors ////////////
    /**
     * Prevent use of the default (no-argument) constructor.
     */
    public ProblemNode() {}

    /**
     * Convenience constructor for when no author UI is present.
     * Equivalent to {@link #ProblemNode(NodeView, ProblemModel) ProblemNode(null, problemModel)}.  
     * @param problemModel the problem model instance
     */
    public ProblemNode(ProblemModel problemModel, String name) {
        this(null, name, problemModel);
    }
    
    public ProblemNode(NodeView nodeView, ProblemModel problemModel) {
        this(nodeView, null, problemModel);
    }

    public ProblemNode(NodeView nodeView, String name, ProblemModel problemModel) {
    	if (trace.getDebugCode("node"))
    		trace.out("node", ">>>ProblemNode("+nodeView+","+name+","+problemModel+")");
        if (nodeView != null) {
            this.nodeView = nodeView;
            this.nodeView.setProblemNode(this);
            this.name = nodeView.getText();
        } else {
            this.name = name;
        }
        this.problemModel = problemModel;
        uniqueID = problemModel.getNodeUniqueIDGenerator();
        this.outDegree = 0;
        this.setPrevNode(null);
        this.setNextNode(null);
    }

    public NodeView getNodeView() {
        return this.nodeView;
    }

    /**
     * @param nextNode
     *            The nextNode to set.
     */
    public void setNextNode(ProblemNode nextNode) {
        this.nextNode = nextNode;
    }

    /**
     * @return Returns the nextNode.
     */
    public ProblemNode getNextNode() {
        return nextNode;
    }

    /**
     * @param prevNode
     *            The prevNode to set.
     */
    public void setPrevNode(ProblemNode prevNode) {
        this.prevNode = prevNode;
    }

    /**
     * @return Returns the prevNode.
     */
    public ProblemNode getPrevNode() {
        return prevNode;
    }

    /**
     * @param outDegree
     *            The outDegree to set.
     */
    void setOutDegree(int outDegree) {
        this.outDegree = outDegree;
    }

    /**
     * @return Returns the outDegree.
     */
    public int getOutDegree() {
        return outDegree;
    }

    /**
     * @param nodeOrder
     *            The nodeOrder to set.
     */
    void setNodeOrder(int nodeOrder) {
        this.nodeOrder = nodeOrder;
    }

    /**
     * @return Returns the nodeOrder.
     */
    int getNodeOrder() {
        return nodeOrder;
    }

    public int getInDegree() {
    	return getIncomingEdges().size();
    }

    public List<ProblemEdge> getIncomingEdges() {
        ArrayList<ProblemEdge> list = new ArrayList<ProblemEdge>();
        for (Enumeration<ProblemEdge> iterEdges = problemModel
                .getProblemGraph().getIncomingEdges(this); iterEdges.hasMoreElements();) {
            ProblemEdge edge = (ProblemEdge) iterEdges.nextElement();
            list.add(edge);
        }
        return list;
    }

   /* public List<ProblemEdge> getIncomingEdges() {
        ArrayList list = new ArrayList();
        for (Enumeration iterEdges = problemModel
                .getProblemGraph().getIncomingEdges(this); iterEdges.hasMoreElements();) {
            ProblemEdge edge = (ProblemEdge) iterEdges.nextElement();
            list.add(edge);
        }
        return list;
    }*/
    public List<ProblemEdge> getConnectingEdges(){
    	 ArrayList<ProblemEdge> list = new ArrayList<ProblemEdge>();
         for (Enumeration<ProblemEdge> iterEdges = problemModel
                 .getProblemGraph().getConnectingEdges(this); iterEdges.hasMoreElements();) {
             ProblemEdge edge = (ProblemEdge) iterEdges.nextElement();
             list.add(edge);
         }
         return list;
    }
    /**
     * 
     * @return Returns a list of the outgoing edges of this node.
     */
    public List<ProblemEdge> getOutgoingEdges() {
        ArrayList<ProblemEdge> list = new ArrayList<ProblemEdge>();
        for (Enumeration<ProblemEdge> iterEdges = problemModel.getProblemGraph().getOutgoingEdges(this); iterEdges.hasMoreElements();) {
            ProblemEdge edge = (ProblemEdge) iterEdges.nextElement();
            list.add(edge);
        }
        return list;
    }

    // ///////////////////////////////////////////////////////////////////////////
    /**
     * test whether nodeTest has one and only one Correct or Firable-Bug child
     * link.
     */
    // ///////////////////////////////////////////////////////////////////////////
    private boolean hasSingleValidOutLink(ProblemNode nodeTest) {
        ProblemEdge edgeTemp = null;
        int validLinkcount = 0;
        Enumeration<ProblemEdge> iterEdges = problemModel.getProblemGraph()
        .getOutgoingEdges(nodeTest);

        while (iterEdges.hasMoreElements()) {
            edgeTemp = (ProblemEdge) iterEdges.nextElement();
            if (edgeTemp.isCorrectorFireableBuggy())
                validLinkcount++;

            if (validLinkcount > 1)
                return false;
        }

        if (validLinkcount == 0)
            return false;

        return true;
    }

    private boolean isEdgeExist(ProblemEdge edgeTest) {
        ProblemEdge edgeTemp;

        Enumeration<ProblemEdge> iter = problemModel.getProblemGraph()
        .edges();
        while (iter.hasMoreElements()) {
            edgeTemp = (ProblemEdge) iter.nextElement();
            if (edgeTemp == edgeTest)
                return true;
        }

        return false;
    }

    
public Vector findPathDepthFirst_forJessOracle(ProblemNode /*SimStNode*/ startNode, ProblemNode /*SimStNode*/ endNode){
		
		/* Base case */
		if(startNode == endNode)
			return null;
		
		/* Recursive case */
		ProblemEdge edge = null;
		if((edge = (ProblemEdge) (startNode.isChildNode(endNode))) != null){
			Vector path = new Vector();
			path.add(0, edge);
			return path;
		} else {
			Vector children = startNode.getChildren();
			if(children.isEmpty())
				return null;
			for(int i=0; i < children.size(); i++){
				ProblemNode childNode = (ProblemNode) children.elementAt(i);
				Vector path = findPathDepthFirst_forJessOracle(childNode, endNode);
				if(path != null) {
					path.add(0, startNode.isChildNode(childNode));
					return path;
				}
			}
			return null;
		}
	}


    // based on Vincent's suggestion only compare Selection
    public static boolean isEdgesListsOverlap(Vector edgesList1, Vector edgesList2) {

        if (edgesList1 == null || edgesList2 == null)
            return false;

        if (edgesList1.size() == 0 || edgesList2.size() == 0)
            return false;

        ProblemEdge edgeTemp1;
        ProblemEdge edgeTemp2;

        EdgeData myEdgeTemp;

        Vector selection1;
        Vector selection2;

        for (int i = 0; i < edgesList1.size(); i++) {
            edgeTemp1 = (ProblemEdge) edgesList1.elementAt(i);
            myEdgeTemp = edgeTemp1.getEdgeData();
            selection1 = myEdgeTemp.getSelection();
            for (int j = 0; j < edgesList2.size(); j++) {
                edgeTemp2 = (ProblemEdge) edgesList2.elementAt(j);
                myEdgeTemp = edgeTemp2.getEdgeData();
                selection2 = myEdgeTemp.getSelection();

                if (selection1.toString().equalsIgnoreCase(
                        selection2.toString()))
                    return true;
            }
        }

        return false;
    }

    // recursive method to find ThisNode children
    public void findDescendentEdgesList(ProblemNode atNode,
            Vector descendentEdgesList) {
        if (problemModel.isLeaf(atNode))
            return;

        ProblemEdge edgeTemp;
        Enumeration<ProblemEdge> iter = problemModel.getProblemGraph()
        .getOutgoingEdges(atNode);
        while (iter.hasMoreElements()) {
            edgeTemp = (ProblemEdge) iter.nextElement();
            if (!ProblemModel.testEdgeInVector(edgeTemp, descendentEdgesList)) {
                descendentEdgesList.addElement(edgeTemp);
                findDescendentEdgesList(edgeTemp.getNodes()[ProblemEdge.DEST],
                        descendentEdgesList);
            }
        }

        return;
    }

    public Vector findLockedParentEdgesList(Vector parentEdgesList) {
        Vector lockedParentEdgesList = new Vector();
        ProblemEdge edgeTemp;

        for (int i = 0; i < parentEdgesList.size(); i++) {
            edgeTemp = (ProblemEdge) parentEdgesList.elementAt(i);
            addEdgeToList(edgeTemp, lockedParentEdgesList);
        }

        return lockedParentEdgesList;
    }

    private void addEdgeToList(ProblemEdge edgeAdd, Vector lockedParentEdgesList) {

        if (edgeAdd == null || lockedParentEdgesList == null)
            return;

        EdgeData myEdgeAdd = edgeAdd.getEdgeData();
        if (!myEdgeAdd.getActionType()
                .equalsIgnoreCase(EdgeData.CORRECT_ACTION))
            return;

        ProblemEdge edgeTemp;
        for (int i = 0; i < lockedParentEdgesList.size(); i++) {
            edgeTemp = (ProblemEdge) lockedParentEdgesList.elementAt(i);
            if (problemModel.compareTwoStatesSame(edgeAdd,
                    edgeTemp, false))
                return;
        }

        lockedParentEdgesList.addElement(edgeAdd);

        return;
    }

    /**
     * @return
     */
    public boolean isLeaf() {
        return problemModel.isLeaf(this);
    }
    
    public boolean isBuggyNode(){
    	return problemModel.isBuggyNode(this);
    }
    /**
     * @return
     */
    public Vector getParents() {
        Vector v = new Vector();

        Enumeration parents = problemModel.getProblemGraph().parents(this);

        while (parents.hasMoreElements()) {
            ProblemNode node1 = (ProblemNode) parents.nextElement();
            v.addElement(node1);
        }
        return v;
    }
    public boolean hasOutGoingPreferredEdge(ProblemEdge excludeEdge){
    	List<ProblemEdge> targetOutEdges = getOutgoingEdges();
		int i;
		ProblemEdge tempEdge;
    	for(i=0; i < targetOutEdges.size(); i++){
    		tempEdge = targetOutEdges.get(i);
    		if(tempEdge == excludeEdge)
    			continue;
			if(tempEdge.isPreferredEdge()){
				return true;
			}
		}
    	return false;
    }
    /**
     * Returns the children and parents of this node
     * 
     * @return
     */
    public Vector getNeighbors() {
        Vector v = new Vector();

        Enumeration neighbors = problemModel.getProblemGraph()
        .neighbors(this);

        while (neighbors.hasMoreElements()) {
            ProblemNode node1 = (ProblemNode) neighbors.nextElement();
            v.addElement(node1);
        }
        return v;
    }

    // See if the node is a child node of this ProblemNode, and if so, return a ProblemEdge 
    // between the node and this ProblemNode
    public ProblemEdge isChildNode(ProblemNode node) {
        List<ProblemEdge> /* ProblemEdge */ outgoingEdges = getOutgoingEdges();
        for (int i = 0; i < outgoingEdges.size(); i++) {
            ProblemEdge problemEdge = (ProblemEdge)outgoingEdges.get(i);
            if (node.equals(problemEdge.getDest())) {
                return problemEdge;
            }
        }
        return null;
    }

    public Vector<ProblemNode> getChildren() {

        Vector<ProblemNode> children = new Vector<ProblemNode>();

        List<ProblemEdge> outgoingEdges = getOutgoingEdges();
        for (Iterator iter = outgoingEdges.iterator(); iter.hasNext();) {
            ProblemEdge problemEdge = (ProblemEdge) iter.next();
            children.add(problemEdge.getDest());
        }
        return children;
    }

    /**
     * @return {@link #uniqueID} if {@link #name} is null or empty
     */
    public String getName() {
        return (name != null && name.length() > 0 ? name : Integer.toString(uniqueID));
    }

    /**
     * @param name new value for {@link #name}
     */
    public void setName(String name) {
        String oldName = this.name;
    	if (trace.getDebugCode("node"))
    		trace.out("node", ">>>ProblemNode.setName("+name+") oldName "+oldName);
        this.name = name;
        if (problemModel != null)
            problemModel.renameNode(this, oldName, name);
    }
    
    /**
     * Tue Oct 25 10:49:59 2005:: Noboru
     * 
     * Simply follow a path from this problem node all the way down a dead-end
     * and returns that node. Wrote to get a "DONE" node given a start node for
     * Sim. St. evaluation
     * 
     * @return a <code>ProblemNode</code> value
     */


    //prev should only point to valid paths

    //public ProblemNode getDeadEnd() {
    //    return (getPrevNode() == null) ? this : getPrevNode().getDeadEnd();
    //}

    public ProblemNode getDeadEnd() {
        return (getNextCorrectChild() == null) ? this : getNextCorrectChild().getDeadEnd();
    }

    private ProblemNode getNextCorrectChild() {
        ProblemNode result = null;
        ProblemGraph pg = problemModel.getProblemGraph();
        Vector children = getChildren();
        ProblemEdge edge;
        //EdgeData edgeData;
        for (int i=0; i<children.size(); i++){
            ProblemNode child = (ProblemNode) children.get(i);
            edge = pg.lookupProblemEdge(this, child);
            //edgeData = edge.getEdgeData();
            if (edge.isCorrect()||edge.isGiven()){
                result = child;
                break;
            }
        }
        return result;
    }

    public void setJGraphNode(BR_JGraphNode jGraphNode) {
        this.jGraphNode = jGraphNode;
    }

    public BR_JGraphNode getJGraphNode() {
        return jGraphNode;
    }

    public boolean isSelectedNode() {
        if (problemModel.getController() != null)
            return problemModel.getController().getSolutionState().getCurrentNode() == this;
        else
            return false;
    }

    public boolean isDoneState() {  // redundant with getDoneState()
        return getDoneState();
    }


    /**
     *  Test whether testNode is an ancestor node of the problemNode.
     *  
     *  @param: testNode.
     *  @return: true if testNode is an ancestor of problemNod.
     */
    public boolean isAncestorNode (ProblemNode testNode) {
        Vector ancestorNodesList = new Vector();
        problemModel.findAncestorNodesList(this, ancestorNodesList);
        return problemModel.testNodeInVector(testNode, ancestorNodesList);
    }

    public BR_Controller getController() {
        return problemModel.getController();
    }

    public int getUniqueID() {
        return this.uniqueID; 
    }

    public boolean getDoneState() {
        return this.doneState;
    }

    public void setDoneState(boolean isDoneState) {
        this.doneState = isDoneState;
    }

    public void setUniqueID(int uniqueIDValue) {
        uniqueID = uniqueIDValue;
        if (problemModel == null)
            return;
        problemModel.updateNodeUniqueIDGenerator(uniqueIDValue);
    }

    /**
     * Thu Oct 12 15:58:21 LDT 2006 :: Noboru
     * See if there is "incorrect action" or "error action" edge coming out from this node.
     * Needed to invent to compare SimSt and real students' performance
     * A real student's performance is marked as "SUCCESS" if the step is performed 
     * correctly at the first attempt (meaning, there is no "buggy" and "error" edges).  
     * Might only make sense when the BRD is converted 
     * from the Carnegie Learning Tutor log.
     */
    public final String ATTEMPT_SUCCESS = "SUCCESS";
    public final String ATTEMPT_ERROR = "ERROR";
    public String cltLogStatus() {
        String result = ATTEMPT_SUCCESS;
        List<ProblemEdge> outgoingEdges = getOutgoingEdges();
        for (int i = 0; i < outgoingEdges.size(); i++) {
            ProblemEdge problemEdge = (ProblemEdge)outgoingEdges.get(i);
            if (!problemEdge.isCorrect()) {
                result = ATTEMPT_ERROR;
                break;
            }
        }
        return result;
    }

    /**
     * @return the {@link #problemModel}
     */
    public ProblemModel getProblemModel() {
        return problemModel;
    }

    /**
     * @return true if this is the {@link ProblemModel#getStudentBeginsHereState()} node.
     */
    public boolean isStudentBeginsHereState() {
        ProblemNode sbhNode = problemModel.getStudentBeginsHereState();
        if (sbhNode == null)
            return false;
        else
            return sbhNode.getUniqueID() == getUniqueID();
    }

    /**
     * Tell whether this node is before the start state.
     * @return {@link ProblemModel#isBeforeStudentBegins(ProblemNode) problemModel#isBeforeStudentBegins(this)}
     */
    public boolean isBeforeStartState() {
        return problemModel.isBeforeStudentBegins(this);
    }

    // Returns a list of edges showing a "correct" solution path reachable 
    // from this ProblemNode. 
    // Returns null if no correct solution found.
    // Works only for SimStAlgebraI Tutor Interface
    public Vector<ProblemEdge> findSolutionPathAlgebra() {
        return findSolutionPathAlgebra(new String[2]);
    }

    public Vector<ProblemEdge> findSolutionPathAlgebra(String[] equation) {
        // This is a leaf node
        if (isLeaf()) {
            return new Vector<ProblemEdge>();
        }
        
        List<ProblemEdge> outEdges = getOutgoingEdges();
        Vector<ProblemEdge> path;
        ProblemEdge backupWrongAnswer = null;
        for (ProblemEdge edge : outEdges) { 
        	if (edge.isCorrect()) {
                // AlgebraV2 Tutor: "commTableX_CaRb"
                String selection = edge.getSelection();
                String input = edge.getInput();

                if(selection.equalsIgnoreCase(Rule.DONE_NAME))
                {
                	
                	path = new Vector<ProblemEdge>();
                	path.add(0,edge);
                	return path;
                }
                else
                {
	                int idx = selection.indexOf("_") -1;
	                if (idx<0){ return null;}
	                char c = selection.charAt(idx);
	                int col = c - '1' +1;
	
	                switch (col) {
	                case 1: equation[0] = input; break;
	                case 2: equation[1] = input; break;
	                case 3: equation[0] = equation[1] = null; break;
	                }

                    ProblemNode child = edge.getDest();
                    path = child.findSolutionPathAlgebra(equation);
                }
                if (path != null) {
                    path.add(0, edge);
                    return path;
                }
                else
                {
                	path = new Vector<ProblemEdge>();
                    path.add(0, edge);
                    return path;
                }
            }
            else
            {
            	if(!edge.getInput().equalsIgnoreCase("FALSE"))
            	{
            		if(backupWrongAnswer != null)
            		{
            			if(backupWrongAnswer.getDest().isLeaf() && !edge.getDest().isLeaf())
                			backupWrongAnswer = edge;
            		}
            		else
            		{
            			backupWrongAnswer = edge;
            		}
            	}
            }
        }
        if(backupWrongAnswer != null)
        {
        	
            ProblemNode child = backupWrongAnswer.getDest();
            path = child.findSolutionPathAlgebra(equation);
            
            if (path != null) {
                path.add(0, backupWrongAnswer);
                // trace.out("findSolutionPathAlgebra() returning " + path.size() + "...");
                return path;
            }
            else
            {
            	path = new Vector<ProblemEdge>();
                path.add(0, backupWrongAnswer);
                return path;
            }
        }
        return null;
    }

    private boolean isAlgebraEqSolved(String[] equation) {
        
        if (isVarTerm(equation[0])) 
            return isConstTerm(equation[1]);
        else if (isConstTerm(equation[0]))
            return isVarTerm(equation[1]);
        else 
            return false;
    }

    private boolean isConstTerm(String string) {
     
        
        if (string == null) return false;
        
        boolean isConstantTerm = true;
        
        for (int i = 0; i < string.length(); i++) {
            char c = string.charAt(i);
            if (!(c == '-' || ('0' <= c && c <= '9'))) {
                isConstantTerm = false;
                break;
            }
            
        }
        return isConstantTerm;
    }

    private boolean isVarTerm(String string) {
        
        boolean isVarTerm = (string != null &&
                string.length() == 1 &&
                "a".compareToIgnoreCase(string) <= 0 &&
                string.compareToIgnoreCase("z") <= 0);

        return isVarTerm;
        
    }
    
    /**
     * Convert to XML element suitable for brd file.
     * @return <edge> element
     */
	public Element toElement() {
		Element elt = new Element(ELEMENT_NAME);
		Element child;
		elt.setAttribute("locked", 
				Boolean.toString(nodeView == null ? false : nodeView.getLocked()));
		elt.setAttribute("doneState", Boolean.toString(getDoneState()));
        
		child = new Element("text").setText(nodeView == null ? this.name : nodeView.getText());
		elt.addContent(child);
		
		child = new Element("uniqueID").setText(Integer.toString(getUniqueID()));
		elt.addContent(child);

		Rectangle2D rect = new Rectangle(1, 1, 1, 1);
        BR_JGraphNode graphNode = getJGraphNode();
        JGraphPanel jgWindow = (getController() == null ? null : getController().getJGraphWindow());
        JGraphController jgController = (jgWindow == null ? null : jgWindow.getJGraphController());
        GraphLayoutCache graphView = (jgController == null ? null : jgController.getGraphView());
        if (graphView != null && graphNode != null) {
        	BR_JGraphVertexView jgraphNodeView = (BR_JGraphVertexView) graphView.getMapping(graphNode, false);
            rect = jgraphNodeView.getBounds();
        } else 
        	trace.err("jgraphNodeView null: graphNode "+graphNode+", graphNode "+
        		graphNode+", nodeView "+nodeView+", .text "+nodeView.getText());
        child = new Element("dimension");
        child.addContent(new Element("x").setText(Integer.toString((int) rect.getX())));
        child.addContent(new Element("y").setText(Integer.toString((int) rect.getY())));
        elt.addContent(child);
        
        return elt;
    }

    /**
     * @return multi-line, indented format of {@link #toElement()}
     */
    public String toXMLString() {
    	return ProblemStateWriter.multiLineOutputter.outputString(toElement());   	
    }
}
