/*
 * TraversedLinksModel.java
 *
 * Created on April 28, 2004, 11:20 AM
 */


/**
 *
 * @author  zzhang
 */


package edu.cmu.pact.BehaviorRecorder.SolutionStateModel;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Vector;

import org.jdom.Document;
import org.jdom.Element;
import org.jdom.JDOMException;
import org.jdom.input.SAXBuilder;
import org.jdom.output.Format;
import org.jdom.output.XMLOutputter;

import edu.cmu.pact.BehaviorRecorder.Controller.BR_Controller;
import edu.cmu.pact.Utilities.trace;
import edu.cmu.pact.ctat.MessageObject;

	//////////////////////////////////////////////////////////////////////
	/**
         *  xml DOM tree to hold/manage traversed links information
         *
	 */
	//////////////////////////////////////////////////////////////////////


public class TraversedLinksModel {

	/**
	 * Formatter for {@link #saveTraversedLinks_Tofile(String)}.  Pretty-print,
	 * preserve XML declaration	"<code>&lt;?xml ... &gt;</code>", include encoding in declaration,
	 * use \n for line separator.
	 */
	private static XMLOutputter outputter =
		new XMLOutputter(Format.getPrettyFormat().setIndent(" ").setOmitEncoding(false).setOmitDeclaration(false).setLineSeparator("\n"));
    
	private Document document; 
	String traversedLinksFileName;
        
    // tags
	final static String	TRAVERSEDLINKS_FILE = "TraversedLinks_File";
        
    final static String	LINK = "Link";
	final static String	LINK_NAME = "Link_Name";
	final static String	COMMMSG_OBJ_NAME = "CommMsgObj_Name";
	final static String	AUTHOR_INTENT_NAME = "AuthorIntent_Name"; 
	final static String	LINK_UNIQUEID_NAME = "LinkUniqueID_Name";
        
	private BR_Controller controller;
	
        
    //////////////////////////////////////////////////////////////////////
	/**
	 *      constructor
	 */
	//////////////////////////////////////////////////////////////////////
        
    public TraversedLinksModel(BR_Controller controller) {
        traversedLinksFileName = "";
		this.controller = controller;
        initDom();
    } 
	
	/**
	 * Build the empty content DOM.
	 */
	public void initDom() {
		document = makeRoot();
		if (trace.getDebugCode("br")) trace.out("br", "TRAVERSED_LINK_MODEL.initDom() "+document.hashCode());
	}   // initDom
	
	/**
	 * Build an empty content DOM.
	 * @return document node from new empty DOM.
	 */
	private Document makeRoot() {
        try {
            Element root = new Element(TRAVERSEDLINKS_FILE); 
            Document document = new Document(root);
            return document;
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }
        
	//////////////////////////////////////////////////////////////////////
	/**
	 	create a DOM from the traversedLinksFileName file
	 */
	//////////////////////////////////////////////////////////////////////
	
	public void loadTraversedLinks_Fromfile(String traversedLinksFileName)
	{

        if (traversedLinksFileName == null){
            trace.out(5, this, "traversedLinksFileName is null");
            return;
        }

        if (traversedLinksFileName.trim().equals("")){
            trace.out(5, this, "traversedLinksFileName is empty");
            return;
        }

        this.traversedLinksFileName = traversedLinksFileName;
        
        File f = new File(traversedLinksFileName);

        // no traversedLinksFileName File with traversedLinksFileName
        if (!f.exists()) {
            initDom();
            return;
        } 
		
        try {
            SAXBuilder builder = new SAXBuilder();
            document = builder.build(traversedLinksFileName);
    		if (trace.getDebugCode("br")) trace.out("br", "TRAVERSED_LINK_MODEL.loadTraversedLinks_Fromfile() "+document.hashCode());
        } catch (JDOMException je) {
        	// Error generated by this application (or a parser-initialization error)
        	trace.err("Error parsing traversed links file "+traversedLinksFileName+": "+je+"\nCause:");
        	Throwable  x = je;
        	if (je.getCause() != null)
        		x = je.getCause();
        	x.printStackTrace();
        } catch (IOException ioe) {
        	trace.err("Error parsing traversed links file "+traversedLinksFileName+": "+ioe);
        	ioe.printStackTrace();
        }
        
        return;
	} // loadTraversedLinks_Fromfile

	//////////////////////////////////////////////////////////////////////
	/**
	 	create a DOM from the XML string currentState
	 */
	//////////////////////////////////////////////////////////////////////
	
	public void loadTraversedLinks_FromXML(String currentState)
	{
		if (trace.getDebugCode("br")) trace.out("br", "load TraversedLinks_FromXML: currentState = " + currentState);
        if (currentState == null) {
        	traversedLinksFileName = "";
    		initDom();
            return;
        } 
		
        try {
            SAXBuilder builder = new SAXBuilder();
            StringReader reader = new StringReader(currentState);
            //StringBufferInputStream inputStream = new StringBufferInputStream(currentState);
            document = builder.build(reader);
    		if (trace.getDebugCode("br")) trace.out("br", "TRAVERSED_LINK_MODEL.loadTraversedLinks_FromXML() "+document.hashCode());
    		if (trace.getDebugCode("br")) trace.out("br", "Document = " + document);
        } catch (JDOMException je) {
        	// Error generated by this application (or a parser-initialization error)
        	trace.err("Error parsing traversed links XML string "+currentState+": "+je+"\nCause:");
        	Throwable  x = je;
        	if (je.getCause() != null)
        		x = je.getCause();
        	x.printStackTrace();
        } catch (IOException ioe) {
        	trace.err("Error parsing traversed links XML string "+currentState+": "+ioe);
        	ioe.printStackTrace();
        }
        
        return;
	} // loadTraversedLinks_FromXML

	//////////////////////////////////////////////////////////////////////
	/**
	 	save the dom into TraversedLinks file
	 */
	//////////////////////////////////////////////////////////////////////

	public void saveTraversedLinks_Tofile(String newTraversedLinksFileName)
	{
		if (document == null)
		{
			if (trace.getDebugCode("br")) trace.out("br", "saveTraversedLinks_Tofile(): document is null");
			return;
		}
        String savedDOMFileName = newTraversedLinksFileName;

        if (traversedLinksFileName == null)
        {
            trace.out(5, this, "traversedLinksFileName is null. Save the DOM at: " + this.traversedLinksFileName);
            savedDOMFileName = this.traversedLinksFileName;
        }
        else if (newTraversedLinksFileName.equals(""))
        {
            trace.out(5, this, "newTraversedLinksFileName is empty. Save the DOM at: " + this.traversedLinksFileName);
            savedDOMFileName = this.traversedLinksFileName;
        }

        File f = new File(savedDOMFileName);

        try
        {
        	FileWriter fw = new FileWriter(savedDOMFileName);
        	String asXML = outputter.outputString(document);
        	fw.write(asXML);
        	fw.close();
        } catch (Exception e) {
        	trace.err("Error writing traversed links file "+savedDOMFileName+": "+e);
        	e.printStackTrace();
        }
	} // saveTraversedLinks_Tofile
	
    //////////////////////////////////////////////////////////////////////
	/**
	 	get the dom into TraversedLinks XML string
	 */
	//////////////////////////////////////////////////////////////////////

	public String getTraversedLinks_asXML()
	{
		if (trace.getDebugCode("br")) trace.out("br", "getTraversedLinks_asXML(): nodes = " + getTraversedLinkNodes());
		if (document == null)
		{
			return null;
		}
        try
        {
        	return outputter.outputString(document);
        } catch (Exception e) {
        	trace.err("Error writing traversed links to XML: "+e);
        	e.printStackTrace();
        	return null;
        }
	} // getTraversedLinks_asXML

    //////////////////////////////////////////////////////////////////////
	/**
	 	get the TraversedLinkObject object from the given linkNodeName
	 */
	//////////////////////////////////////////////////////////////////////
	
	public TraversedLinkObject getTraversedLinkObject(String linkNodeName)
	{
        Element linkNode = getTraversedLinkNode(linkNodeName);

        if (linkNode == null)
            return null;

        TraversedLinkObject linkObj = get_LinkObj_From_LinkNode(linkNode);

        return linkObj;
		
	} // getTraversedLinkObject
        
    
	/**
	 * Get all TraversedLinkNode objects
	 * @return list of type {@link TraversedLinkObject}
	 */
    public Vector getTraversedLinkNodes() {
        Vector nodeList = new Vector();
    
        Element rootNode = document.getRootElement();	// TRAVERSEDLINKS_FILE
        if (rootNode == null) {
            trace.err("getTraversedLinkNodes(): rootNode is null");
            return nodeList;
        }
        List eltList = rootNode.getChildren();
        for (Iterator it = eltList.iterator(); it.hasNext(); ) {
            Element linkNode = (Element) it.next();
            TraversedLinkObject tlo = get_LinkObj_From_LinkNode(linkNode);
            nodeList.addElement(tlo);
        }
        return nodeList;
    }
        
    //////////////////////////////////////////////////////////////////////
	/**
	 	get all TraversedLinkNode names
	 */
	//////////////////////////////////////////////////////////////////////
        
    public Vector<String> getTraversedLinkNodesNames() {
        Vector<String> nameList = new Vector<String>();
    
        Element rootNode = document.getRootElement();	// TRAVERSEDLINKS_FILE
        
        if (rootNode == null) {
            trace.err("getTraversedLinkNodesNames(): rootNode is null");
            return nameList;
        }
        
        Element linkNode;
        Element nameNode;

        String nameText;

        List nodeList = rootNode.getChildren();
        if (trace.getDebugCode("br")) trace.out("br", "nodeList = " + nodeList);

        // 1st item is the parentNode name element
        for (int i=0; i<nodeList.size(); i++) {
            linkNode = (Element) nodeList.get(i);
            nameNode = linkNode.getChild(LINK_NAME);	
            nameText = nameNode.getText();

            nameList.addElement(nameText);
        }
        
        return nameList;
    }
        
        
    //////////////////////////////////////////////////////////////////////
	/**
	 	get the TraversedLinkNode object from the given linkName
     *
	 */
	//////////////////////////////////////////////////////////////////////
        
    private Element getTraversedLinkNode(String linkName) {
        Element rootNode = document.getRootElement();	// TRAVERSEDLINKS_Element
        
        List nodeList = rootNode.getChildren();
        Element linkNode;
        Element nameNode;
        String nameNodeText;

        for (int i=0; i<nodeList.size(); i++) {
            linkNode = (Element) nodeList.get(i);	
            nameNode = linkNode.getChild(LINK_NAME);
            nameNodeText = nameNode.getText();

            if (nameNodeText.equals(linkName))
            {
                if (trace.getDebugCode("mt")) trace.out("mt", "Found the matched LinkNode with linkName: " + linkName);
                
                return linkNode;
            }
        }

        if (trace.getDebugCode("mt")) trace.out("mt", "Not Found the matched linkNode with linkName: " + linkName);
        
        return null;
    }
        
        
    //////////////////////////////////////////////////////////////////////
	/**
	 	construct TraversedLinkObject from TraversedLinkNode 
	 */
	//////////////////////////////////////////////////////////////////////
        
    private TraversedLinkObject get_LinkObj_From_LinkNode(Element linkNode) {
        
        if (linkNode == null)
            return null;

        String linkName = "";
        MessageObject CommMsgObj = null;
        String authorIntent = "";
        int uniqueID = -999;
        
        Element tagNode;
        String tagNodeName;

        List nodeList = linkNode.getChildren();
        trace.out(5, this, "linkNode has " + nodeList.size() + " elements.");
        
        String tempString;
        for (int i=0; i<nodeList.size(); i++) 
        {
            tagNode = (Element) nodeList.get(i);	
            tagNodeName = tagNode.getName();

            tempString = tagNode.getText();

            if (tagNodeName.equals(LINK_NAME))
                linkName = tempString;
            else if (tagNodeName.equals(COMMMSG_OBJ_NAME))
                CommMsgObj = MessageObject.parse(tempString);
            else if (tagNodeName.equals(AUTHOR_INTENT_NAME))
                authorIntent = tempString;
            else if (tagNodeName.equals(LINK_UNIQUEID_NAME))
                uniqueID = Integer.valueOf(tempString).intValue();
            else
                trace.out(5, this, "not defined tag: " + tagNodeName);
        }
        
        return new TraversedLinkObject(linkName, CommMsgObj, authorIntent, uniqueID);  
    }

        
    //////////////////////////////////////////////////////////////////////
	/**
	 	build a child tag element node for given parentNode, tagName and elementValue:
	 	
	 	<parentNode>
	 		<tagName> elementValue </tagName>
	 */
	//////////////////////////////////////////////////////////////////////
	
	private void build_Single_Element(Element parentNode, String tagName, String elementValue)
	{
        // add section name node
        Element tagNode = new Element(tagName);
        tagNode.setText(elementValue);
        parentNode.addContent(tagNode);
	} // build_Single_Element
        
        
    //////////////////////////////////////////////////////////////////////
	/**
	 	build a TraversedLinkNode from a TraversedLinkObject
         *
         *      <Link>
                    <Link_Name> link value </Link_Name>
                    <CommMsgObj_Name> CommMsgObj value </CommMsgObj_Name>
                    <AuthorIntent_Name> AuthorIntent value </AuthorIntent_Name>
                    <LinkUniqueID_Name> LinkUniqueID value </LinkUniqueID_Name>
                </Link>

	 */
	//////////////////////////////////////////////////////////////////////
        
    private Element buildLinkNode(TraversedLinkObject linkObj) { 
        Element linkNode = new Element(LINK); 

        // add LINK_NAME node
        build_Single_Element(linkNode, LINK_NAME, linkObj.getLinkName());

        // add COMMMSG_OBJ_NAME node 
        String CommMsgObjString = linkObj.getCommMsgObj().toString();
        build_Single_Element(linkNode, COMMMSG_OBJ_NAME, CommMsgObjString);

        // add AUTHOR_INTENT_NAME node
        build_Single_Element(linkNode, AUTHOR_INTENT_NAME, linkObj.getAuthorIntent());

        // add LINK_UNIQUEID_NAME node
        build_Single_Element(linkNode, LINK_UNIQUEID_NAME, linkObj.getUniqueID() + "");

        return linkNode;
    } // buildSectionNode
        
    
    public void addLinkNode(TraversedLinkObject linkObj) {
    
        Element rootNode = document.getRootElement();	// TRAVERSEDLINKS_FILE

        Element newLinkNode = buildLinkNode(linkObj);
        
        Element existLinkNode = getTraversedLinkNode(linkObj.getLinkName());

//        if (existLinkNode.getOwnerDocument().hashCode() != newLinkNode.getOwnerDocument().hashCode()) {
//        	trace.printStack("br", "TRAVERSED_LINK_MODEL.addLinkNode() doc "+document.hashCode()+
//        			", old "+existLinkNode.getOwnerDocument().hashCode()+
//        			", new "+newLinkNode.getOwnerDocument().hashCode());
//        	System.exit(-1);
//        }
        if (existLinkNode != null) {
            boolean removed = rootNode.removeContent(existLinkNode);
            if (trace.getDebugCode("br")) trace.out("br", "removed existLinkNode "+existLinkNode);
        }
	
        // add a new link node
        rootNode.addContent(newLinkNode);   
        
        return;  
    }
    
    public void removeLinkNode(String linkName) {
        
        if (linkName == null) {
            trace.out(5, this, "linkName is null in the method removeLinkNode()");
            
            return;
        }

        if (linkName.trim().equals("")) {
            trace.out(5, this, "linkName is empty in the method removeLinkNode()");
            
            return;
        }

        Element rootNode = document.getRootElement();	// TRAVERSEDLINKS_FILE
	
        Element tempLinkNode = getTraversedLinkNode(linkName);
        
        if (tempLinkNode != null){
            rootNode.removeContent(tempLinkNode);
            
            return;
        }

        trace.out(5, this, "Not found matched linkNode with linkName: " + linkName);

        return;
    }

    /**
     * Add a link.
     * @param linkName
     * @param messageObject InterfaceAction message that generated the link.
     * @param actionType
     * @param uniqueID
     */
	public void addLinkNode(String linkName, MessageObject messageObject, String actionType, int uniqueID) {
		TraversedLinkObject tlo = new TraversedLinkObject(linkName, messageObject, actionType, uniqueID);
		addLinkNode(tlo);
	}

	/**
	 * Tell the number of links in the model.
	 * @return number of children of root node
	 */
	public int size() {
        Element rootNode = document.getRootElement();
        List children = rootNode.getChildren();
        if (children == null)
        	return 0;
        else
        	return children.size();
	}

	/**
	 * Delete the given number of links from the tail of the list.
	 * @param nLinksToDelete number of links to remove; if greater than or
	 *        equal to the total length, removes all links.
	 * @return number of links actually deleted
	 */
	public int deleteLinksFromTail(int nLinksToDelete) {
        Element rootNode = document.getRootElement();
        List children = rootNode.getChildren();
        int oldSize = children.size();
        int newSize = oldSize - nLinksToDelete;
        if (newSize <= 0) {
        	initDom();            // document now empty
        	return oldSize;       // deleted all links
        }
        Element root = document.getRootElement();
        for (int i = oldSize-1; i >= newSize; --i)
        	root.removeContent((Element) children.get(i));
		return nLinksToDelete;
	}

	
	/**
	 * Get the CommMsgs from the currently-saved links.
	 * @return list with element type MessageObject
	 */
	public List getCommMsgs() {
		Element rootNode = document.getRootElement();
		List result = new ArrayList();
		List children = rootNode.getChildren();
		for (int i = 0; i < children.size(); ++i) {
			TraversedLinkObject tlo = get_LinkObj_From_LinkNode((Element) children.get(i));
			result.add(tlo.getCommMsgObj());
		}
		return result;
	}
}

