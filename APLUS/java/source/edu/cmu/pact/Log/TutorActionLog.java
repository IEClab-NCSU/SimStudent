/*
 * $Id: TutorActionLog.java 21063 2014-08-07 19:44:35Z awang1 $
 */
package edu.cmu.pact.Log;

import java.io.IOException;
import java.io.Reader;
import java.io.StringReader;
import java.rmi.server.UID;
import java.text.DateFormat;
import java.text.ParsePosition;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;

import org.jdom.Document;
import org.jdom.Element;
import org.jdom.JDOMException;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.Format;
import org.jdom.output.XMLOutputter;

import edu.cmu.oli.log.client.ActionLog;
import edu.cmu.pact.Utilities.Logger;
import edu.cmu.pact.Utilities.trace;
import edu.cmu.pslc.logging.ContextMessage;
import edu.cmu.pslc.logging.Message;
import edu.cmu.pslc.logging.PlainMessage;
import edu.cmu.pslc.logging.ToolMessage;
import edu.cmu.pslc.logging.TutorMessage;
import edu.cmu.pslc.logging.element.ActionEvaluationElement;
import edu.cmu.pslc.logging.element.EventElement;
import edu.cmu.pslc.logging.element.MetaElement;
import edu.cmu.pslc.logging.element.SemanticEventElement;
import edu.cmu.pslc.logging.util.DateTools;

/**
 * A log message whose body is derived from an XML element conforming to
 * the OLI logging specification for tutor-related messages.
 */
public class TutorActionLog extends ActionLog {

	/**
	 * An iterator that returns no elements.
	 */
	public static class EmptyIterator implements Iterator {

		/**
		 * Disabled default constructor for singleton.
		 */
		private EmptyIterator() {}

		/** Always returns false.
			@return constant false */
		public boolean hasNext() {
			return false;
		}

		/** Always throws {@link java.util.NoSuchElementException}.
			@return never returns */
		public Object next() {
			throw new NoSuchElementException("empty iterator");
		}

		/** Always throws {@link java.lang.IllegalStateException}. */
		public void remove() {
			throw new IllegalStateException("empty iterator");
		}
	}

	/**
	 * Marker interface to extract text from more elaborate elements.
	 */
	public static interface TextIsString {
		/** see {@link java.lang.Object#toString()} */
		public String toString();
	}

	/**
	 * An event described in a message.
	 */
	interface MsgEvent {
		/** Event's unique identifier. @return id */
		public String getId();
	}

	/**
	 * Describes a low-level user interface event, like a mouse movement
	 * with no selection. See DTD.
	 */
	public static class UIEvent implements MsgEvent {

		/** Element name for this class. */
		public static final String ELEMENT = "ui_event";

		/** Unique identifier. Required. */
		private final String id;

		/**
		 * Construct from XML Element.
		 *
		 * @param  elt ui_event element
		 * @exception JDOMException if elt is not a ui_event or
		 *                id child is missing
		 */
		public UIEvent(Element elt) throws JDOMException {
			if (null == elt || !(ELEMENT.equals(elt.getName())))
				throw new JDOMException("wrong element type: " +
										(elt == null ? "(null)" : elt.getName()));
			id = elt.getAttributeValue("id");
		}

		/** Unique identifier.
			@return {@link #id} */
		public String getId() { return id; }

		/** Generate an element for this object.
			@return DOM {@link org.jdom.Element Element} */
		public Element getElement() {
			Element result = new Element(ELEMENT);
			if (id != null)
				result.setAttribute("id", id);
			return result;
		}
	}

	/**
	 * Describes an event of interest to (or generated by) a tutor or other
	 * external processor.  This event is of a higher order than a low-level
	 * UI event, like a mouse movement with no selection. See DTD.
	 */
	public static class SemanticEvent implements MsgEvent {

		/** Element name for this class. */
		public static final String ELEMENT = "semantic_event";

		/** Unique identifier. Required. */
		private String id;

		/** Foreign key: identifier of triggering event. */
		private String linkedEventId = "";

		/** Semantically-significant name. */
		private final String name;

		/** Type of trigger event: "USER" if a user action; else "DATA". */
		private String trigger = "DATA";

		/** Text of event element. */
		private String text = "";

		/** DataShop library element. */
		private SemanticEventElement eventElement;
		
		/**
		 * Construct from XML Element.
		 *
		 * @param  elt semantic_event element
		 * @exception JDOMException if elt is not a semantic_event or
		 *                id child is missing
		 */
		protected SemanticEvent(Element elt) throws JDOMException {
			if (null == elt || !(ELEMENT.equals(elt.getName())))
				throw new JDOMException("wrong element type: " +
										(elt == null ? "(null)" : elt.getName()));
			String s = elt.getAttributeValue("name");
			name = (s == null ? "" : s);
			trigger = elt.getAttributeValue("trigger");
			s = elt.getAttributeValue("semantic_event_id");
			linkedEventId = (s == null ? "" : s);
			text = elt.getTextTrim();        // returns empty string if none

			s = elt.getAttributeValue("transaction_id");  // DTDv4
			if (null == s)
				s = elt.getAttributeValue("id");          // DTDv2
			if (null == s || s.length() < 1)
				throw new JDOMException("missing or empty id: " + s);
			setId(s);
			String subtype = elt.getAttributeValue("subtype");
			eventElement = new SemanticEventElement(s, getName(), getTrigger(), subtype);
		}

		/**
		 * Constructor sets {@link #name}, generates {@link #id}.
		 *
		 * @param  name
		 */
		private SemanticEvent(String name) {
			this(generateGUID(), name);
		}

		/**
		 * Constructor sets {@link #name}, {@link #id}.
		 *
		 * @param  id caller must ensure uniqueness
		 * @param  name
		 */
		private SemanticEvent(String id, String name) {
			this.id = id;
			this.name = name;
		}

		/** Generate an element for this object.
			@return DOM {@link org.jdom.Element Element} */
		public Element getElement() {
			Element result = new Element(ELEMENT);
			if (id != null)
				result.setAttribute("id", id);
			if (linkedEventId != null && linkedEventId.length() > 0)
				result.setAttribute("semantic_event_id", linkedEventId);
			if (name != null)
				result.setAttribute("name", name);
			if (trigger != null)
				result.setAttribute("trigger", trigger);
			result.setText(text);
			return result;
		}

		/** Unique identifier.
			@return {@link #id} */
		public String getId() { return id; }

		/** Foreign key: identifier of triggering event.
			@return {@link #linkedEventId} */
		public String getLinkedEventId() { return linkedEventId; }

		/** Set foreign key: identifier of triggering event.
			@param  linkedEventId new value for {@link #linkedEventId} */
		void setLinkedEventId(String linkedEventId) {
			this.linkedEventId = (linkedEventId == null ? "" : linkedEventId);
		}

		/** Semantically-significant name.
			@return {@link #name} */
		public String getName() { return name; }

		/** Type of trigger event: "USER" if a user action; else "DATA".
			@return {@link #trigger} */
		public String getTrigger() { return trigger; }

		/** Set type of trigger event: "USER" if a user action; else "DATA".
			@param  trigger new value for {@link #trigger} */
		private void setTrigger(String trigger) { this.trigger = trigger; }

		/** Text of event element.
			@return {@link #text} */
		public String getText() { return text; }

		/** Set text of event element.
			@param  text new value for {@link #text} */
		private void setText(String text) { this.text = text; }

		/**
		 * @param id new value for {@link #id}
		 */
		protected void setId(String id) {
			this.id = id;
		}

		public String getTransactionId() {
			return getId();
		}

		/**
		 * @return the {@link #eventElement}
		 */
		protected SemanticEventElement getEventElement() {
			return eventElement;
		}
	}
	
	/**
	 * Content of an action element.
	 */
	public static class Action implements TextIsString {

		/** Element name for this class. */
		public static final String ELEMENT = "action";

		/** Text (body) of action element. */
		public final String text;

		/** Optional identifier. */
		public final String id;

		/**
		 * Construct from given data.
		 *
		 * @param  text value for {@link #text}; uses "" if null
		 * @param  id value for {@link #id}
		 */
		private Action(String text, String id) {
			this.text = (text == null ? "" : text);
			this.id = id;
		}

		/** Generate an element for this object.
			@return DOM {@link org.jdom.Element Element} */
		public Element getElement() {
			Element result = new Element(ELEMENT);
			if (id != null)
				result.setAttribute("id", id);
			result.setText(text);
			return result;
		}

		/** String equivalent: text member.
			@return {@link #text} */
		public String toString() { return text; }
	}

	/**
	 * Content of a selection element.
	 */
	public static class Selection implements TextIsString {

		/** Element name for this class. */
		public static final String ELEMENT = "selection";

		/** Text (body) of selection element. */
		public final String text;

		/** Optional identifier. */
		public final String id;

		/** Optional type specifier. */
		public final String type;

		/**
		 * Construct from given data.
		 *
		 * @param  text value for {@link #text}; uses "" if null
		 * @param  id value for {@link #id}
		 * @param  type value for {@link #type}
		 */
		private Selection(String text, String id, String type) {
			this.text = (text == null ? "" : text);
			this.id = id;
			this.type = type;
		}

		/** Generate an element for this object.
			@return DOM {@link org.jdom.Element Element} */
		public Element getElement() {
			Element result = new Element(ELEMENT);
			if (id != null)
				result.setAttribute("id", id);
			if (type != null)
				result.setAttribute("type", type);
			result.setText(text);
			return result;
		}

		/** String equivalent: text member.
			@return {@link #text} */
		public String toString() { return text; }
	}

	/**
	 * Content of an input element.
	 */
	public static class Input implements TextIsString {

		/** Element name for this class. */
		public static final String ELEMENT = "input";

		/** Text (body) of input element. */
		public final String text;

		/** Optional identifier. */
		public final String id;

		/**
		 * Construct from given data.
		 *
		 * @param  text value for {@link #text}; uses "" if null
		 * @param  id value for {@link #id}
		 */
		private Input(String text, String id) {
			this.text = (text == null ? "" : text);
			this.id = id;
		}

		/** Generate an element for this object.
			@return DOM {@link org.jdom.Element Element} */
		public Element getElement() {
			Element result = new Element(ELEMENT);
			if (id != null)
				result.setAttribute("id", id);
			result.setText(text);
			return result;
		}

		/** String equivalent: text member.
			@return {@link #text} */
		public String toString() { return text; }
	}

	/**
	 * Substance of a SemanticEvent or UIEvent.
	 */
	public static class EventDescriptor {

		/** Element name for this class. */
		public static final String ELEMENT = "event_descriptor";

		/** Optional identifier of event described. */
		private final String linkedEventId;

		/** Names of one or more actions describing this event. */
		private final List actions;

		/** Names of one or more selected user interface items acted on. */
		private final List selections;

		/** User input on each corresponding selection. This list
		    is parallel to {@link #selections} with equivalent indexing. */
		private final List inputs;

		/**
		 * Construct from XML Element.
		 *
		 * @param  elt event_descriptor element
		 * @param  msg {@link ToolMessage} or {@link TutorMessage} instance
		 *         to which to add selection, action, input
		 * @exception JDOMException if elt is not a event_descriptor or
		 *                id child is missing
		 */
		private EventDescriptor(Element elt, Message msg) throws JDOMException {
			Namespace ns = elt.getNamespace();
			if (null == elt || !ELEMENT.equals(elt.getName()))
				throw new JDOMException("wrong element type: " +
										(elt == null ? "(null)" : elt.getName()));

			String s = elt.getAttributeValue("event_id", ns);
			linkedEventId = (s == null ? "" : s);
			
			List list = elt.getChildren(Action.ELEMENT, ns);
			Iterator it = list.iterator();
			if (it.hasNext()) {
				actions = new ArrayList();
				do {
					Element iElt = (Element) it.next();
					String text = iElt.getTextTrim();
					actions.add(new Action(text,
										   iElt.getAttributeValue("id", ns)));
					if (msg instanceof ToolMessage)
						((ToolMessage) msg).addAction(text);
					else if (msg instanceof TutorMessage)
						((TutorMessage) msg).addAction(text);
				} while (it.hasNext());
			} else
				actions = null;

			list = elt.getChildren(Selection.ELEMENT, ns);
			it = list.iterator();
			if (it.hasNext()) {
				selections = new ArrayList();
				do {
					Element sElt = (Element) it.next();
					String text = sElt.getTextTrim();
					selections.add(new Selection(text,
												 sElt.getAttributeValue("id", ns),
												 sElt.getAttributeValue("type", ns)));
					if (msg instanceof ToolMessage)
						((ToolMessage) msg).addSelection(text);
					else if (msg instanceof TutorMessage)
						((TutorMessage) msg).addSelection(text);
				} while (it.hasNext());
			} else
				selections = null;

			list = elt.getChildren(Input.ELEMENT, ns);
			it = list.iterator();
			if (it.hasNext()) {
				inputs = new ArrayList();
				do {
					Element iElt = (Element) it.next();
					String text = iElt.getTextTrim();
					inputs.add(new Input(text,
										 iElt.getAttributeValue("id", ns)));
					if (msg instanceof ToolMessage)
						((ToolMessage) msg).addInput(text);
					else if (msg instanceof TutorMessage)
						((TutorMessage) msg).addInput(text);
				} while (it.hasNext());
			} else
				inputs = null;
		}

		/**
		 * Construct from given values.
		 *
		 * @param  linkedEventId value for {@link #linkedEventId}
		 * @param  actions value for {@link #actions}
		 * @param  selections value for {@link #selections}
		 * @param  inputs value for {@link #inputs}
		 */
		private EventDescriptor(String linkedEventId, List actions,
								List selections, List inputs) {
			this.linkedEventId = (linkedEventId == null ? "" : linkedEventId);
			this.actions = actions;
			this.selections = selections;
			this.inputs = inputs;
		}

		/** Generate an element for this object.
			@return DOM {@link org.jdom.Element Element} */
		public Element getElement() {
			Element result = new Element(ELEMENT);
			if (linkedEventId != null)
				result.setAttribute("event_id", linkedEventId);
			if (actions != null) {
				for (Iterator it = actions.iterator(); it.hasNext(); )
					result.addContent(((Action) it.next()).getElement());
			}
			if (selections != null) {
				for (Iterator it = selections.iterator(); it.hasNext(); )
					result.addContent(((Selection) it.next()).getElement());
			}
			if (inputs != null) {
				for (Iterator it = inputs.iterator(); it.hasNext(); )
					result.addContent(((Input) it.next()).getElement());
			}
			return result;
		}

		/** Foreign key: identifier of triggering event.
			@return {@link #linkedEventId} */
		public String getLinkedEventId() { return linkedEventId; }

		/** Semantically-significant action.
			@return first element of {@link #actions}, if available; else "" */
		public String getAction() {
			if (actions == null && actions.isEmpty())
				return "";
			else
				return ((Action) actions.get(0)).toString();
		}

		/** Semantically-significant actions.
			@return {@link #actions} */
		public List getActions() {
			return (actions == null ? new ArrayList(0) : actions);
		}

		/** Names of one or more selected user interface items acted on.
			@return {@link #selections} */
		public List getSelections() {
			return (selections == null ? new ArrayList(0) : selections);
		}

		/** User input on each corresponding selection. This list
		    is parallel to {@link #selections} with equivalent indexing.
			@return {@link #inputs} */
		public List getInputs() {
			return (inputs == null ? new ArrayList(0) : inputs);
		}
	}

	/**
	 * Summary tutor response to a tool action.  This element tells, e.g.,
	 * whether a tutor considered a student action correct or incorrect.
	 * For hint requests, this element can provide a hint index and the
	 * number of hints available.
	 */
	public static class ActionEvaluation implements TextIsString {

		/** Element name for this class. */
		public static final String ELEMENT = "action_evaluation";

		/** Text (body) of evaluation: typically "CORRECT", "INCORRECT",
		    "FIRST_HINT", "NEXT_HINT", etc. */
		public final String text;

		/** For hint responses, the current hint number.
		    Content should be an integer; null if information not available. */
		public final String currentHintNumber;

		/** For hint responses, the number of hints available on this step.
		    Content should be an integer; null if information not available. */
		public final String totalHintsAvailable;

		/**
		 * Construct from given data.
		 *
		 * @param  text value for {@link #text}; uses "" if null
		 * @param  currentHintNumber value for {@link #currentHintNumber}
		 * @param  totalHintsAvailable value for {@link #totalHintsAvailable}
		 */
		private ActionEvaluation(String text, String currentHintNumber,
								 String totalHintsAvailable) {
			if (trace.getDebugCode("log")) trace.out("log", "ActionEvaluation(Stringx3) text is "+text);
			this.text = (text == null ? "" : text);
			this.currentHintNumber = currentHintNumber;
			this.totalHintsAvailable = totalHintsAvailable;
		}

		/**
		 * Construct from XML Element.
		 *
		 * @param  elt event_descriptor element
		 * @exception JDOMException if elt is not an action_evaluation or
		 *                a hint number
		 */
		private ActionEvaluation(Element elt) throws JDOMException {
			if (null == elt || !ELEMENT.equals(elt.getName()))
				throw new JDOMException("wrong element type: " +
										(elt == null ? "(null)" : elt.getName()));
			text = elt.getTextTrim();
			if (trace.getDebugCode("log")) trace.out("log", "ActionEvaluation(Element) text is "+text);
			
			currentHintNumber = elt.getAttributeValue("current_hint_number");
			totalHintsAvailable = elt.getAttributeValue("total_hints_available");
		}

		/** Generate an element for this object.
			@return DOM {@link org.jdom.Element Element} */
		public Element getElement() {
			Element result = new Element(ELEMENT);
			if (currentHintNumber != null)
				result.setAttribute("current_hint_number", currentHintNumber);
			if (totalHintsAvailable != null)
				result.setAttribute("total_hints_available", totalHintsAvailable);
			result.setText(text);
			return result;
		}

		/** String equivalent: text member.
			@return {@link #text} */
		public String toString() { return text; }

	       /** Return the text.  */
	       public String getText() {
                   return text;
               }
	       /** Return the currentHintNumber.  */
	       public String getCurrentHintNumber() {
                   return currentHintNumber;
               }
	       /** Return the totalHintsAvailable.  */
	       public String getTotalHintsAvailable() {
		       return totalHintsAvailable;
	       }
	}

	/**
	 * Top-level tutor response to a tool action.
	 */
	public static class Skill implements TextIsString {

		/** Element name for this class. */
		public static final String ELEMENT = "skill";

		/** Text (body) of skill element.  Content should be a skill name. */
		public final String text;

		/**
		 *  Probability of skill mastery, where available.  Some tutors may
		 *  be able to calculate this value.  Content should be a
		 *  floating-point decimal number in the interval [0,1]; null if
		 *  data not available.
		 */
		public final String probability;

		/**
		 * Construct from given data.
		 *
		 * @param  text value for {@link #text}; uses "" if null
		 * @param  probability value for {@link #probability}
		 */
		protected Skill(String text, String probability) {
			this.text = (text == null ? "" : text);
			this.probability = probability;
		}

		/**
		 * Construct from XML Element.
		 *
		 * @param  elt event_descriptor element
		 * @exception JDOMException if elt is not a skill
		 */
		private Skill(Element elt) throws JDOMException {
			if (null == elt || !ELEMENT.equals(elt.getName()))
				throw new JDOMException("wrong element type: " +
										(elt == null ? "(null)" : elt.getName()));
			text = elt.getTextTrim();
			probability = elt.getAttributeValue("probability");
		}

		/** Generate an element for this object.
			@return DOM {@link org.jdom.Element Element} */
		public Element getElement() {
			Element result = new Element(ELEMENT);
			if (probability != null)
				result.setAttribute("probability", probability);
			result.setText(text);
			return result;
		}

		/** String equivalent: text member.
			@return {@link #text} */
		public String toString() { return text; }
	}

	/**
	 * A name-value pair. The value may be either a single String or
	 * List of Strings.
	 */
	public static class MsgProperty {

		/** Element name for this class. */
		public static final String ELEMENT = "property";

		/** Element name for single entry of list-valued property. */
		public static final String ENTRY_ELEMENT = "entry";

		/** Name (attribute) of msgProperty element. */
		private String name = null;

		/** Property's value as scalar String. */
		private String stringValue = null;

		/** Property's value as List. */
		private List entries = null;

		/**
		 * Construct from given data.
		 *
		 * @param  name value for {@link #name}; uses "" if null
		 * @param  value value for {@link #stringValue}
		 */
		private MsgProperty(String name, String value) {
			this.name = (name == null ? "" : name);
			this.stringValue = (value == null ? "" : value);
		}

		/**
		 * Construct from given data.
		 *
		 * @param  name value for {@link #name}; uses "" if null
		 * @param  entries list of Strings for {@link #entries}; if null,
		 *             
		 */
		private MsgProperty(String name, List entries) {
			this.name = (name == null ? "" : name);
			if (entries == null)
				this.stringValue = "";
			else
				this.entries = new LinkedList(entries);
		}

		/**
		 * Construct from XML Element.
		 *
		 * @param  elt event_descriptor element
		 * @exception JDOMException if elt is not a msgProperty
		 */
		private MsgProperty(Element elt) throws JDOMException {
			if (null == elt || !ELEMENT.equals(elt.getName()))
				throw new JDOMException("wrong element type: " +
										(elt == null ? "(null)" : elt.getName()));
			name = elt.getAttributeValue("name");
			Iterator it = elt.getChildren(ENTRY_ELEMENT).iterator();
			if (!it.hasNext())
				stringValue = elt.getText().trim();  // empty string if no content
			else {
				entries = new LinkedList();
				do {
					entries.add(((Element) it.next()).getText().trim());
				} while (it.hasNext());
			}
		}

		/** Generate an element for this object.
			@return DOM {@link org.jdom.Element Element} */
		public Element getElement() {
			Element result = new Element(ELEMENT);
			result.setAttribute("name", name);
			if (isList()) {
				for (Iterator it = entries.iterator(); it.hasNext(); ) {
					Element e = new Element(ENTRY_ELEMENT);
					Object obj = it.next();
					result.addContent(e.setText(obj == null ? "" : obj.toString()));
				}
			} else
				result.setText(stringValue);
			return result;
		}

		/** Get the property name.
			@return {@link #name} */
		public String getName() { return name; }

		/** Tell whether this property is list-valued.
			@return true if {@link #entries} not null */
		public boolean isList() { return (entries != null); }

		/** Get a scalar value. Result valid if {@link #isList()} returns false.
			@return {@link #stringValue} */
		public String getStringValue() { return stringValue; }

		/** Get a list value. Result valid if {@link #isList()} returns true.
			@return {@link #entries} */
		public List getList() { return entries; }
	}

	/** Attribute of OLI log_action element. */
	public static final String USER_GUID_ATTR = Logger.STUDENT_NAME_PROPERTY;

	/** Attribute of OLI log_action element. */
	public static final String SESSION_ID_ATTR = Logger.SESSION_ID_PROPERTY;

	/** Attribute of OLI log_action element. */
	public static final String DATE_TIME_ATTR = "date_time";

	/** Attribute of OLI log_action element. */
	public static final String TIMEZONE_ATTR = "timezone";

	/**
	 * An iterator to return the TutorActionLog elements in a stream.
	 * The next() method will call the {@link TutorActionLog} constructor on
	 * the current child of the stream's root element.
	 */
	protected static class Factory implements Iterator {
		
		/** DTD version number read from {@link TutorActionLog#MSG_SEQUENCE_ELEMENT} element. */
		private String dtdVersion = VERSION_NUMBER;

		/** Used with TutorActionLog constructors.*/
		private MetaElement meta;

		/** Document built from Reader. */
		private Document doc = null;

		/** Iterator on doc root children. Delegate for Iterator methods.*/
		protected Iterator iterator;

		/**
		 * Constructor builds Document from Reader, saves Iterator.
		 * Accepts root element of name
		 * {@link TutorActionLog#MSG_SEQUENCE_ELEMENT} for sequence.
		 * Will generate single-member iterator if root element is <ul>
		 * <li>{@link #TOOL_MSG_ELEMENT},</li>
		 * <li>{@link #TUTOR_MSG_ELEMENT},</li>
		 * <li>{@link #CONTEXT_MSG_ELEMENT},</li>
		 * <li>{@link #CURRICULUM_MSG_ELEMENT} or</li>
		 * <li>{@link #MSG_ELEMENT}.</li></ul>
		 *
		 * @param  rdr Reader for {@link org.jdom.input.SAXBuilder}
		 * @param dtdVersion if not null, DTD version
		 * @param  meta userid, sessionid, date
		 * @exception JDOMException, IOException
		 */
		protected Factory(Reader rdr, String dtdVersion, MetaElement meta)
				throws JDOMException, IOException {
			if (dtdVersion != null)
				this.dtdVersion = dtdVersion;
			this.meta = meta;
			SAXBuilder builder = new SAXBuilder();
			doc = builder.build(rdr);
			Element root = doc.getRootElement();
			String name = root.getName();
			if (LOG_ACTION_ELEMENT.equals(name)) {
				this.meta =	new MetaElement(root.getAttributeValue(USER_GUID_ATTR),
						root.getAttributeValue(SESSION_ID_ATTR),
						root.getAttributeValue(DATE_TIME_ATTR), root.getAttributeValue(TIMEZONE_ATTR));
				root = (Element) root.getChildren().get(0);
				name = root.getName();
			}
			if (MSG_SEQUENCE_ELEMENT.equals(name)) {
				String versionAttr = root.getAttributeValue(VERSION_NUMBER_ATTR);
				if (versionAttr != null)
					this.dtdVersion = versionAttr;
				iterator = root.getChildren().iterator();
			} else if (TOOL_MSG_ELEMENT.equals(name) ||
					 TUTOR_MSG_ELEMENT.equals(name) ||
					 CONTEXT_MSG_ELEMENT.equals(name) ||
					 CURRICULUM_MSG_ELEMENT.equals(name) ||
					 MSG_ELEMENT.equals(name)) {
				List singleElt = new LinkedList();
				singleElt.add(root);
				iterator = singleElt.iterator();
			} else {
				throw new JDOMException("Bad root element: " + name);
			}
			trace.out("log", "TutorActionLog.Factory.Factory() root "+name+", dtdVersion "+this.dtdVersion);
		}

		/** Returns state of {@link #iterator}. */
		public boolean hasNext() {
			return iterator.hasNext();
		}

		/** Calls constructor, passes next element in {@link #iterator}. */
		public Object next() {
			Element msgElt = (Element) iterator.next();  // throws if empty
			if (TutorActionLogV4.VERSION_NUMBER.equals(getDtdVersion()))
				return new TutorActionLogV4(msgElt, getMeta());
			else
				return new TutorActionLog(msgElt, getMeta());
		}

		/** always throws {@link java.lang.UnsupportedOperationException} */
		public void remove() {
			throw new UnsupportedOperationException("cannot remove");
		}

		/**
		 * @return the {@link #meta}
		 */
		public MetaElement getMeta() {
			return meta;
		}

		/**
		 * @return the {@link #dtdVersion}
		 */
		protected String getDtdVersion() {
			return dtdVersion;
		}
	}

	/** Default time zone if none in msg. */
	public static final String DEFAULT_TIME_ZONE = "UTC";
	
	/** Element type of OLI envelope element. */
	public static final String LOG_ACTION_ELEMENT = "log_action";

	/** Element type of message sequence, from log file or data base report. */
	public static final String MSG_SEQUENCE_ELEMENT =
		"tutor_related_message_sequence";

	/** Name of message sequence element attribute {@link #VERSION_NUMBER}. */
	public static final String VERSION_NUMBER_ATTR = "version_number";

	/** Attribute value of DTD version this class can accept and generate. */
	static final String VERSION_NUMBER = "2";

	/** Element type of messages from student interface. */
	public static final String TOOL_MSG_ELEMENT = "tool_message";

	/** Element type of Behavior Recorder or Production System messages. */
	public static final String TUTOR_MSG_ELEMENT = "tutor_message";

	/** Element type of curriculum system messages. */
	public static final String CURRICULUM_MSG_ELEMENT = "curriculum_message";

	/** Element type of curriculum-context-of-this-problem messages. */
	public static final String CONTEXT_MSG_ELEMENT = "context_message";

	/** Element type of other messages. */
	public static final String MSG_ELEMENT = "message";

	/** Element type for problem name. */
	public static final String PROBLEMNAME_ELEMENT = "problem_name";

	/** Element type for text of hint, success or buggy message. */
	public static final String TUTOR_ADVICE_ELEMENT = "tutor_advice";

	/** Element type for difficulty factor analysis elements. */
	public static final String DFA_ELEMENT = "dfa";

	/** Element type for productions. */
	public static final String PRODUCTION_ELEMENT = "production";

	/** Element type for problem name. */
	public static final String SCHOOLNAME_ELEMENT = Logger.SCHOOL_NAME_PROPERTY;

	/** Element type for problem name. */
	public static final String COURSENAME_ELEMENT = "course_name";

	/** Element type for problem name. */
	public static final String UNITNAME_ELEMENT = "unit_name";

	/** Element type for problem name. */
	public static final String SECTIONNAME_ELEMENT = "section_name";

	/** Element type for property. */
	public static final String PROPERTY_ELEMENT = "property";

	/** Fixed info_type value for all messages: refers to DTD. */
	private static final String INFO_TYPE = "tutor_message.dtd";

	/** Empty iterator for empty lists. */
	private static Iterator emptyIterator = new EmptyIterator();

	/** Formatter to interpret time field with millisecond granularity. */
	private static DateFormat dateFmtMS =
		new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS z");

	/** Formatter to interpret time field with second granularity. */
	private static DateFormat dateFmtSS =
		new SimpleDateFormat("yyyy-MM-dd HH:mm:ss z");

	/** Formatter to interpret time field with minute granularity. */
	private static DateFormat dateFmt =
		new SimpleDateFormat("yyyy-MM-dd HH:mm z");

	/**
	 * Formatter for toString().  Pretty-print, preserve XML declaration
	 *	"<code>&lt;?xml ... &gt;</code>", include encoding in declaration,
	 * use \n for line separator.
	 */
	private static XMLOutputter outputter =
		new XMLOutputter(Format.getPrettyFormat().setIndent(" ").setOmitEncoding(false).setOmitDeclaration(false).setLineSeparator("\n"));

	/**
	 * Top-level element tag: {@link #TOOL_MSG_ELEMENT} or
	 * {@link #TUTOR_MSG_ELEMENT}.
	 */
	protected String topElementType = null;
	
	/** The content of the info field, as a DTDv4 logging library object. */
	protected Message msg;

	/** Attempt identifier: see DTD. */
	private String attemptId = null;

	/** ProblemName object. */
	private String problemName = null;

	/** UIEvent objects in message. Value type is
		{@link UIEvent}; key for each is UIEvent.getId(). */
	private Map uiEvents = null;

	/** SemanticEvent objects in message. Value type is
		{@link SemanticEvent}; key for each is SemanticEvent.getId(). */
	private Map semanticEvents = null;
	
	/** EventDescriptor objects in message. Value type is
		{@link EventDescriptor}; key is EventDescriptor.getLinkedEventId(). */
	private Map eventDescriptors = null;

	/** ActionEvaluation objects in message. Entry type is
		{@link ActionEvaluation}. */
	private List actionEvaluations = null;

	/** Tutor advice objects in message. Entry type is String. */
	private List tutorAdvices = null;

	/** Tutor advice objects in message. Entry type is String. */
	private List dfas = null;

	/** Skill objects in message. Entry type is	{@link Skill}. */
	protected List skills = null;

	/** production objects in message. Entry type is String. */
	private List productions = null;

	/** SchoolName object. */
	private String schoolName = null;

	/** CourseName object. */
	private String courseName = null;

	/** UnitName object. */
	private String unitName = null;

	/** SectionName object. */
	private String sectionName = null;

	/** MsgProperty objects in message. Entry type is {@link MsgProperty}. */
	private List msgProperties = null;


	///////////////////////////////////////////////////////////////////////
	/**
	 * Constructor for building log message from values.
	 *
	 * @param  topElementType top-level element name: {@link #TOOL_MSG_ELEMENT}
	 *             or {@link #TUTOR_MSG_ELEMENT}
	 *             or {@link #CURRICULUM_MSG_ELEMENT} or {@link #MSG_ELEMENT}
	 * @exception IllegalArgumentException if topElementType not defined
	 */
	///////////////////////////////////////////////////////////////////////
	public TutorActionLog(String topElementType) {
		setTopElementType(topElementType);
	}


	///////////////////////////////////////////////////////////////////////
	/**
	 * Constructor for XML Element input.
	 *
	 * @param  elt XML element to analyze
	 * @exception RuntimeException on error
	 */
	///////////////////////////////////////////////////////////////////////
	public TutorActionLog(Element elt, MetaElement meta) {
		setMetaData(meta);
		try {
			parseElement(elt);
		} catch (JDOMException de) {
			Throwable cause = de.getCause();
			if (cause != null)
				cause.printStackTrace();
			else
				de.printStackTrace();
			throw(new RuntimeException("XML exception = " + de.toString() +
									   (cause == null ? "" :
														"; cause " + cause)));
		}
	}
	
	/**
	 * Set the userid, sessionid and timestamp.
	 * @param metaElt DOM element
	 * @param ns namespace of parent
	 */
	private void setMetaData(Element metaElt, Namespace ns) {
		String userGuid = metaElt.getChildTextTrim("user_id", ns);
		String sessionId = metaElt.getChildTextTrim(Logger.SESSION_ID_PROPERTY, ns);
		String time = metaElt.getChildTextTrim("time", ns);
		String timeZone = metaElt.getChildTextTrim("time_zone", ns);
		MetaElement meta = new MetaElement(userGuid, sessionId, time, timeZone);
		setMetaData(meta);
	}

    /**
     * Formatter to interpret time field with millisecond granularity.
     * This format allows 5 digits for milliseconds, though only 3 are needed. 
     */
    private static DateFormat dateFmtMSSSSS =
        new SimpleDateFormat("yyyy/MM/dd HH:mm:ss.SSSSS z");

    /**
     * Formatter to interpret time field with millisecond granularity. 
     * This format allows 3 digits for milliseconds.
     */
    private static DateFormat dateFmtMSSS =
        new SimpleDateFormat("yyyy/MM/dd HH:mm:ss.SSS z");

	/**
	 * Set the userid, sessionid and timestamp.
	 * @param meta DataShop logging library class; no-op if null
	 */
	private void setMetaData(MetaElement meta) {
		// trace.out("log", "meta TutorActionLog.setMetaData("+meta+")");
		if (meta == null)
			return;
		String s = meta.getUserId();
		if (s != null && s.length() > 0)
			setUserGuid(s);
		s = meta.getSessionId();
		if (s != null && s.length() > 0)
			setSessionId(s);
		s = meta.getTime();
		if (s != null && s.length() > 0)
			setTimeStamp(getDate(s, meta.getTimeZone()));
		s = meta.getTimeZone();
		if (s != null && s.length() > 0)
			setTimezone(s);
	}

	/**
	 * Augmentation of {@link DateTools#getDate(String, String)} for timestamps
	 * of form found in OLI log msgs.
	 * @param timeString
	 * @param timeZone
	 * @return
	 */
	public static Date getDate(String timeString, String timeZone) {
        if ((timeZone == null)){ timeZone = "EST"; }
        
        String twz = timeString.trim() + " " + timeZone;
        ParsePosition pos = new ParsePosition(0);

        Date timeStamp = dateFmtMSSSSS.parse(twz, pos);
        if (timeStamp != null)
        	return timeStamp;

        timeStamp = dateFmtMSSS.parse(twz, pos);
        if (timeStamp != null)
        	return timeStamp;
		return DateTools.getDate(timeString, timeZone);
	}

	/**
	 * Constructor for String input: creates instance from first
	 * {@link #TOOL_MSG_ELEMENT}, {@link #TUTOR_MSG_ELEMENT}
	 * {@link #CURRICULUM_MSG_ELEMENT} or {@link #MSG_ELEMENT}
	 * element in the input string, ignores all others.
	 *
	 * @param  xmlStr String of XML with at least one message element
	 * @param  dtdVersion if not null, protocol version from higher-level element
	 * @param  meta userid, sessionid, date
	 * @return TutorActionLog from first element; null on error
	 */
	public static TutorActionLog factory(String xmlStr, String dtdVersion, MetaElement meta)
	{
		Iterator it = factoryIterator(new StringReader(xmlStr), dtdVersion, meta);
		return (TutorActionLog) it.next();
	}

	/**
	 * Create a factory that will return a Iterator whose next() method
	 * will (successively) create TutorActionLog instances for each log
	 * element in the given Reader.
	 * Builds Document from Reader, returns Iterator on top-level child
	 * elements.  Accepts root element of name
	 * {@link TutorActionLog#MSG_SEQUENCE_ELEMENT} for sequence.
	 * Also will generate single-member iterator if root element
	 * is {@link #TOOL_MSG_ELEMENT}, {@link #TUTOR_MSG_ELEMENT},
	 * {@link #CURRICULUM_MSG_ELEMENT} or {@link #MSG_ELEMENT}.
	 *
	 * @param  rdr input XML content
	 * @param dtdVersion if not null, DTD version
	 * @param  meta userid, sessionid, date
	 * @return Iterator whose next() method returns a TutorActionLog instance
	 * @throws RuntimeException
	 */
	//////////////////////////////////////////////////////////////////////
	public static Iterator factoryIterator(Reader rdr, String dtdVersion, MetaElement meta) {
		try {
			return new Factory(rdr, dtdVersion, meta);
		} catch (JDOMException de) {
			Throwable cause = de.getCause();
			if (cause != null)
				cause.printStackTrace();
			else
				de.printStackTrace();
			throw(new RuntimeException("XML exception = " + de.toString() +
									   (cause == null ? "" :
														"; cause " + cause)));
		} catch (Exception e) {
			e.printStackTrace();
			throw(new RuntimeException(e.toString()));
		}
	}

	//////////////////////////////////////////////////////////////////////
	/**
	 * XML string representation of complete XML Document, including prologue.
	 *
	 * @return pretty-print of the result of {@link #getDocument()}.
	 */
	//////////////////////////////////////////////////////////////////////
	public String toString() {
		return outputter.outputString(getDocument());
	}

	//////////////////////////////////////////////////////////////////////
	/**
	 * Generate a complete XML document for this object.
	 * The root element will be of type {@link MSG_SEQUENCE_ELEMENT}
	 *
	 * @return DOM {@link org.jdom.Document}
	 */
	//////////////////////////////////////////////////////////////////////
	protected Document getDocument() {
		Element root = new Element(MSG_SEQUENCE_ELEMENT);
		root.setAttribute(VERSION_NUMBER_ATTR, getDTDVersionNumber());
		root.addContent(getElement());
		return new Document(root);
	}

	//////////////////////////////////////////////////////////////////////
	/**
	 * String representation is pretty-print of XML Element.
	 *
	 * @return XML pretty-print from {@link #outputter}
	 */
	//////////////////////////////////////////////////////////////////////
	public String getElementString() {
		return outputter.outputString(getElement());
	}

	//////////////////////////////////////////////////////////////////////
	/**
	 * Generate an element for this object.
	 *
	 * @return DOM {@link org.jdom.Element Element}
	 */
	//////////////////////////////////////////////////////////////////////
	protected Element getElement() {//changed from protected to public
		Element root = new Element(topElementType);
		if (attemptId != null)
			root.setAttribute("attempt_id", attemptId);

		//!!!STUB: need <meta> (when OLI is down?)

		if (CURRICULUM_MSG_ELEMENT.equals(topElementType))
			return getCurriculumElement(root);

		if (MSG_ELEMENT.equals(topElementType))
			return getMsgElement(root);

		if (problemName != null)
			root.addContent(stringToElement(PROBLEMNAME_ELEMENT, problemName));
		for (Iterator it = uiEventsIterator(); it.hasNext(); )
			root.addContent(((UIEvent) it.next()).getElement());
		for (Iterator it = semanticEventsIterator(); it.hasNext(); )
			root.addContent(((SemanticEvent) it.next()).getElement());
		for (Iterator it = eventDescriptorsIterator(); it.hasNext(); )
			root.addContent(((EventDescriptor) it.next()).getElement());
		for (Iterator it = actionEvaluationsIterator(); it.hasNext(); )
			root.addContent(((ActionEvaluation) it.next()).getElement());
		for (Iterator it = tutorAdvicesIterator(); it.hasNext(); )
			root.addContent(stringToElement(TUTOR_ADVICE_ELEMENT,
											(String) it.next()));
		for (Iterator it = skillsIterator(); it.hasNext(); )
			root.addContent(((Skill) it.next()).getElement());
		for (Iterator it = productionsIterator(); it.hasNext(); )
			root.addContent(stringToElement(PRODUCTION_ELEMENT,
											(String) it.next()));

		//!!!STUB: need tutor_message elements

		return root;
	}

	/**
	 * Get the top-level element type, one of {@link #CURRICULUM_MSG_ELEMENT},
	 * etc.
	 * @return {@link #topElementType} as a String, under sufferance
	 */
	public String getTopElementType() {
		return topElementType;
	}

	//////////////////////////////////////////////////////////////////////
	/**
	 * Fill in the content of a curriculum message.
	 *
	 * @param  root element of type {@link #CURRICULUM_MSG_ELEMENT}
	 * @return root argument
	 */
	//////////////////////////////////////////////////////////////////////
	protected Element getCurriculumElement(Element root) {

		if (schoolName != null)
			root.addContent(stringToElement(SCHOOLNAME_ELEMENT, schoolName));
		if (courseName != null)
			root.addContent(stringToElement(COURSENAME_ELEMENT, courseName));
		if (unitName != null)
			root.addContent(stringToElement(UNITNAME_ELEMENT, unitName));
		if (sectionName != null)
			root.addContent(stringToElement(SECTIONNAME_ELEMENT, sectionName));
		if (problemName != null)
			root.addContent(stringToElement(PROBLEMNAME_ELEMENT, problemName));

		for (Iterator it = dfasIterator(); it.hasNext(); )
			root.addContent(stringToElement(DFA_ELEMENT, (String) it.next()));
		for (Iterator it = skillsIterator(); it.hasNext(); )
			root.addContent(((Skill) it.next()).getElement());
		for (Iterator it = productionsIterator(); it.hasNext(); )
			root.addContent(stringToElement(PRODUCTION_ELEMENT,
											(String) it.next()));
		return root;
	}

	//////////////////////////////////////////////////////////////////////
	/**
	 * Fill in the content of a message of type {@link #MSG_ELEMENT}.
	 *
	 * @param  root element of type MSG_ELEMENT
	 * @return root argument
	 */
	//////////////////////////////////////////////////////////////////////
	protected Element getMsgElement(Element root) {
		if (msgProperties == null)
			return root;
		for (Iterator it = msgProperties.iterator(); it.hasNext(); )
			root.addContent(((MsgProperty) it.next()).getElement());
		return root;
	}

	//////////////////////////////////////////////////////////////////////
	/**
	 * Extract data from an XML Element message.
	 *
	 * @param  elt Element with message data
	 * @exception JDOMException on any error
	 */
	//////////////////////////////////////////////////////////////////////
	protected void parseElement(Element elt) throws JDOMException {

		Namespace ns = elt.getNamespace();
		trace.out("log", "TutorActionLog.parseElement("+outputter.outputString(elt)+")");
		if (trace.getDebugCode("log")) {
			List children = elt.getChildren();
			trace.outNT("log", "nChildren "+children.size()+", ns "+elt.getNamespace());
			for (Iterator it = children.iterator(); it.hasNext(); ) {
				Object child = it.next();
				trace.outNT("log", (child instanceof Element ? ((Element) child).getName() : child).toString());
			}
		}
		setTopElementType(elt.getName());
		attemptId = elt.getAttributeValue("attempt_id", ns);

		Element metaElt = elt.getChild("meta", ns);
		if (metaElt != null) {
			trace.out("log", "meta TutorActionLog.parseElement("+outputter.outputString(metaElt)+")");
			setMetaData(metaElt, ns);
		}
		ContextMessage cmsg = createMinimalContextMsg(elt);

		if (TOOL_MSG_ELEMENT.equals(topElementType)) {
			msg = ToolMessage.create(cmsg);
			parseCommonContent(elt, ns);
		} else if (TUTOR_MSG_ELEMENT.equals(topElementType)) {
			ToolMessage tmsg = ToolMessage.create(cmsg);
			msg = TutorMessage.create(tmsg);
			parseCommonContent(elt, ns);
			parseTutorMsgContent(elt, ns);
		} else if (CURRICULUM_MSG_ELEMENT.equals(topElementType)) {
			msg = cmsg;
			parseCurriculumContent(elt, ns);
		} else if (CONTEXT_MSG_ELEMENT.equals(topElementType)) {
			msg = cmsg;
			parseCurriculumContent(elt, ns);
		} else if (MSG_ELEMENT.equals(topElementType)) {
			msg = PlainMessage.create(cmsg);
			parseMsgContent(elt, ns);
		} else {
			throw new JDOMException("Undefined message element tag: " +
									topElementType);
		}
	}
	
	/**
	 * Create a minimal context message from a message element.
	 * The only valid data in the returned message is the 
	 * context_message_id, which is drawn from that attribute in the
	 * given message element, if any.
	 * @param elt message element from XML
	 * @return minimal context message
	 */
	private ContextMessage createMinimalContextMsg(Element elt) {
		ContextMessage cmsg = ContextMessage.createStartProblem(getMetaElement());
		String cid = elt.getAttributeValue("context_message_id");
		cmsg.setContextMessageId(cid == null ? "" : cid);
		return cmsg;
	}

	/**
	 * Generate a {@link MetaElement} from the base class's userGuid, sessionID
	 * and timestamp properties.
	 * @return new object created from {@link #getUserGuid()},
	 *         {@link #getSessionId()}, {@link #getTimeStamp()}, {@link #getTimezone()}
	 */
	public MetaElement getMetaElement() {
		Date date = getTimeStamp();
		MetaElement meta = new MetaElement(getUserGuid(), getSessionId(),
				(date == null ? "" : dateFmt.format(date)), getTimezone());
		return meta;
	}


	//////////////////////////////////////////////////////////////////////
	/**
	 * Extract data common to both {@link #TUTOR_MSG_ELEMENT} and
	 * {@link #TOOL_MSG_ELEMENT} Elements.
	 *
	 * @param  msgElt Element with message data
	 * @param  ns msgElt's namespace
	 * @exception JDOMException on any error
	 */
	//////////////////////////////////////////////////////////////////////
	protected void parseCommonContent(Element msgElt, Namespace ns) throws JDOMException {
		
		// get the ProblemName
		problemName = msgElt.getChildText(PROBLEMNAME_ELEMENT, ns);
		if (trace.getDebugCode("log")) trace.out("log", "parseCommonContent problemName "+problemName+"\ninstance of "+ 
				(msg instanceof ToolMessage ? "ToolMessage":"TutorMessage"));
		if (msg instanceof ToolMessage)
			((ToolMessage) msg).setProblemName(problemName);
		else if (msg instanceof TutorMessage)
			((TutorMessage) msg).setProblemName(problemName);

		// get all the UIEvents
		{
			Iterator it = msgElt.getChildren(UIEvent.ELEMENT, ns).iterator();
			if (it.hasNext()) {
				uiEvents = new LinkedHashMap();
				do {
					UIEvent se = new UIEvent((Element) it.next());
					uiEvents.put(se.getId(), se);
					// Tool & TutorMessage not yet take UiEventElements
				} while(it.hasNext());
			}
		}

		// get all the SemanticEvents
		{
			List elts = msgElt.getChildren(SemanticEvent.ELEMENT, ns);
			trace.out("log", "TutorActionLog.parseCommonContent("+msg+","+msgElt.getName()+") "+
					SemanticEvent.ELEMENT+" count "+elts.size());
			Iterator it = elts.iterator();
			if (it.hasNext()) {
				semanticEvents = new LinkedHashMap();
				do {
					SemanticEvent se = new SemanticEvent((Element) it.next());
					semanticEvents.put(se.getId(), se);
					if (trace.getDebugCode("log")) trace.out("log", "parseCommonContent semanticEvent "+se.getText()+"\ninstance of "+ 
							(msg instanceof ToolMessage ? "ToolMessage":"TutorMessage"));
					if (msg instanceof ToolMessage)
						((ToolMessage) msg).setEventElement(se.getEventElement());
					else if (msg instanceof TutorMessage)
						((TutorMessage) msg).setEventElement(se.getEventElement());
				} while(it.hasNext());
			}
		}

		// get all the EventDescriptors
		{
			List elts = msgElt.getChildren(EventDescriptor.ELEMENT, ns);
			trace.out("log", "TutorActionLog.parseCommonContent("+msg+","+msgElt.getName()+") "+
					EventDescriptor.ELEMENT+" count "+elts.size());
			Iterator it = elts.iterator();
			if (it.hasNext()) {
				eventDescriptors = new LinkedHashMap();
				do {
					EventDescriptor ed = new EventDescriptor((Element) it.next(), msg);
					eventDescriptors.put(ed.getLinkedEventId(), ed);
					if (trace.getDebugCode("log")) trace.out("log", "parseCommonContent eventDescriptors "+
										ed.getSelections() + ed.getActions() + ed.getInputs());
				} while(it.hasNext());
			}
		}
		
	}

	/**
	 * Extract data from an {@link #TUTOR_MSG_ELEMENT} Element not common
	 * with {@link #TOOL_MSG_ELEMENT} Elements.
	 *
	 * @param  msgElt Element with message data
	 * @param  ns msgElt's namespace
	 * @exception JDOMException on any error
	 */
	protected void parseTutorMsgContent(Element msgElt, Namespace ns) throws JDOMException {
		if (trace.getDebugCode("log")) trace.outln("log", "parseTutorMsgContent");

		// get all the ActionEvaluations
		{
			Iterator it =
				msgElt.getChildren(ActionEvaluation.ELEMENT, ns).iterator();
			if (it.hasNext()) {
				actionEvaluations = new LinkedList();
				do {
					ActionEvaluation e = new ActionEvaluation((Element) it.next());
					actionEvaluations.add(e);
					if (trace.getDebugCode("log")) trace.out("log", "parseTutorMsgContent actionEvaluations "+e);
					
					if (msg instanceof TutorMessage) {
						ActionEvaluationElement aee =
							new ActionEvaluationElement(e.getCurrentHintNumber(),
									e.getTotalHintsAvailable(), null, null, e.getText()); 
						((TutorMessage) msg).setActionEvaluationElement(aee);
						if (trace.getDebugCode("log")) trace.out("log", "actionEvaluation "
								+ "instanceOf TutorMessage. actionEvaluationElement is "+aee);
					}
				} while(it.hasNext());
			}
		}

		// get all the tutor advice values
		{
			Iterator it = msgElt.getChildren(TUTOR_ADVICE_ELEMENT, ns).iterator();
			if (it.hasNext()) {
				tutorAdvices = new LinkedList();
				do {
					String text = ((Element) it.next()).getTextTrim();
                    if (trace.getDebugCode("log")) trace.out("log", "parseTutorMsgContent tutor Advice "+text);
					tutorAdvices.add(text);
					if (msg instanceof TutorMessage)
						((TutorMessage) msg).addTutorAdvice(text);
				} while(it.hasNext());
			}
		}

		parseSkills(msgElt, ns);  // get all the Skills

		// get all the production values
		{
			Iterator it = msgElt.getChildren(PRODUCTION_ELEMENT, ns).iterator();
			if (it.hasNext()) {
				productions = new LinkedList();
				do {
					String text = ((Element) it.next()).getTextTrim();
					productions.add(text);
					if (trace.getDebugCode("log")) trace.out("log", "parseTutorMsgContent production values "+text);
				} while(it.hasNext());
			}
		}
	}
	
	/**
	 * Get all the Skills into the skills iterator. Sets {@link #skills}.
	 * @param msgElt top-level tutor_message Element
	 * @param ns namespace for msgElt
	 */
	protected void parseSkills(Element msgElt, Namespace ns) throws JDOMException {
		Iterator it = msgElt.getChildren(Skill.ELEMENT, ns).iterator();
		if (it.hasNext()) {
			skills = new LinkedList();
			do {
				Skill s = new Skill((Element) it.next());
				skills.add(s);
				if (trace.getDebugCode("log")) trace.out("log", "parseTutorMsgContent->parseSKills "+s);
			} while(it.hasNext());
		}
	}

	//////////////////////////////////////////////////////////////////////
	/**
	 * Extract data from an {@link #CURRICULUM_MSG_ELEMENT} Element.
	 *
	 * @param  msgElt Element with message data
	 * @param  ns msgElt's namespace
	 * @exception JDOMException on any error
	 */
	//////////////////////////////////////////////////////////////////////
	protected void parseCurriculumContent(Element msgElt, Namespace ns)
			throws JDOMException {

		schoolName  = msgElt.getChildText(SCHOOLNAME_ELEMENT, ns);
		courseName  = msgElt.getChildText(COURSENAME_ELEMENT, ns);
		unitName    = msgElt.getChildText(UNITNAME_ELEMENT, ns);
		sectionName = msgElt.getChildText(SECTIONNAME_ELEMENT, ns);
		problemName = msgElt.getChildText(PROBLEMNAME_ELEMENT, ns);

		// get all the DFA values
		{
			Iterator it = msgElt.getChildren(DFA_ELEMENT, ns).iterator();
			if (it.hasNext()) {
				dfas = new LinkedList();
				do {
					String text = ((Element) it.next()).getTextTrim();
					dfas.add(text);
				} while(it.hasNext());
			}
		}

		// get all the Skills
		{
			Iterator it = msgElt.getChildren(Skill.ELEMENT, ns).iterator();
			if (it.hasNext()) {
				skills = new LinkedList();
				do {
					Skill e = new Skill((Element) it.next());
					skills.add(e);
				} while(it.hasNext());
			}
		}

		// get all the production values
		{
			Iterator it = msgElt.getChildren(PRODUCTION_ELEMENT, ns).iterator();
			if (it.hasNext()) {
				productions = new LinkedList();
				do {
					String text = ((Element) it.next()).getTextTrim();
					productions.add(text);
				} while(it.hasNext());
			}
		}
	}

	//////////////////////////////////////////////////////////////////////
	/**
	 * Extract data from an {@link #MSG_ELEMENT} Element.
	 *
	 * @param  msgElt Element with message data
	 * @param  ns msgElt's namespace
	 * @exception JDOMException on any error
	 */
	//////////////////////////////////////////////////////////////////////
	protected void parseMsgContent(Element msgElt, Namespace ns) throws JDOMException {
		/* Iterator it = msgElt.getChildren(PROPERTY_ELEMENT, ns).iterator();
		if (!it.hasNext())
			return;
		msgProperties = new LinkedList();
		do {
			MsgProperty p = new MsgProperty((Element) it.next());
			msgProperties.add(p);
            } while(it.hasNext()); */
		// Iterator<Element> it = (Iterator<Element>)msgElt.getChildren(PROPERTY_ELEMENT, ns).iterator();
        for (Element elt: (List<Element>)msgElt.getChildren(PROPERTY_ELEMENT, ns))
            addMsgProperty(new MsgProperty(elt));
	}

	//////////////////////////////////////////////////////////////////////
	/**
	 * Return a UI event.
	 *
	 * @param  id unique event identifier
	 * @return UIEvent with this identifier; null if none
	 */
	//////////////////////////////////////////////////////////////////////
	public UIEvent getUIEvent(String id) {
		if (uiEvents == null)
			return null;
		else
			return (UIEvent) uiEvents.get(id);
	}

	//////////////////////////////////////////////////////////////////////
	/**
	 * Return an iterator over all UI events.
	 *
	 * @return Iterator on {@link #uiEvents uiEvents.values()};
                   EmptyIterator if no set
	 */
	//////////////////////////////////////////////////////////////////////
	public Iterator uiEventsIterator() {
		if (uiEvents == null)
			return emptyIterator;
		else
			return uiEvents.values().iterator();
	}

	//////////////////////////////////////////////////////////////////////
	/**
	 * Add a semantic event.  Creates the event and adds it
	 *
	 * @param  name semantically-significant name for event
	 * @param  id of SemanticEvent to create; defaulted if null or empty
	 * @param  linkedEventId semantically-significant name for event
	 * @return id
	 */
	//////////////////////////////////////////////////////////////////////
	public String addSemanticEvent(String name, String id,
								   String linkedEventId) {
		SemanticEvent result = null;
		if (semanticEvents == null)
			semanticEvents = new LinkedHashMap();
		if (id == null || id.length() < 1)
			result = new SemanticEvent(name);
		else
			result = new SemanticEvent(id, name);
		result.setLinkedEventId(linkedEventId);
		semanticEvents.put(result.getId(), result);
		return result.getId();
	}

	//////////////////////////////////////////////////////////////////////
	/**
	 * Add an EventDescriptor with a single selection and input.
	 * If an EventDescriptor with the given id
	 * is not found, creates one; otherwise replaces values in that object.
	 *
	 * @param  id of EventDescriptor created; if null or empty, creates
	 *             or rewrites EventDescriptor with id ""
	 * @param  action value for {@link EventDescriptor#action}
	 * @param  selection value for element 0 of {@link EventDescriptor#selections}
	 * @param  input value for element 0 of {@link EventDescriptor#inputs}
	 * @param  name name of selected user interface element
	 * @return id of EventDescriptor inserted
	 */
	//////////////////////////////////////////////////////////////////////
	public String addEventDescriptor(String id, String action,
									 String selection, String input) {
		List actions = new ArrayList();
		actions.add(new Action(action, null));
		List selections = new ArrayList();
		selections.add(new Selection(selection, null, null));
		List inputs = new ArrayList();
		inputs.add(new Input(input, null));
		return addEventDescriptorInternal(id, actions, selections, inputs);
	}
	
	

	//////////////////////////////////////////////////////////////////////
	/**
	 * Add an EventDescriptor with parallel lists of selection and input.
	 * If an EventDescriptor with the given id
	 * is not found, creates one; otherwise replaces values in that object.
	 *
	 * @param  id of EventDescriptor created; if null or empty, creates
	 *             or rewrites EventDescriptor with id ""
	 * @param  actions value for {@link EventDescriptor#actions};
	 *             does NOT copy list
	 * @param  selections value for {@link EventDescriptor#selections};
	 *             does NOT copy list
	 * @param  inputs value for {@link EventDescriptor#inputs};
	 *             does NOT copy list
	 * @param  name name of selected user interface element
	 * @return id of EventDescriptor inserted
	 */
	//////////////////////////////////////////////////////////////////////
	protected String addEventDescriptorInternal(String id, List actions,
												List selections, List inputs) {
		if (eventDescriptors == null)
			eventDescriptors = new LinkedHashMap();
		EventDescriptor ed = new EventDescriptor(id, actions,
												 selections, inputs);
		eventDescriptors.put(ed.getLinkedEventId(), ed);
		return ed.getLinkedEventId();
	}
	
	
	//////////////////////////////////////////////////////////////////////
	/**
	 * Add an ActionEvaluation.
	 *
	 * @param  text body text of ActionEvaluation created
	 */
	//////////////////////////////////////////////////////////////////////
	public void addActionEvaluation(String text) {
		addActionEvaluation(text, null, null);
	}

	//////////////////////////////////////////////////////////////////////
	/**
	 * Add an ActionEvaluation with a hint number and total hints available.
	 *
	 * @param  text body text of ActionEvaluation created
	 * @param  currentHintNumber value for
	 *            {@link ActionEvaluation#currentHintNumber}
	 * @param  totalHintsAvailable value for
	 *            {@link ActionEvaluation#totalHintsAvailable}
	 */
	//////////////////////////////////////////////////////////////////////
	public void addActionEvaluation(String text,
									int currentHintNumber,
									int totalHintsAvailable) {
		
		System.out.println("tutorActionLog addActionEvaluation");
		addActionEvaluation(text, Integer.toString(currentHintNumber),
							Integer.toString(totalHintsAvailable));
	}

	//////////////////////////////////////////////////////////////////////
	/**
	 * Add an ActionEvaluation with a hint number and total hints available.
	 *
	 * @param  text body text of ActionEvaluation created
	 * @param  currentHintNumber value for
	 *            {@link ActionEvaluation#currentHintNumber}
	 * @param  totalHintsAvailable value for
	 *            {@link ActionEvaluation#totalHintsAvailable}
	 */
	//////////////////////////////////////////////////////////////////////
	public void addActionEvaluation(String text,
									String currentHintNumber,
									String totalHintsAvailable) {
		if (actionEvaluations == null){	actionEvaluations = new LinkedList(); System.out.println("instantiating actionEvaluations list");}
		ActionEvaluation e = new ActionEvaluation(text, currentHintNumber,
												  totalHintsAvailable);
		
		System.out.println("addActionEvaluation");
		actionEvaluations.add(e);
	}

	//////////////////////////////////////////////////////////////////////
	/**
	 * Add a tutor_advice value.
	 *
	 * @param  text text of tutor advice created
	 */
	//////////////////////////////////////////////////////////////////////
	public void addTutorAdvice(String text) {
		if (tutorAdvices == null)
			tutorAdvices = new LinkedList();
		tutorAdvices.add(text);
	}

	//////////////////////////////////////////////////////////////////////
	/**
	 * Add a difficulty factors analysis (DFA) value.
	 *
	 * @param  text text of tutor advice created
	 */
	//////////////////////////////////////////////////////////////////////
	public void addDfa(String text) {
		if (dfas == null)
			dfas = new LinkedList();
		dfas.add(text);
	}

	//////////////////////////////////////////////////////////////////////
	/**
	 * Add a production value.
	 *
	 * @param  text text of production created
	 */
	//////////////////////////////////////////////////////////////////////
	public void addProduction(String text) {
		if (productions == null)
			productions = new LinkedList();
		productions.add(text);
	}

	//////////////////////////////////////////////////////////////////////
	/**
	 * Add a Skill.
	 *
	 * @param  text body text of Skill to create
	 */
	//////////////////////////////////////////////////////////////////////
	public void addSkill(String text) {
		addSkill(text, null);
	}

	//////////////////////////////////////////////////////////////////////
	/**
	 * Add a Skill with a numeric probability.
	 *
	 * @param  text body text of Skill created
	 * @param  probability value for {@link Skill#probability}
	 */
	//////////////////////////////////////////////////////////////////////
	public void addSkill(String text, double probability) {
		addSkill(text, Double.toString(probability));
	}

	//////////////////////////////////////////////////////////////////////
	/**
	 * Add a Skill with an optional probability.
	 *
	 * @param  text body text of Skill created
	 * @param  probability value for {@link Skill#probability}; can be null
	 */
	//////////////////////////////////////////////////////////////////////
	public void addSkill(String text, String probability) {
		if (skills == null)
			skills = new LinkedList();
		Skill e = new Skill(text, probability);
		skills.add(e);
	}

    private void addMsgProperty(MsgProperty e) {
		if (msgProperties == null)
			msgProperties = new LinkedList();
		msgProperties.add(e);
    }

	//////////////////////////////////////////////////////////////////////
	/**
	 * Add a MsgProperty with a scalar String value.
	 *
	 * @param  name property name
	 * @param  stringValue scalar value
	 */
	//////////////////////////////////////////////////////////////////////
	public void addMsgProperty(String text, String stringValue) {
		/* if (msgProperties == null)
			msgProperties = new LinkedList();
		MsgProperty e = new MsgProperty(text, stringValue);
		msgProperties.add(e); */
        addMsgProperty(new MsgProperty(text, stringValue));
	}

	//////////////////////////////////////////////////////////////////////
	/**
	 * Add a MsgProperty with a List value.
	 *
	 * @param  name property name
	 * @param  list list value
	 */
	//////////////////////////////////////////////////////////////////////
	public void addMsgProperty(String text, List list) {
		/* if (msgProperties == null)
			msgProperties = new LinkedList();
		MsgProperty e = new MsgProperty(text, list);
		msgProperties.add(e); */
        addMsgProperty(new MsgProperty(text, list));
	}

	/**
	 * Return the ProblemName as a String.
	 *
	 * @return value of {@link ProblemName#getText()}; returns "" if
	 *             problem name is not set
	 */
	public String getProblemName() {
		return (problemName != null ? problemName : "");
	}

	/**
	 * Set the ProblemName as a String.
	 *
	 * @param  name new value value for {@link ProblemName#text}; set "" if
	 *             argument is null
	 */
	public void setProblemName(String name) {
		problemName = (name != null ? name : "");
	}

	//////////////////////////////////////////////////////////////////////
	/**
	 * Return a semantic event.
	 *
	 * @param  id unique event identifier
	 * @return SemanticEvent with this identifier; null if none
	 */
	//////////////////////////////////////////////////////////////////////
	public SemanticEvent getSemanticEvent(String id) {
		if (semanticEvents == null)
			return null;
		else if (id == null || id.length() < 1) {
			Iterator it = semanticEventsIterator();
			SemanticEvent result = (SemanticEvent) (it.hasNext() ? it.next() : null);
			if (trace.getDebugCode("log"))
				trace.out("log", "empty id to getSemanticId(), returning first one found: "+result);
			return result;
		} else
			return (SemanticEvent) semanticEvents.get(id);
	}

	//////////////////////////////////////////////////////////////////////
	/**
	 * Return an iterator over all semantic events.
	 *
	 * @return Iterator on {@link #semanticEvents semanticEvents.values()};
                   EmptyIterator if no set
	 */
	//////////////////////////////////////////////////////////////////////
	public Iterator semanticEventsIterator() {
		if (semanticEvents == null)
			return emptyIterator;
		else
			return semanticEvents.values().iterator();
	}

	//////////////////////////////////////////////////////////////////////
	/**
	 * Return an iterator over all event descriptors.
	 *
	 * @return Iterator on {@link #eventDescriptors}; EmptyIterator if no list
	 */
	//////////////////////////////////////////////////////////////////////
	public Iterator eventDescriptorsIterator() {
		if (eventDescriptors == null)
			return emptyIterator;
		else
			return eventDescriptors.values().iterator();
	}
	
	/**
	 * Convenience method to return a selection text by index.
	 * @return text of all Selections from all EventDescriptors
	 */
	public List<String> getSelectionTexts() {
		List<String> result = new ArrayList<String>();
		Iterator it = eventDescriptorsIterator();
		while (it.hasNext()) {
			EventDescriptor ed = (EventDescriptor) it.next();
			for (Selection s : (List<Selection>) ed.getSelections())
				result.add(s.text);
		}
		return result;
	}
	
	/**
	 * @return text of all Actions from all EventDescriptors
	 */
	public List<String> getActionTexts() {
		List<String> result = new ArrayList<String>();
		Iterator it = eventDescriptorsIterator();
		while (it.hasNext()) {
			EventDescriptor ed = (EventDescriptor) it.next();
			for (Action a : (List<Action>) ed.getActions())
				result.add(a.text);
		}
		return result;
	}
	
	/**
	 * @return text of all Inputs from all EventDescriptors
	 */
	public List<String> getInputTexts() {
		List<String> result = new ArrayList<String>();
		Iterator it = eventDescriptorsIterator();
		while (it.hasNext()) {
			EventDescriptor ed = (EventDescriptor) it.next();
			for (Input i : (List<Input>) ed.getInputs())
				result.add(i.text);
		}
		return result;
	}
	
	/**
	 * Convenience method to return a selection text by index.
	 *
	 * @param  requestIdx index of desired Selection item; this should be
	 *             a 0-based total index across all EventDescriptors
	 * @return text of indicated Selection; records exception and returns ""
	 *             if index is out of bounds
	 */
	public String getSelectionText(int requestIdx) {
		Iterator it = eventDescriptorsIterator();
		int i = 0;
		while (it.hasNext() && i <= requestIdx) {
			EventDescriptor ed = (EventDescriptor) it.next();
			int nSelections = ed.getSelections().size();
			if (i + nSelections <= requestIdx)
				i += nSelections;
			else {
				Selection s =
					(Selection) ed.getSelections().get(requestIdx - i);
				return s.text;
			}
		}
		try {
			throw new IndexOutOfBoundsException("requested index " +
												requestIdx +
												", number of selections " + i);
		} catch (Exception e) {
			e.printStackTrace();
			return "";
		}
	}

	//////////////////////////////////////////////////////////////////////
	/**
	 * Return an iterator over all action evaluations.
	 *
	 * @return Iterator on {@link #actionEvaluations}; EmptyIterator if no list
	 */
	//////////////////////////////////////////////////////////////////////
	public Iterator actionEvaluationsIterator() {
		if (actionEvaluations == null)
			return emptyIterator;
		else
			return actionEvaluations.iterator();
	}

	//////////////////////////////////////////////////////////////////////
	/**
	 * Return an iterator over all tutor advice values.
	 *
	 * @return Iterator on {@link #tutorAdvices}; EmptyIterator if no list
	 */
	//////////////////////////////////////////////////////////////////////
	public Iterator tutorAdvicesIterator() {
		if (tutorAdvices == null)
			return emptyIterator;
		else
			return tutorAdvices.iterator();
	}

	//////////////////////////////////////////////////////////////////////
	/**
	 * Return an iterator over all tutor advice values.
	 *
	 * @return Iterator on {@link #dfas}; EmptyIterator if no list
	 */
	//////////////////////////////////////////////////////////////////////
	public Iterator dfasIterator() {
		if (dfas == null)
			return emptyIterator;
		else
			return dfas.iterator();
	}

	//////////////////////////////////////////////////////////////////////
	/**
	 * Return an iterator over all production values.
	 *
	 * @return Iterator on {@link #productions}; EmptyIterator if no list
	 */
	//////////////////////////////////////////////////////////////////////
	public Iterator productionsIterator() {
		if (productions == null)
			return emptyIterator;
		else
			return productions.iterator();
	}

	//////////////////////////////////////////////////////////////////////
	/**
	 * Return an iterator over the skill list.
	 *
	 * @return Iterator on {@link #skills}; EmptyIterator if no list
	 */
	//////////////////////////////////////////////////////////////////////
	public Iterator skillsIterator() {
		if (skills == null)
			return emptyIterator;
		else
			return skills.iterator();
	}

	/**
	 * Return the SchoolName as a String.
	 *
	 * @return value of {@link SchoolName#getText()}; returns "" if
	 *             problem name is not set
	 */
	public String getSchoolName() {
		return (schoolName != null ? schoolName : "");
	}

	/**
	 * Set the SchoolName as a String.
	 *
	 * @param  name new value value for {@link SchoolName#text}; set "" if
	 *             argument is null
	 */
	public void setSchoolName(String name) {
		schoolName = (name != null ? name : "");
	}

	/**
	 * Return the CourseName as a String.
	 *
	 * @return value of {@link CourseName#getText()}; returns "" if
	 *             problem name is not set
	 */
	public String getCourseName() {
		return (courseName != null ? courseName : "");
	}

	/**
	 * Set the CourseName as a String.
	 *
	 * @param  name new value value for {@link CourseName#text}; set "" if
	 *             argument is null
	 */
	public void setCourseName(String name) {
		courseName = (name != null ? name : "");
	}

	/**
	 * Return the UnitName as a String.
	 *
	 * @return value of {@link UnitName#getText()}; returns "" if
	 *             problem name is not set
	 */
	public String getUnitName() {
		return (unitName != null ? unitName : "");
	}

	/**
	 * Set the UnitName as a String.
	 *
	 * @param  name new value value for {@link UnitName#text}; set "" if
	 *             argument is null
	 */
	public void setUnitName(String name) {
		unitName = (name != null ? name : "");
	}

	/**
	 * Return the SectionName as a String.
	 *
	 * @return value of {@link SectionName#getText()}; returns "" if
	 *             problem name is not set
	 */
	public String getSectionName() {
		return (sectionName != null ? sectionName : "");
	}

	/**
	 * Set the SectionName as a String.
	 *
	 * @param  name new value value for {@link SectionName#text}; set "" if
	 *             argument is null
	 */
	public void setSectionName(String name) {
		sectionName = (name != null ? name : "");
	}

	//////////////////////////////////////////////////////////////////////
	/**
	 * Return an iterator over all {@link TutorActionLog.MsgProperty} elements.
	 *
	 * @return Iterator on {@link #msgProperties}; EmptyIterator if no list
	 */
	//////////////////////////////////////////////////////////////////////
	public Iterator msgPropertiesIterator() {
		if (msgProperties == null)
			return emptyIterator;
		else
			return msgProperties.iterator();
	}

	/**
	 * @param topElementType new value for {@link #topElementType}
	 */
	protected void setTopElementType(String topElementType) {
		if (TOOL_MSG_ELEMENT.equalsIgnoreCase(topElementType))
			this.topElementType = TOOL_MSG_ELEMENT;
		else if (TUTOR_MSG_ELEMENT.equalsIgnoreCase(topElementType))
			this.topElementType = TUTOR_MSG_ELEMENT;
		else if (CURRICULUM_MSG_ELEMENT.equalsIgnoreCase(topElementType))
			this.topElementType = CURRICULUM_MSG_ELEMENT;
		else if (MSG_ELEMENT.equalsIgnoreCase(topElementType))
			this.topElementType = MSG_ELEMENT;
		else
			throw new IllegalArgumentException("Undefined element type: " +
											   topElementType);
	}


	/**
	 * Override the base class method to ensure that loggers and other
	 * handlers will get our value for the info field.
	 *
	 * @return result of {@link #toString()}
	 */
	public String getInfo() {
		return toString();
	}

	/** Return the attemptId.
	 */
	public String getAttemptId() {
		return attemptId;
	}

	/** Set the attemptId.
	 */
	public void setAttemptId(String attemptId) {
		this.attemptId = attemptId;
	}

	/**
	 * Override the base class method to ensure that loggers and other
	 * handlers will get our value for the action_id field.
	 *
	 * @return value of {@link #topElementType}}
	 */
	public String getActionId() {
		return topElementType;
	}

	/**
	 * Override the base class method to ensure that loggers and other
	 * handlers will get XML for the info_type field.
	 *
	 * @return constant {@link #INFO_TYPE}
	 */
	public String getInfoType() {
		return INFO_TYPE;
	}

	/**
	 * Create an XML element from a String.
	 *
	 * @param  tag XML element name
	 * @param  text text of the element; will be escaped to avoid
	 *         conflict w/ XML elements
	 * @return element with text as content; null if an error occurs
	 */
	public static Element stringToElement(String tag, String text) {
		Element result = new Element(tag);
		String escText = outputter.escapeElementEntities(text);
		result.setText(escText);
		return result;
	}

	/**
	 * Generate a unique identifier. Returns toString() of a new instance of
	 * {@link java.rmi.server.UID}, prefixed by "A" to ensure 1st char is
	 * alphabetic (see XML spec).
	 * !!!STUB: should append machine identifier for global uniqueness.
	 *
	 * @return  UID.toString() result
	 */
	static String generateGUID() {
		UID uid = new UID();
		return "A" + uid.toString();
	}

	/**
	 * @return the {@link #WERSION_NUMBER}
	 */
	public String getDTDVersionNumber() {
		return VERSION_NUMBER;
	}

	/**
	 * Get the transaction id from the embedded {@link EventElement}.
	 * @return result of {@link EventElement#getId()}, if {@link #msg} is
	 *         a {@link ToolMessage} or {@link TutorMessage}; else null
	 */
	public String getTransactionId() {
		EventElement ee = null;
		if (msg instanceof ToolMessage)
			ee = ((ToolMessage) msg).getEventElement();
		else if (msg instanceof TutorMessage)
			ee = ((TutorMessage) msg).getEventElement();
		else
			return null;
		if (ee == null)
			return null;
		return ee.getId();
	}


	public List getActionEvaluations() {System.out.println("getActionEvaluations "+actionEvaluations);
		return actionEvaluations;
	}
}
