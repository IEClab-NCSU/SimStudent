/*
 * Created on Apr 27, 2004
 *
 * To change the template for this generated file go to
 * Window&gt;Preferences&gt;Java&gt;Code Generation&gt;Code and Comments
 */
package edu.cmu.pact.Utilities;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;

/**
 * This class generates code for the class {@link VersionInformation}. It can create at least
 * two versions of that class, one each for the academic and commercial licenses. The default
 * version is for the academic license. The version for the commercial license resides
 * with the command-line argument "-commercial".
 * @author sewall
 */
public class VersionInfoGenerator {

	//////////////////////////////////////////////////////////////////////
	//
	// Fields
	//
	//////////////////////////////////////////////////////////////////////

	private String workFile;
	private String buildDate;
	private String buildVersion;
    private static String UNKNOWN_VERSION = "unknown";

	/**
	 * Format for build date: value is "MMMM dd, yyyy".
	 */
	private static final DateFormat buildDateFmt =
		new SimpleDateFormat("dd MMMM yyyy");

	/**
	 * Format for build version: value is "yyyyMMdd-HHmm".
	 */
	private static final DateFormat buildVersionFmt =
		new SimpleDateFormat("yyyyMMdd-HHmm");

	/**
	 * Whether to print debug info. Default false.
	 */
	private boolean verbose = false;
	
	/** The kind of license-reference calls to generate. */
	private LicenseType licenseType = LicenseType.academic;

	/**
	 * Command-line arguments.
	 */
	public static final String USAGE_MSG =
		"Usage:\n" +
		"  java " + VersionInfoGenerator.class.getName() + " [-v] ["+
		LicenseType.internal+"|"+LicenseType.academic+"|"+LicenseType.commercial+"]\n" +
		"where--\n" +
		"  -v    means to print verbose debugging information;\n" +
		"  "+LicenseType.internal+"   means to generate code for use in the PACT lab (default);\n" +
		"  "+LicenseType.academic+"   means to generate code for the academic license;\n" +
		"  "+LicenseType.commercial+" means to generate code for the commercial license.";

	/**
	 * Constructor sets all parameters.
	 * @param  licenseType value for {@link #licenseType}
	 * @param  verbose value for {@link #verbose}
	 */
	public VersionInfoGenerator(String licenseType, boolean verbose) {
		if (licenseType == null)
			licenseType = (LicenseType.values())[0].toString();
		this.licenseType = LicenseType.valueOf(licenseType.toLowerCase());
		this.verbose = verbose;
	}

	/**
	 * Return the date of execution as a build date. Format is "MMMM dd, yyyy".
	 * @return {@link #buildDate}
	 */
	public String getBuildDate() {
		return buildDate;
	}

	/**
	 * Return the date and time of execution as a build version. Format is "yyyyMMdd-HHmm".
	 *
	 * @return {@link #buildVersion}
	 */
	public String getBuildVersion() {
		return buildVersion;
	}

	/**
	 * Format a value for {@link VersionInformation#RELEASE_NAME}.
	 * @return value of System.getProperty("VersionInfo.Release") if set;
	 *         else value of {@link #UNKNOWN_VERSION}
	 */
	private String getReleaseName() {
	    String propVal = System.getProperty("VersionInfo.Release");
	    if (propVal != null && propVal.length() > 0)
	        return propVal;
	    else
	        return UNKNOWN_VERSION;
	}

	/**
	 * Generate Java source code for VersionInformation class.
	 */
	private void generateJava() {
		StringBuffer result = new StringBuffer(
			"package edu.cmu.pact.Utilities;\n" +
			"\n" +
			"/**\n" +
			" * Version number and build date for " + workFile + ".\n" +
			" * THIS CODE IS GENERATED by VersionInfoGenerator.\n" +
			" */\n" +
			"public class VersionInformation {\n" +
			"    public static String RELEASE_NAME = \"" + getReleaseName() + "\";\n" +
			"    public static String VERSION_NUMBER = \"" + getBuildVersion() + "\";\n" +
			"    public static String BUILD_DATE = \"" + getBuildDate() + "\";\n" +
			"\n" +
			"    private static VersionInfoGenerator.LicenseType licenseType = VersionInfoGenerator.LicenseType." + licenseType + ";\n" +
			"\n" +
			"    public static String getReleaseString() {\n" +
			"        return RELEASE_NAME+\", \"+VERSION_NUMBER+\", \"+BUILD_DATE;\n" +
			"    }\n"+
			"\n" +
			"    public static void main(String[] args) {\n" +
			"        trace.out(getReleaseString());\n" +
			"    }\n");
		result.append("\n").append(genIncludePredicates());
		result.append("\n").append(genRunningSimSt());
		result.append("\n").append(genGetWebPage());
		result.append("\n").append(genGetMenuItem());
		result.append("\n").append(genGetFileReferenceString());
		result.append("}\n");
		System.out.print(result.toString());
		//trace.out(String.valueOf(result));
	}

	/**
	 * {@link VersionInformation#isRunningSimSt()} tells whether or not Simulated Student is actually running
	 * {@link VersionInformation#setRunningSimSt(boolean)} sets whether Simulated Student is actually running
	 * @return code for these 2 methods
	 */
	private String genRunningSimSt() {
		StringBuffer sb = new StringBuffer();
		sb.append(
		"    /** True if we are actually running Sim Student. */\n"+
		"    private static boolean runningSimSt = false;\n"
		);
		sb.append("\n");
		sb.append(
		"    /**\n"+
		"     * @return true if actually running Sim Student\n"+
		"     */\n"+
		"    public static boolean isRunningSimSt() {\n"+
		"        return runningSimSt && includesSimSt();\n"+
		"    }\n"
		);
		sb.append("\n");
		sb.append(
		"    /**\n"+
		"     * @param new value for {@link #runningSimSt}\n"+
		"     */\n"+
		"    public static void setRunningSimSt(boolean b) {\n"+
		"        runningSimSt = b;\n"+
		"    }\n"
		);
		sb.append("\n");
		return sb.toString();
	}

	/**
	 * {@link VersionInfomation#includesJess()} tells whether or not Jess is available.
	 * {@link VersionInfomation#includesSimSt()} tells whether or not Simulated Student is available.
	 * {@link VersionInfomation#includesCL()} tells whether Carnegie Learning libraries are available.
	 * @return code for these 3 methods
	 */
	private String genIncludePredicates() {
		StringBuffer sb = new StringBuffer();
		sb.append(
		"    /**\n"+
		"     * @return true if the Carnegie Learning libraries are available; else false\n"+
		"     */\n"+
		"    public static boolean includesCL() { return licenseType == VersionInfoGenerator.LicenseType.internal; }\n"
		);
		sb.append("\n");
		sb.append(
		"    /**\n"+
		"     * @return true if Simulated Student mode is available; else false\n"+
		"     */\n"+
		"    public static boolean includesSimSt() { return licenseType == VersionInfoGenerator.LicenseType.internal; }\n"
		);
		sb.append("\n");
		sb.append(
		"    /** Result of last {@link #includesJess()} call. */\n"+
		"    private static Boolean lastJessResult = null;\n"
		);
		sb.append("\n");
		sb.append(
		"    /**\n"+
		"     * @return true if can instantiate the {@link jess.Rete} class; else false\n"+
		"     */\n"+
		"    public static boolean includesJess() {\n" +
		"        if(lastJessResult != null)\n" +
		"            return lastJessResult.booleanValue();\n" +
		"        boolean result;\n" +
		"        try {\n" +
		"            Class cls = Class.forName(\"jess.Rete\");\n" +
		"            result = (cls.newInstance() != null);\n" +
		"        } catch (NoClassDefFoundError ncdfe) {\n" +
		"            result = false;\n" +
		"        } catch (ClassNotFoundException cnfe) {\n" +
		"            result = false;\n" +
		"        } catch (Throwable t) {\n" +
		"            result = (licenseType != VersionInfoGenerator.LicenseType.commercial);\n" +
		"        }\n" +
		"        lastJessResult = new Boolean(result);\n" +
		"        return result;\n" +
		"    }\n"
		);
		sb.append("\n");
		return sb.toString();
	}

	/**
	 * {@link VersionInfomation#getWebPage()} returns null or the URL of the web page having
	 * the proper license agreement.
	 * @return source for getWebPage()
	 */
	private String genGetWebPage() {
		String webPage = (licenseType == LicenseType.commercial ? "null"
				: "\"http://ctat.pact.cs.cmu.edu/license\"");
		return 
		"    /**\n"+
		"     * @return URL of web page having the license agreement or null\n"+
		"     */\n"+
		"    public static String getWebPage() {\n"+
		"        return "+webPage+";\n"+
		"    }\n";
	}

	/**
	 * {@link VersionInformation#getMenuItem()} returns null or a menuItem that would
	 * display the CTAT license.
	 * @return source for {@link VersionInformation#getMenuItem()}
	 */
	private String genGetMenuItem() {
		String menuItem = (licenseType == LicenseType.commercial ? "null"
				: "new javax.swing.JMenuItem(\"CTAT License\")");
		return
		"    /**\n"+
		"     * @return menu item labeled \"CTAT License\" or null\n"+
		"     */\n"+
		"    public static javax.swing.JMenuItem getMenuItem() {\n"+
		"        return "+menuItem+";\n"+
		"    }\n";
	}

	/**
	 * {@link VersionInformation#getFileReferenceString()} returns the pathname of the 
	 * locally-installed license agreement or null.
	 * @return source for {@link VersionInformation#getFileReferenceString()}
	 */
	private String genGetFileReferenceString() {
		String fileReferenceString = (licenseType == LicenseType.commercial ? "\"\"" :
			"\"License: \"+VersionInformation.currentDir()+\"CTAT academic license.html.<br><br>\"");
		String currentDirSource = (licenseType == LicenseType.commercial ? "" :
			"    /**\n"+
			"     * @return current directory from System property user.dir or empty string.\n"+
			"     */\n"+
			"    private static String currentDir() {\n"+
			"        String result = System.getProperty(\"user.dir\");\n"+
			"        if (result == null || result.length() < 1)\n"+
			"            return \"\";\n"+
			"        return result+java.io.File.separator;\n"+
			"    }\n");
			
		StringBuffer result = new StringBuffer();
		result.append("    /**\n"+
					  "     * @return HTML string telling the location of the license file or empty string\n"+
					  "     */\n"+
					  "    public static String getFileReferenceString() {\n");
		result.append("        return ").append(fileReferenceString).append(";\n");
		result.append("    }\n");
		result.append("\n");
		result.append(currentDirSource);
		result.append("\n");
		return result.toString();
	}

	/**
	 * Set the build date and version and generate the Java file.
	 * Writes to stdout.
	 *
	 */
	public void run() {
		buildDate = buildDateFmt.format(new Date());
		buildVersion = buildVersionFmt.format(new Date());
		if (verbose)
			System.err.println("buildDate: " + buildDate + ", buildVersion: " + buildVersion);
		generateJava();
	}

	/**
	 * Print the {@link #USAGE_MSG} message to stderr and exit with exit
	 * status 1.
	 *
	 * @param errMsg optional error message to precede the usage message;
	 *               will append a period (".")
	 */
	private static void usageExit(String errMsg) {
		if (errMsg != null && errMsg.length() > 0)
			System.err.print(errMsg + ". ");
		System.err.println(USAGE_MSG);
		System.exit(1);
	}

	/**	Currently-supported license types. */
	enum LicenseType {
		internal,
		academic,
		commercial
	};
	
	/**
	 * For command-line arguments, see {@link #USAGE_MSG}.
	 * @param args command-line arguments
	 */
	public static void main(String[] args) {
		boolean verbose = false;
		int a = 0;
		for (; a < args.length && args[a].charAt(0) == '-'; ++a) {
			if (args[a].length() < 2)
				usageExit("Missing option after '-'");
			char opt = args[a].charAt(1);
			switch (opt) {
			case 'v': case 'V':
				verbose = true; break;
			default:
				usageExit("Undefined option '-" + opt + "'");
			}
		}
		String licenseType = (a < args.length ? args[a] : null);
		try {
			VersionInfoGenerator gen = new VersionInfoGenerator(licenseType, verbose);
			gen.run();
		} catch (Exception e) {
			usageExit(e.toString());
		}

	}
}
