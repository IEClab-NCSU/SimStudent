/**
 * Representing hint messages generated by Carnegie Learning Algebra I tutor (GetHint)
 * 
 */
package edu.cmu.pact.miss;

import java.util.Vector;

import edu.cmu.pact.BehaviorRecorder.Controller.BR_Controller;
import edu.cmu.pact.BehaviorRecorder.ProblemModel.Graph.ProblemNode;
import edu.cmu.pact.miss.userDef.algebra.EqFeaturePredicate;

/**
 * @author mazda
 *
 */
public class ClAlgebraTutorHint {

    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
    // Fields
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
    
    private String bottomOutHint = "";
    public String getButtomOutHint() {
        return this.bottomOutHint;
    }

    // Clue for add, subtract, multiply, and divde
    private static final String YOU_CAN_ = "You can ";
    private static final String TYPE_IN_ = "Type in ";
    // private static final String CLT_ = "What action can you perform";
    private static final String CLT = "Add/Subtract terms";
    private static final String CLT2 = "Select Simplify Signs";
    private static final String MT = "Perform multiplication";
    private static final String RF = "Simplify fractions";
    private static final String CLT_TYPEIN = "combine";
    private static final String RF_TYPEIN = "simplify";
    // private static final String DONE = "You have solved the equation";

    private static final String SKILL_ADD = "add";
    private static final String SKILL_SUB = "subtract";
    private static final String SKILL_MULTI = "multiply";
    private static final String SKILL_DIV = "divide";
    private static final String SKILL_TYPEIN = "typein";
    private static final String SKILL_CLT = "clt";
    private static final String SKILL_MT = "mt";
    private static final String SKILL_RF = "rf";
    // private static final String SKILL_DONE = "done";
    
    private String[] hint;
    
    private String skillName = null;
    private String selection = null;
    private final String action = "UpdateTable";
    private String input = null;
    private Sai sai = null;
    
    public String getSelection() { return this.selection; }
    public void setSelection(String selection) { this.selection = selection; }
    public String getSkillName() { return this.skillName; }
    public String getInput() { return this.input; }
    public String getAction() { return this.action; }
    
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
    // Constructor
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
 
    /**
     * hintMessage is a ';' separated list of hints.  Ex. of a hint:
     * 
     * You can add <expression>1</expression> to both sides of the equation 
     * to eliminate the constant value of <expression>-1</expression> 
     * (<expression>-1</expression> + <expression>1</expression> = 0).
     * 
     * The last element of the hintMessage is a bottom-out hint.
     * 
     */
    public ClAlgebraTutorHint(String hintMessageList) {

        this.hint = hintMessageList.split(";");
        this.bottomOutHint = hint[hint.length -1];
        
        String bottomOutHint = this.bottomOutHint;
        
        // If the hintMessage begins with "You can ...",
        // strip that off to get a "skill_operand" string at the front
        // E.g., 
        // "You can subtract <expression>8</expression> from both sides of..."
        if (bottomOutHint.startsWith(YOU_CAN_)) {
            bottomOutHint = bottomOutHint.replaceAll(YOU_CAN_, "");
        }
        
        this.skillName = parseSkillName(bottomOutHint);
        this.input = parseInput(bottomOutHint);
        
    }

    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
    // Methods
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
 
    private String parseInput(String hintMessage) {
        
        String input = "";
        
        // "add 1.2"
        if (EqFeaturePredicate.isBasicArithmeticSkill(this.skillName)) {
            input = getSkillName() + " " + parseOperand(hintMessage);
        } else if (EqFeaturePredicate.isValidSimplificationSkill(getSkillName())) {
            input = getSkillName();
        } else if (isSkillTypein(getSkillName())){
            input = hintMessage.split("</?literal>")[1];
        }
        return input;
    }
    
    private boolean isSkillTypein(String skillName) {
        return skillName.endsWith(SKILL_TYPEIN);
    }
    
    // hintMessage: "Add <expression>7y</expression> to both sides..."
    private String parseOperand(String hintMessage) {
        String operand = null;
        try {
            if (hintMessage.indexOf("<expression>") > 0) {
                operand  = hintMessage.split("</?expression>")[1];
            } else {
                // The hintMessage has no <expression> tag for it has only a simple term
                if (getSkillName().equals(SKILL_ADD) || getSkillName().equals(SKILL_SUB)) {
                    // "Subtract y from both sides."
                    operand = hintMessage.split(" ")[1];
                } else if (getSkillName().equals(SKILL_MULTI) || getSkillName().equals(SKILL_DIV)) {
                    // "Multiply both sides by x."
                    operand = hintMessage.split(" ")[4];
                    // get rid of the last '.'
                    operand = operand.substring(0, operand.length()-1);
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return operand;
    }

    private String parseSkillName(String hintMessage) {
        
        String keyWord = hintMessage.split(" ")[0];
        
        if (SKILL_ADD.equalsIgnoreCase(keyWord)) {
            return SKILL_ADD;
        } else if (SKILL_SUB.equalsIgnoreCase(keyWord)) {
            return SKILL_SUB;
        } else if (SKILL_MULTI.equalsIgnoreCase(keyWord)) {
            return SKILL_MULTI;
        } else if (SKILL_DIV.equalsIgnoreCase(keyWord)) {
            return SKILL_DIV;
        } else if (hintMessage.startsWith(TYPE_IN_)) {
            return parseSkillTypein();
        } else if (hintMessage.startsWith(CLT) || hintMessage.startsWith(CLT2)) {
            return SKILL_CLT;
        } else if (hintMessage.startsWith(MT)) {
            return SKILL_MT;
        } else if (hintMessage.startsWith(RF)) {
            return SKILL_RF;
        } else {
            new Exception("ClAlgebraTutorHint: unknown hint type: " + hintMessage).printStackTrace();
        }
        return null;
    }
    
    private String parseSkillTypein() {
        
        String skillTypein = "";
        
        // Get the first word in the 2nd hint from the bottom-out hint
        String typeinHint = hint[hint.length -2];
        String skill = typeinHint.split(" ")[0].toLowerCase();
        String skill2 = typeinHint.split(" ")[1].toLowerCase();
        if (EqFeaturePredicate.isBasicArithmeticSkill(skill)) {
            skillTypein = skill + "-" + SKILL_TYPEIN;
        } else if (CLT_TYPEIN.equals(skill)) {
            skillTypein = SKILL_CLT + "-" + SKILL_TYPEIN;
        } else if (RF_TYPEIN.equals(skill)) {
            skillTypein = SKILL_RF + "-" + SKILL_TYPEIN;
        } else if ("multiplication".equals(skill2)) {
            skillTypein = SKILL_MT + "-" + SKILL_TYPEIN;
        } else {
            new Exception("ClAlgebraTutorHint: invalid skill name for typein >>> " + typeinHint).printStackTrace();
        }

        return skillTypein;
    }
    
    public Sai getSAI(BR_Controller brController, ProblemNode currentNode) {
        
        if (this.selection == null) {
        	this.selection = findSelection(brController, currentNode);
        }
        if (this.sai == null) {
            this.sai = new Sai(this.selection, this.action, this.input);
        }
        return sai;
    }
    
    private String findSelection(BR_Controller brController, ProblemNode currentNode) {
        
        /*
        String msg[] = { "currentNode", currentNode.getName() };
        SimSt.suspendForDebug(brController, "setSelection", msg);
        */

        String selection = "commTable1_";
        
        ProblemNode startNode = brController.getProblemModel().getStartNode();
        Vector /* ProblemEdge */ path = InquiryClAlgebraTutor.findPathDepthFirst(startNode, currentNode);
        
        /*
        msg[0] = "path.size()";
        msg[1] = "" + (path == null ? 0 : path.size());
        SimSt.suspendForDebug(brController, "setSelection", msg);
        */
        
        int stepDepth = (path == null) ? 0 : path.size();
        if ((stepDepth % 3) == 0) {
            // This is for SkillOperand
            selection += "C" + 3 + "R" + (stepDepth/3 + 1);
        } else {
            // This is for typein
            int column = this.bottomOutHint.endsWith("left.") ? 1 : 2;
            selection += "C" + column + "R" + (stepDepth/3 + 2);
        }
        
        /*
        msg[0] = "selection";
        msg[1] = selection;
        SimSt.suspendForDebug(brController, "setSelection", msg);
        */

        return selection;
    }
}
