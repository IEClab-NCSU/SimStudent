package edu.cmu.pact.miss.PeerLearning.GameShow;

import java.awt.event.ActionEvent;
import java.io.IOException;
import java.util.LinkedList;
import java.util.List;

import javax.swing.JOptionPane;
import javax.swing.Timer;

import edu.cmu.pact.Utilities.trace;
import edu.cmu.pact.miss.PeerLearning.GameShow.Connection;

public class ContestOrganizer implements TimeoutRecovery {
	private Connection contestant1;
	private Connection contestant2;
	
	private List<String> problems;
	
	boolean problemsSubmitted = false;
	boolean answered = false;
	boolean forfeited = false;
	
	private List<Solution> solutions1;
	private List<Solution> solutions2;
	
	private ContestServer server;
	
	public static final String PROBLEM_START_MSG = "Starting problem $1";
	public static final String LEAVE_MSG = "$1 has left the game.";
	public static final String ANS_SUBMIT_MSG = "$1 has locked in an answer.";
	public static final String PROBLEM_REQUEST_MSG = "$1's tutor will be asked to provide problem $2.";
	
	
	/*
	 * Constructor to create new contest organizer - sends message to each contestant that
	 * contest is starting.
	 */
	public ContestOrganizer(ContestServer serv, Connection cont1, Connection cont2)
	{
		server = serv;
		
		contestant1 = cont1;
		contestant2 = cont2;
		
		problems = new LinkedList<String>();
		String problem = GameShowUtilities.generate();
		problems.add(problem);
		
		solutions1 = new LinkedList<Solution>();
		solutions2 = new LinkedList<Solution>();

		contestant1.writer.println(ContestServer.START_CONTEST+","+contestant2.userid+","+contestant2.img);
		contestant2.writer.println(ContestServer.START_CONTEST+","+contestant1.userid+","+contestant1.img);

		//start listening to the contestants for messages
		new Thread(new ListenerThread(contestant1,solutions1)).start();
		new Thread(new ListenerThread(contestant2,solutions2)).start();

		//First problem is automatically generated by the organizer.  Delay message starting the problem
		//by 5 seconds so contestants have time to see game is starting
		new Thread(new MessageDelay(contestant1,5000,ContestServer.START_PROBLEM+","+problem)).start();
		new Thread(new MessageDelay(contestant2,5000,ContestServer.START_PROBLEM+","+problem)).start();
		startProblemTimers();

		sendPrivateAnnounceMessage(GameShowUtilities.replacePiece(PROBLEM_START_MSG,""+problems.size()));
	}
	
	/*
	 * A class to track info and statistics about a submitted solution
	 */
	class Solution
	{
		String answer;
		boolean correct;
		int numSteps;
		int numIncorrectSteps;
		String solutionPath;
		
		Solution(String ans, boolean corr, int nSteps, int nIncorr, String path)
		{
			answer = ans;
			correct = corr;
			numSteps = nSteps;
			numIncorrectSteps = nIncorr;
			solutionPath = path;
		}
	}
	
	/*
	 * A threaded class to send a message to a connection after a specified delay
	 */
	class MessageDelay extends Thread
	{
		int timeDelay;
		String message;
		Connection connection;
		MessageDelay(Connection connect, int delay, String messageText)
		{
			timeDelay = delay;
			message = messageText;
			connection = connect;
		}
		public void run()
		{
			try {
				Thread.sleep(timeDelay);
			} catch (InterruptedException e1) {
				e1.printStackTrace();
			}
			if(!forfeited)
				connection.writer.println(message);
		}
	}
	
	/*
	 * A threaded class to listen for message responses from contestants
	 */
	class ListenerThread extends Thread
    {
		//whether or not to keep listening for more messages
		boolean activeListener = true;
		Connection connection;
		List<Solution> solutionList;
		ListenerThread(Connection connect, List<Solution> sols)
		{
			connection = connect;
			solutionList = sols;
		}
	
    	public void run() {
    		String incomingMsg;
			try {
				while(activeListener && (incomingMsg = connection.reader.readLine()) != null)
				{
					//As each message is received, determine message type and distribute to the
					//correct method
				    trace.out("Client (organizer): " + incomingMsg);
				    
				    if(!forfeited)
				    {
					    if(incomingMsg.startsWith(ContestServer.SOLUTION))
					    	solutionMade(incomingMsg);
					    if(incomingMsg.startsWith(ContestServer.SUBMIT_PROBLEMS))
					    	submitProblems(incomingMsg);
					    if(incomingMsg.startsWith(ContestServer.REQUEST_PROBLEM_BANK))
					    	requestProblemBank(incomingMsg);
                                            if(incomingMsg.startsWith(ContestServer.PROBLEM_REQUEST_EXIT))
                                                stopProblemRequestResponseTimer();
				    }
				    if(incomingMsg.startsWith(ContestServer.LEAVE))
				    	leaveProgram(incomingMsg);
				    if(incomingMsg.startsWith(ContestServer.JOIN))
				    {
				    	//A join message from one of the organizer's contestants is trying to
				    	//join the matchup again.  Stop listening to them and return them to
				    	//the matchup server for listening
				    	server.returnConnection(connection);
				    	activeListener = false;
				    }
				    if(incomingMsg.startsWith(ContestServer.CHAT_PRIVATE_MESSAGE))
				    	sendChatMessage(incomingMsg);
				}
			} catch (IOException e) {
				e.printStackTrace();
			}
			
    	}
    	
    	private void requestProblemBank(String incomingMsg) {
			String problemBank = ContestServer.requestProblemBank();
			connection.writer.println(ContestServer.PROBLEM_BANK_LIST+","+problemBank);			
		}

		/*
    	 * Handle a submit problem message: tell both contestants to start the given problem
    	 * Received message format is: SUBMIT_PROBLEMS,problem 
    	 */
    	private void submitProblems(String incomingMsg) {
			String[] probs = incomingMsg.split(",");
			
			String problem = probs[1];
			if(problemRequestResponse != null)
				problemRequestResponse.stop();
			problems.add(problem);
			contestant1.writer.println(ContestServer.START_PROBLEM+","+problem);
			contestant2.writer.println(ContestServer.START_PROBLEM+","+problem);
			startProblemTimers();

			sendPrivateAnnounceMessage(GameShowUtilities.replacePiece(PROBLEM_START_MSG,""+problems.size()));
		}
    	
		/*
		 * Process leave message: send a response message which informs the contestant
		 * that they have been removed and stop listening at the socket
		 * Message received format is: LEAVE or LEAVE technical
		 */
		private void leaveProgram(String args)
    	{
			boolean technical = false;
			if(args.contains("technical"))
				technical = true;
    		connection.writer.println(ContestServer.LEAVE);
    		try {
        		//give the contestant time to close their own connection before dropping them
				Thread.sleep(100);
			} catch (InterruptedException e1) {
				e1.printStackTrace();
			}
			
			//remove from the active connection list and close the socket
    	    connection.writer.close();
    	    try {
    	    	connection.reader.close();
				connection.socket.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
			
			//stop listening at socket
			activeListener = false;

			sendPrivateAnnounceMessage(GameShowUtilities.replacePiece(LEAVE_MSG,connection.name));
			
			//End this contest! - Return the other contestant, but don't change score
			if(technical && !forfeited && solutions1.size()<5 && solutions2.size()<5 )
			{
				forfeitGame(connection,false);
			}
			//End this contest! - Return the other contestant
			else if(!forfeited && solutions1.size()<5 && solutions2.size()<5 )
			{
				//solved at least one problem but not all of them
				forfeitGame(connection,true);
			}
    	}
    	
		
		
		/*
		 * Process solution message: store the solution internally for later reference &
		 * if both solutions have been received, send assessment
		 * Received message format is: SOLUTION_MADE,answer,corrrectness,number_of_steps,number_of_incorrect_steps,solution_path_htmls
		 */
    	private void solutionMade(String args)
    	{
    		String[] solution = args.split(",");
    		if(solution.length < 3)
    		{
    			//Error!
    		}
    		else
    		{
    			sendPrivateAnnounceMessage(GameShowUtilities.replacePiece(ANS_SUBMIT_MSG, connection.name));
    			if(contestant1 == connection && problemAnswerResponse1 != null)
    			{
    				problemAnswerResponse1.stop();
    			}
    			else if(contestant2 == connection && problemAnswerResponse2 != null)
    			{
    				problemAnswerResponse2.stop();
    			}
    			String ans = solution[1];
    			boolean correct = Boolean.parseBoolean(solution[2]);
    			int nSteps,nIncorrect;
    			if(solution.length >= 5)
    			{
    				nSteps = Integer.parseInt(solution[3]);
    				nIncorrect = Integer.parseInt(solution[4]);
    			}
    			else
    			{
    				nSteps = 0;
    				nIncorrect = 0;
    			}
    			String path = "";
    			if(solution.length >=6)
    				path = solution[5];
    			//save solution data
    			Solution sol = new Solution(ans,correct,nSteps,nIncorrect,path);
    			processSolution(connection, sol);
    			
    		}
    	}
    	
    	/*
    	 * Process a chat message: take the message, add the name onto it, and
    	 * send to all active connections not currently in games
    	 * Message received format is: CHAT_PRIVATE_MESSAGE,message
    	 */
		public void sendChatMessage(String incomingMsg) {
			String chat = incomingMsg.substring(incomingMsg.indexOf(',')+1);
			chat = connection.name+"'s Tutor: "+chat;
			contestant1.writer.println(ContestServer.CHAT_PRIVATE_MESSAGE+","+chat);
			contestant2.writer.println(ContestServer.CHAT_PRIVATE_MESSAGE+","+chat);
			
		}
    	
    }
	
        Timer problemRequestResponse;
        
	/*
	 * Send an assessment of how the other contestant did to each player (each contestant already
	 * has the data to know how they did) & then send a problem request to the correct contestant
	 * or end the contest
	 */
	public void sendAssessment() {
		Solution solution1 = solutions1.get(solutions1.size()-1);
		Solution solution2 = solutions2.get(solutions2.size()-1);
		
		//send assessment for other contestant
		contestant1.writer.println(ContestServer.ASSESSED+","+solution2.answer+","+solution2.correct);
		contestant2.writer.println(ContestServer.ASSESSED+","+solution1.answer+","+solution1.correct);

		int successes = 0;
		if(solution1.correct) successes++;
		if(solution2.correct) successes++;
		ContestServer.updateProblemStatistics(problems.get(problems.size()-1), 2, successes);
		
		//If there have not been five problems yet
		if(problems.size() < 5 && !forfeited)
		{
			//contestant1 does even indices of problems 2 & 4
			if(problems.size() % 2 == 0)
			{
				new Thread(new MessageDelay(contestant1,10000,ContestServer.REQUEST_PROBLEM)).start();
				problemRequestResponse = new Timer(ContestServer.PROBLEM_REQUEST_TIMEOUT_TIME, new TimeoutDelay(this, ContestServer.PROBLEM_REQUEST_TIMEOUT,contestant1));
				sendPrivateAnnounceMessage(GameShowUtilities.replaceTwoPieces(PROBLEM_REQUEST_MSG, contestant1.name, ""+(problems.size()+1)));
			}
			else
			{
				//contestant2 does odd indices of problems 1 & 3
				new Thread(new MessageDelay(contestant2,10000,ContestServer.REQUEST_PROBLEM)).start();
				problemRequestResponse = new Timer(ContestServer.PROBLEM_REQUEST_TIMEOUT_TIME, new TimeoutDelay(this, ContestServer.PROBLEM_REQUEST_TIMEOUT,contestant2));
				sendPrivateAnnounceMessage(GameShowUtilities.replaceTwoPieces(PROBLEM_REQUEST_MSG, contestant2.name, ""+(problems.size()+1)));
			}
			problemRequestResponse.setRepeats(false);
			problemRequestResponse.start();
		}
		else if(!forfeited)
		{
			//there has been five problems, end the contest
			endContest();
		}
		
	}

	public void stopProblemRequestResponseTimer()
        {
            if (problemRequestResponse != null)
            {
                problemRequestResponse.stop();
                //TimeoutDelay td = (TimeoutDelay) problemRequestResponse.getActionListeners()[0];
                //td.connection.writer.println("ProblemRequestExited");
		String problem = GameShowUtilities.generate();
		problems.add(problem);
		contestant1.writer.println(ContestServer.START_PROBLEM+","+problem);
		contestant2.writer.println(ContestServer.START_PROBLEM+","+problem);

		sendPrivateAnnounceMessage(GameShowUtilities.replacePiece(PROBLEM_START_MSG,""+problems.size()));
            }
        }
	
	public void forfeitGame(Connection forfeiter, boolean updateScore) {
		
		forfeited = true;
		
		Connection forfeitee = contestant1;
		if(forfeiter == contestant1)
			forfeitee = contestant2;
		
		String result = calculateStatsForfeit(forfeitee.name, forfeiter.name, updateScore);
		
		//Add solution paths for each
		result+=contestant1.name+":";
		for(Solution sol:solutions1)
		{
			result+=sol.solutionPath+";";
		}
		result+=","+contestant2.name+":";
		for(Solution sol:solutions2)
		{
			result+=sol.solutionPath+";";
		}
		
		//Add correctness of problems for each
		result+=","+contestant1.name+":";
		for(Solution sol:solutions1)
		{
			result+=sol.correct+";";
		}
		result+=","+contestant2.name+":";
		for(Solution sol:solutions2)
		{
			result+=sol.correct+";";
		}
		//Send message after 10 second delay for contestants to look at last problem
		//new Thread(new MessageDelay(contestant1,5000,ContestServer.FORFEIT+","+result)).start();
		//new Thread(new MessageDelay(contestant2,5000,ContestServer.FORFEIT+","+result)).start();

		if(updateScore)
		{
			contestant1.writer.println(ContestServer.FORFEIT+","+result);
			contestant2.writer.println(ContestServer.FORFEIT+","+result);
		}
		else
		{
			contestant1.writer.println(ContestServer.CANCEL+","+result);
			contestant2.writer.println(ContestServer.CANCEL+","+result);
		}
		
	}

	Timer problemAnswerResponse1,problemAnswerResponse2;

	public void startProblemTimers() {
		problemAnswerResponse1 = new Timer(ContestServer.PROBLEM_SOLVE_TIMEOUT_TIME, new TimeoutDelay(this, ContestServer.PROBLEM_ANSWER_TIMEOUT,contestant1));
		problemAnswerResponse2 = new Timer(ContestServer.PROBLEM_SOLVE_TIMEOUT_TIME, new TimeoutDelay(this, ContestServer.PROBLEM_ANSWER_TIMEOUT,contestant2));
		problemAnswerResponse1.start();
		problemAnswerResponse2.start();
	}


	public void processSolution(Connection connect, Solution sol) {
		
		List<Solution> solutionList;
		if(connect == contestant1)
			solutionList = solutions1;
		else
			solutionList = solutions2;
		solutionList.add(sol);
		
		//no prior solution has been received
		if(!answered)
			answered = true;
		else
		{
			//prior solution has been received, reset variable & send assessment of solutions
			answered = false;
			sendAssessment();
		}
		
	}


	/*
	 * End the contest: determine winner, calculate statistics for each contestant, 
	 * add all solution paths and send all this info to both contestants
	 */
	private void endContest() {
		String result = calculateStats();
		
		//Add solution paths for each
		result+=contestant1.name+":";
		for(Solution sol:solutions1)
		{
			result+=sol.solutionPath+";";
		}
		result+=","+contestant2.name+":";
		for(Solution sol:solutions2)
		{
			result+=sol.solutionPath+";";
		}
		
		//Add correctness of problems for each
		result+=","+contestant1.name+":";
		for(Solution sol:solutions1)
		{
			result+=sol.correct+";";
		}
		result+=","+contestant2.name+":";
		for(Solution sol:solutions2)
		{
			result+=sol.correct+";";
		}
		//Send message after 10 second delay for contestants to look at last problem
		new Thread(new MessageDelay(contestant1,10000,ContestServer.END_CONTEST+","+result)).start();
		new Thread(new MessageDelay(contestant2,10000,ContestServer.END_CONTEST+","+result)).start();

	}

	/*
	 * Create a string detailing statistics of a contest for sending an end contest message.
	 * Calculates winner, number of problems correct, average number of steps in correct problem,
	 * and overall percentage of steps correct
	 */
	private String calculateStats()
	{
		String results = "";
		int correct1 = 0;
		int correct2 = 0;
		int stepsOnCorrect1 = 0;
		int stepsOnCorrect2 = 0;
		int totalSteps1 = 0;
		int totalSteps2 = 0;
		int incorrectSteps1 = 0;
		int incorrectSteps2 = 0;
		
		//Count number of correct and number of both total and incorrect steps
		for(Solution sol:solutions1)
		{
			if(sol.correct)
			{
				correct1++;
				stepsOnCorrect1 += sol.numSteps;
			}
			totalSteps1 += sol.numSteps;
			incorrectSteps1 += sol.numIncorrectSteps;
		}
		for(Solution sol:solutions2)
		{
			if(sol.correct)
			{
				correct2++;
				stepsOnCorrect2 += sol.numSteps;
			}
			totalSteps2 += sol.numSteps;
			incorrectSteps2 += sol.numIncorrectSteps;
		}
		
		//Calculate average number of steps in a correct problem
		double avgStepsToCorrect1 = ((double) stepsOnCorrect1)/ correct1;
		double avgStepsToCorrect2 = ((double) stepsOnCorrect2)/ correct2;
		
		//If no problems are correct, use 0 as the avg steps in a correct solution, to avoid NaN
		if(correct1 == 0)
			avgStepsToCorrect1 = 0;
		if(correct2 == 0)
			avgStepsToCorrect2 = 0;
		if(totalSteps1 == 0)
			totalSteps1 = 1;
		if(totalSteps2 == 0)
			totalSteps2 = 1;
		
		//Calculate percentage of steps correct out of all steps
		int pctStepsCorrect1 = 100 - ( 100*incorrectSteps1/ totalSteps1);
		int pctStepsCorrect2 = 100 - ( 100*incorrectSteps2/ totalSteps2);
		
		//Determine winner and loser
		String winner = "";
		String loser = "";
		
		//due to more problems correct (first choice)
		if(correct1 > correct2)
		{
			winner = contestant1.name;
			loser = contestant2.name;
		}
		else if(correct2 > correct1)
		{
			winner = contestant2.name;
			loser = contestant1.name;
		}
		else
		{
			//due to shorter correct solutions (second choice)
			if(avgStepsToCorrect1 < avgStepsToCorrect2)
			{
				winner = contestant1.name;
				loser = contestant2.name;
			}
			else if(avgStepsToCorrect2 < avgStepsToCorrect1)
			{
				winner = contestant2.name;
				loser = contestant1.name;
			}
			else
			{
				//due to more steps correct overall
				if(pctStepsCorrect1 > pctStepsCorrect2)
				{
					winner = contestant1.name;
					loser = contestant2.name;
				}	
				else if(pctStepsCorrect2 > pctStepsCorrect1)
				{
					winner = contestant2.name;
					loser = contestant1.name;
				}
			}
		}
		
		//If there is a winner, update the ratings
		if(winner.length() > 0 && loser.length() > 0)
		{
			String winnerID = contestant1.getUserID();
			String loserID = contestant2.getUserID();
			if(contestant1.name.equals(loser))
			{
				winnerID = contestant2.getUserID();
				loserID = contestant1.getUserID();
			}
			ContestServer.updateRating(winnerID,loserID);
		}
		else //otherwise, update tie count
			ContestServer.updateRatingTie(contestant1.userid, contestant2.userid);
		
		/*int rating1 = ContestServer.competitors.get(contestant1.name).rating;
		int rating2 = ContestServer.competitors.get(contestant2.name).rating;
		*/
		int rating1 = ContestServer.competitors.get(contestant1.getUserID()).rating;
		int rating2 = ContestServer.competitors.get(contestant2.getUserID()).rating;
		
		results = winner+","+contestant1.name+":"+rating1+","+contestant2.name+":"+rating2+","+contestant1.name
		+":"+correct1+";"+avgStepsToCorrect1+";"+pctStepsCorrect1+","+contestant2.name+":"
		+correct2+";"+avgStepsToCorrect2+";"+pctStepsCorrect2+",";
		
		//Announce win or tie
		if(winner.length() > 0)
			server.announceWin(winner, loser);
		else
			server.announceTie(contestant1.name, contestant2.name);
		
		return results;
	}
	
	/*
	 * Create a string detailing statistics of a contest for sending an end contest message.
	 * Calculates winner, number of problems correct, average number of steps in correct problem,
	 * and overall percentage of steps correct
	 */
	private String calculateStatsForfeit(String forfeitee, String forfeiter, boolean updateScore)
	{
		String results = "";
		int correct1 = 0;
		int correct2 = 0;
		int stepsOnCorrect1 = 0;
		int stepsOnCorrect2 = 0;
		int totalSteps1 = 0;
		int totalSteps2 = 0;
		int incorrectSteps1 = 0;
		int incorrectSteps2 = 0;
		
		//Count number of correct and number of both total and incorrect steps
		for(Solution sol:solutions1)
		{
			if(sol.correct)
			{
				correct1++;
				stepsOnCorrect1 += sol.numSteps;
			}
			totalSteps1 += sol.numSteps;
			incorrectSteps1 += sol.numIncorrectSteps;
		}
		for(Solution sol:solutions2)
		{
			if(sol.correct)
			{
				correct2++;
				stepsOnCorrect2 += sol.numSteps;
			}
			totalSteps2 += sol.numSteps;
			incorrectSteps2 += sol.numIncorrectSteps;
		}
		
		//Calculate average number of steps in a correct problem
		double avgStepsToCorrect1 = ((double) stepsOnCorrect1)/ correct1;
		double avgStepsToCorrect2 = ((double) stepsOnCorrect2)/ correct2;
		
		//If no problems are correct, use 0 as the avg steps in a correct solution, to avoid NaN
		if(correct1 == 0)
			avgStepsToCorrect1 = 0;
		if(correct2 == 0)
			avgStepsToCorrect2 = 0;
		if(totalSteps1 == 0)
			totalSteps1 = 1;
		if(totalSteps2 == 0)
			totalSteps2 = 1;
		
		//Calculate percentage of steps correct out of all steps
		int pctStepsCorrect1 = 100 - ( 100*incorrectSteps1/ totalSteps1);
		int pctStepsCorrect2 = 100 - ( 100*incorrectSteps2/ totalSteps2);
		
		String forfeiteeID = contestant1.getUserID();
		String forfeiterID = contestant2.getUserID();
		if(contestant1.name.equals(forfeiter))
		{
			forfeiteeID = contestant2.getUserID();
			forfeiterID = contestant1.getUserID();
		}
		
		if(updateScore)
			ContestServer.updateRating(forfeiteeID,forfeiterID);
		
		/*int rating1 = ContestServer.competitors.get(contestant1.name).rating;
		int rating2 = ContestServer.competitors.get(contestant2.name).rating;
		*/
		int rating1 = ContestServer.competitors.get(contestant1.getUserID()).rating;
		int rating2 = ContestServer.competitors.get(contestant2.getUserID()).rating;
		
		results = forfeitee+","+contestant1.name+":"+rating1+","+contestant2.name+":"+rating2+","+contestant1.name
		+":"+correct1+";"+avgStepsToCorrect1+";"+pctStepsCorrect1+","+contestant2.name+":"
		+correct2+";"+avgStepsToCorrect2+";"+pctStepsCorrect2+",";
		
		//Announce forfeit
		server.announceForfeit(forfeitee, forfeiter);
		
		return results;
	}


	/*
	 * Send a message from the organizer to both contestants. Server announcement messages
	 * are surrounded by **'s to set them off.
	 */
	public void sendPrivateAnnounceMessage(String message) {
		
		message = "** "+message+" **";

		contestant1.writer.println(ContestServer.ANNOUNCE_PRIVATE_MESSAGE+","+message);
		contestant2.writer.println(ContestServer.ANNOUNCE_PRIVATE_MESSAGE+","+message);
		
	}


	@Override
	public void timeoutRecovery(String timeoutType, Connection connection1,
			Connection connection2) {
		if(forfeited)
			return;
		if(timeoutType.equals(ContestServer.PROBLEM_REQUEST_TIMEOUT))
		{
			connection1.writer.println(ContestServer.PROBLEM_REQUEST_TIMEOUT);
			String problem = GameShowUtilities.generate();
			problems.add(problem);
			contestant1.writer.println(ContestServer.START_PROBLEM+","+problem);
			contestant2.writer.println(ContestServer.START_PROBLEM+","+problem);

			sendPrivateAnnounceMessage(GameShowUtilities.replacePiece(PROBLEM_START_MSG,""+problems.size()));
		
		}
		if(timeoutType.equals(ContestServer.PROBLEM_ANSWER_TIMEOUT))
		{
			connection1.writer.println(ContestServer.PROBLEM_ANSWER_TIMEOUT);
			Solution sol = new Solution("?", false, 0, 0, "No Answer Submitted");
			processSolution(connection1, sol);
		}
		
	}
	
}
