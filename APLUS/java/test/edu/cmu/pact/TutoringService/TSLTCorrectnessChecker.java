/*Takes a .comp file and compares it to a .test file (System.out.printlning whether they match)
 *The .comp file is generated by the TSLTpreProcessor.
 *The .test file is generated by running test.sh (TSLTListener writes the actual file).
 *
 *Currently the .comp file is well formed XML, while .test is prepended with an xml header,
 *and a root object to make .test valid xml (subject to change soon.. but comments may be left unchanged :) )
 *
 *The comparison compares sequentially each message whose messagetype 
 *isn't in the filter list badMessageTypes. 
 *Written by Borg "The White Shadow" Lojasiewicz 7/10/09 
 */

package edu.cmu.pact.TutoringService;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.StringReader;
import java.util.Iterator;

import org.jdom.Document;
import org.jdom.Element;
import org.jdom.JDOMException;
import org.jdom.input.SAXBuilder;

import edu.cmu.pact.Log.LogFormatUtils;
import edu.cmu.pact.Utilities.trace;


class TSLTCorrectnessChecker {
	private final static String Usage = "Usage: Please enter .comp and .test file to compare\n";
	private static String[] badMessageTypes = {"VersionInfo","ProblemSummaryRequest"};
	private LogFormatUtils utils;
	public TSLTCorrectnessChecker () {
		utils = new LogFormatUtils();
	}
	
	private boolean sequentialCompareLogs(String comp, String test){
		Document compXML = null;
		Document testXML = null;
		SAXBuilder builder = new SAXBuilder();
		//JDOM is quite idiotic... saxbuilder doesn't have a build method
		//That takes a string.
		try {
			compXML = builder.build(new StringReader(comp));
			testXML = builder.build(new StringReader(test));
		} catch (JDOMException e){
			trace.out("tslt", "Test Failed: jdom exception building doc");
			System.out.println("Test Failed: jdom exception building doc");
			e.printStackTrace();
		} catch (IOException e){
			trace.out("tslt", "Test Failed: ioexception building doc");
			System.out.println("Test Failed: ioexception building doc");
			e.printStackTrace();
		}
		Element compRoot = compXML.getRootElement();
		Element testRoot = testXML.getRootElement();
		Iterator<Element> compIt = compRoot.getChildren().iterator();
		Iterator<Element> testIt = testRoot.getChildren().iterator();
		int i = 0;
		
		while(testIt.hasNext()){
			i++;
			Element testMessage = getNextMessage(testIt);
			Element compMessage = getNextMessage(compIt);
			if((testMessage==null)!=(compMessage==null)){
				return false;
			}
			if((testMessage==null)&&(compMessage==null)){
				return true;
			}
			if(!testProperties(compMessage,testMessage)){
				return false;
			}
			
		}
		return true;
	}
	private boolean testProperties(Element comp, Element test){
		Element compProperties = comp.getChild("properties");
		Element testProperties = comp.getChild("properties");
		String msgType = compProperties.getChildText("MessageType");
		if(!msgType.equals(testProperties.getChildText("MessageType"))){
			return false;
		}
		
		if(msgType.equals("InterfaceAction")){
			if(compProperties.getChild("transaction_id")!=null)
				if(!compProperties.getChildText("transaction_id").equals(testProperties.getChildText("transaction_id")))
					return false;
			if(!compProperties.getChild("Selection").getValue().equals(testProperties.getChild("Selection").getValue()))
				return false;
			if(!compProperties.getChild("Action").getValue().equals(testProperties.getChild("Action").getValue()))
				return false;
			if(!compProperties.getChild("Input").getValue().equals(testProperties.getChild("Input").getValue()))
				return false;
		}
		if(msgType.equals("CorrectAction")||msgType.equals("InCorrectAction")){
			if(compProperties.getChild("transaction_id")!=null)
				if(!compProperties.getChildText("transaction_id").equals(testProperties.getChildText("transaction_id")))
					return false;
			if(!compProperties.getChild("Selection").getValue().equals(testProperties.getChild("Selection").getValue()))
				return false;
			if(!compProperties.getChild("Action").getValue().equals(testProperties.getChild("Action").getValue()))
				return false;
			if(!compProperties.getChild("Input").getValue().equals(testProperties.getChild("Input").getValue()))
				return false;
		}
		if(msgType.equals("AssociatedRules")){
			if(compProperties.getChild("transaction_id")!=null)
				if(!compProperties.getChildText("transaction_id").equals(testProperties.getChildText("transaction_id")))
					return false;
			if(!compProperties.getChild("Selection").getValue().equals(testProperties.getChild("Selection").getValue()))
				return false;
			if(!compProperties.getChild("Action").getValue().equals(testProperties.getChild("Action").getValue()))
				return false;
			if(!compProperties.getChild("Input").getValue().equals(testProperties.getChild("Input").getValue()))
				return false;
		}
		//see if child elements of type value, otherwise just compare text.
		if(msgType.equals("ShowHintsMessage")){
			if(!compUnescapedValues(compProperties.getChild("HintsMessage"),testProperties.getChild("HintsMessage")))
				return false;
			if(!compProperties.getChild("Selection").getValue().equals(testProperties.getChild("Selection").getValue()))
				return false;
			if(!compProperties.getChild("Action").getValue().equals(testProperties.getChild("Action").getValue()))
				return false;
			if(!compProperties.getChild("Input").getValue().equals(testProperties.getChild("Input").getValue()))
				return false;
		}
		if(msgType.equals("ProblemSummaryResponse")){
			if(!compProperties.getChildText("ProblemSummary").equals(testProperties.getChildText("ProblemSummary")))
				return false;
		}
		return true;
	}
	
	private boolean compUnescapedValues(Element a, Element b){
		String aString = a.getValue();
		String bString = b.getValue();
		aString = utils.unescapeString(aString);
		bString = utils.unescapeString(bString);
		return aString.equals(bString);
	}
	/*Gets the nextMessage from the iterator that isn't filtered by
	 * badMessageTypes.
	 */
	private Element getNextMessage(Iterator<Element> it){
		Element message;
		Element messageType;
		int i = 0;
		boolean goodMessageType;
		while(it.hasNext()){
			goodMessageType = true;
			message = it.next();
			messageType = message.getChild("properties").getChild("MessageType");
			String text = messageType.getText();
			for(i = 0; i < badMessageTypes.length; i++){
				if(text.equals(badMessageTypes[i])){
					goodMessageType = false;
					continue;
				}
			}
			if(goodMessageType){
				return message;
			}
		}
		return null;
	}
	
	public static void main (String args[])
	{
		TSLTCorrectnessChecker TSLTCC = new TSLTCorrectnessChecker();
		String compFilePath = "";
		String testFilePath = "";
		if (args.length == 2)
		{
			compFilePath = args[0];
			testFilePath = args[1];
		}else{
			trace.out("tslt", "Test Failed: improper usage");
			System.out.println("Test Failed: improper usage");
			System.out.println("Usage: TSLTCorrectnessChecker testFilePath [origFilePath]");
			return;
		}
		trace.out("tslt", "TSLTCorrectnessChecking " + compFilePath + " vs " + testFilePath);
		String testXML = "<?xml version=\"1.0\" standalone=\"yes\"?>\n<messages>\n";
		String compXML = "";
		try{
			BufferedReader br = new BufferedReader(new FileReader(new File(testFilePath)));
			while(br.ready()){
				testXML+=br.readLine()+'\n';
			}
			br.close();
			testXML+="</messages>";
			br = new BufferedReader(new FileReader(new File(compFilePath)));
			while(br.ready()){
				compXML+=br.readLine()+'\n';
			}
			br.close();
		}
		catch(Exception e){
			System.out.println(Usage);
			System.out.println("File reading exception of some sorts, test failed");
			trace.out("tslt", "File reading exception of some sorts, test failed");
			return;
		}
		if (TSLTCC.sequentialCompareLogs(compXML, testXML)){
			trace.out("tslt", "Test log matches the original log");
			System.out.println("Test log matches the original log");
		}else{
			trace.out("tslt", "Test Failed: log DOESN NOT MATCH original log");
			System.out.println("Test Failed: log DOESN NOT MATCH original log");
		}
	}
}