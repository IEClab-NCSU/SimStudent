FOIL 6.4   [January 1996]
--------

    Options:
	minimum clause accuracy 1.41944e+09%

Relation subtract-typein

Relation *IsAVarTerm

Relation *Homogeneous

Relation *IsDenominatorOf

Relation *IsPolynomial

Relation *IsConstant

Relation *IsSkillAdd

Relation *IsSkillDivide

Relation *Monomial

Relation *IsFractionTerm

Relation *HasConstTerm

Relation *HasParentheses

Relation *HasCoefficient

Relation *IsLastConstTermNegative

Relation *HasVarTerm

Relation *NotNull

Relation *IsNumeratorOf

Relation *IsSkillSubtract

Relation *IsSkillMultiply

----------
subtract-typein:

State (2/30, 15.0 bits available)

	Save not(IsSkillDivide(B)) (2,20 value 1.1)
	Save IsPolynomial(A) (1,9 value 1.0)
	Save HasVarTerm(A) (1,9 value 1.0)
	Save not(Homogeneous(A)) (1,9 value 1.0)

Best literal IsSkillSubtract(B) (5.0 bits)

State (2/20, 10.0 bits available)

	Save HasVarTerm(A) (1,6 value 1.6)
	Save not(Homogeneous(A)) (1,6 value 1.6)
	Save not(Monomial(A)) (1,6 value 1.6)

Best literal IsPolynomial(A) (5.0 bits)

State (1/6, 1.8 bits available)

No literals

Recover to subtract-typein(A,B) :- IsSkillSubtract(B), HasVarTerm(A).

State (1/6, 1.8 bits available)

No literals

Recover to subtract-typein(A,B) :- IsSkillSubtract(B), not(Homogeneous(A)).

State (1/6, 1.8 bits available)

No literals

Recover to subtract-typein(A,B) :- IsSkillSubtract(B), not(Monomial(A)).

State (1/6, 1.8 bits available)

No literals

Recover to subtract-typein(A,B) :- not(IsSkillDivide(B)).

State (2/20, 10.0 bits available)

	Save HasVarTerm(A) (1,6 value 1.6)
	Save not(Homogeneous(A)) (1,6 value 1.6)
	Save not(Monomial(A)) (1,6 value 1.6)

Best literal IsPolynomial(A) (5.0 bits)

State (1/6, 1.8 bits available)

No literals

Recover to subtract-typein(A,B) :- not(IsSkillDivide(B)), HasVarTerm(A).

State (1/6, 1.8 bits available)

No literals

Recover to subtract-typein(A,B) :- not(IsSkillDivide(B)), not(Homogeneous(A)).

State (1/6, 1.8 bits available)

No literals

Recover to subtract-typein(A,B) :- not(IsSkillDivide(B)), not(Monomial(A)).

State (1/6, 1.8 bits available)

No literals

Recover to subtract-typein(A,B) :- IsPolynomial(A).

State (1/9, 5.8 bits available)

	Save not(IsSkillDivide(B)) (1,6 value 1.6)

Best literal IsSkillSubtract(B) (5.0 bits)

State (1/6, 1.8 bits available)

No literals

Recover to subtract-typein(A,B) :- IsPolynomial(A), not(IsSkillDivide(B)).

State (1/6, 1.8 bits available)

No literals

Recover to subtract-typein(A,B) :- HasVarTerm(A).

State (1/9, 5.8 bits available)

	Save not(IsSkillDivide(B)) (1,6 value 1.6)

Best literal IsSkillSubtract(B) (5.0 bits)

State (1/6, 1.8 bits available)

No literals

Recover to subtract-typein(A,B) :- HasVarTerm(A), not(IsSkillDivide(B)).

State (1/6, 1.8 bits available)

No literals

Recover to subtract-typein(A,B) :- not(Homogeneous(A)).

State (1/9, 5.8 bits available)

	Save not(IsSkillDivide(B)) (1,6 value 1.6)

Best literal IsSkillSubtract(B) (5.0 bits)

State (1/6, 1.8 bits available)

No literals

Recover to subtract-typein(A,B) :- not(Homogeneous(A)), not(IsSkillDivide(B)).

State (1/6, 1.8 bits available)

No literals

Clause too inaccurate (1/6)

***  Warning: the following definition
***  does not cover 2 tuples in the relation


Time 0.0 secs
