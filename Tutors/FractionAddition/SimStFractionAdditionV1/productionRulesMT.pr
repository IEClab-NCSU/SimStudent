;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;																			    ;;
;;  This file contains Jess / SimStudent production rules to tutor effectively  ;;
;;  (MetaCognitive Model) when teaching SimStudent.							    ;;
;;																				;;
;; 	Simulated Student Project													;;
;;  Carnegie Mellon University													;;
;;																				;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; You may need to add similar statements if you wish to add your own predicates
;; and operator symbols.See http://herzberg.ca.sandia.gov/jess/docs/70/extending.html
;; for details.

;; Now define the behavior rules themselves. Each rule matches a set of conditions
;; and then predicts the student SAI, the hint message and updates the working memory
;; if the student SAI matches the rule SAI.

;; Removing a following line will jeopardize the tutor's model tracing capability

;; (watch all) ;; for debug

;;
;; If [APlusLaunched == "true"]
;; Then
;; [Press Quiz Button]
(defrule simst-launch-take-quiz
	"If APlusLaunched then take the quiz"
	(declare (salience 150)) ;; salience determines the priority of the rules : higher the salience, higher the priority
	?wm <- (ModelTraceWorkingMemory (APlusLaunched "true") 
									(studentEnteredProblem ?enteredProblem&:(eq ?enteredProblem nil)))
	=>
	(predicted-sai quiz ButtonPressed -1) ;; predicts-the-ruleSAI
	(update-wm-if-ruleSAI-equals-studentSAI ?wm "(quizTaken true)" "(APlusLaunched false)") ;; updates the working memory when the rule's predicted values matches the student's values
	(construct-tutor-hint-message
		"[ It's a good strategy to quiz SimStName, because it would help you to understand what SimStName already knows. ]"
		"[ Click the Quiz button. ]"))

		

;; Buggy / Suboptimal rule: If in the beginning instead of taking the quiz, they start to tutor a
;; problem then let them finish the problem but remind them that they need to take a quiz.
(defrule BUG-simst-enter-lhs-problem
	(declare (salience 50))
	?wm <- (or (ModelTraceWorkingMemory (APlusLaunched "true"))
			   (ModelTraceWorkingMemory (quizTaken "true") 
									(quizOutcome "pass"))
			   (ModelTraceWorkingMemory (quizTaken "true")
									(quizOutcome "fail"))
			   (ModelTraceWorkingMemory (problemType "failedQuizProblem")
									(problemStatus "solved"))
			   (ModelTraceWorkingMemory (problemType "failedQuizProblem")
									(problemStatus "abandoned"))
			   (ModelTraceWorkingMemory (problemType "solvedQuizProblem")
									(problemStatus "solved"))
			   (ModelTraceWorkingMemory (problemType "solvedQuizProblem")
									(problemStatus "abandoned")))
	(studentValues (selection ?sel&:(eq ?sel "dorminTable1_C1R1")) (input ?inp&:(neq ?inp nil)))
	=>
	(predicted-sai ?sel DONT-CARE ?inp)
	(modify ?wm (lhsProblem ?inp) (lhsQProblem nil) (rhsQProblem nil)))


(defrule BUG-simst-enter-rhs-problem
	(declare (salience 50))
	?wm <- (or (ModelTraceWorkingMemory (APlusLaunched "true"))
			   (ModelTraceWorkingMemory (quizTaken "true")
									(quizOutcome "pass"))
			   (ModelTraceWorkingMemory (quizTaken "true")
									(quizOutcome "fail"))
			   (ModelTraceWorkingMemory (problemType "failedQuizProblem")
									(problemStatus "solved"))
			   (ModelTraceWorkingMemory (problemType "failedQuizProblem")
									(problemStatus "abandoned"))
			   (ModelTraceWorkingMemory (problemType "solvedQuizProblem")
									(problemStatus "solved"))
			   (ModelTraceWorkingMemory (problemType "solvedQuizProblem")
									(problemStatus "abandoned")))
	(studentValues (selection ?sel&:(eq ?sel "dorminTable2_C1R1")) (input ?inp&:(neq ?inp nil)))
	=>
	(predicted-sai ?sel DONT-CARE ?inp)
	(modify ?wm (rhsProblem ?inp) (lhsQProblem nil) (rhsQProblem nil)))


(defrule BUG-simst-start-problem
	(declare (salience 50))
	?wm <- (or (ModelTraceWorkingMemory (APlusLaunched "true")
							 (lhsProblem ?lhs&:(neq ?lhs nil))
							 (rhsProblem ?rhs&:(neq ?rhs nil)))
			   (ModelTraceWorkingMemory (quizTaken "true")
							 (quizOutcome "pass")
							 (lhsProblem ?lhs&:(neq ?lhs nil))
							 (rhsProblem ?rhs&:(neq ?rhs nil)))
			   (ModelTraceWorkingMemory (quizTaken "true")
							 (quizOutcome "fail")
							 (lhsProblem ?lhs&:(neq ?lhs nil))
							 (rhsProblem ?rhs&:(neq ?rhs nil)))
			   (ModelTraceWorkingMemory (problemType "failedQuizProblem")
							 (problemStatus "solved")
							 (lhsProblem ?lhs&:(neq ?lhs nil))
							 (rhsProblem ?rhs&:(neq ?rhs nil)))
			   (ModelTraceWorkingMemory (problemType "failedQuizProblem")
							 (problemStatus "abandoned")
							 (lhsProblem ?lhs&:(neq ?lhs nil))
							 (rhsProblem ?rhs&:(neq ?rhs nil)))
			   (ModelTraceWorkingMemory (problemType "solvedQuizProblem")
							 (problemStatus "solved")
							 (lhsProblem ?lhs&:(neq ?lhs nil))
							 (rhsProblem ?rhs&:(neq ?rhs nil)))
			   (ModelTraceWorkingMemory (problemType "solvedQuizProblem")
							 (problemStatus "abandoned")
							 (lhsProblem ?lhs&:(neq ?lhs nil))
							 (rhsProblem ?rhs&:(neq ?rhs nil))))
	(studentValues (selection ?sel&:(eq ?sel "yes")))
	=>
	(predicted-sai yes ButtonPressed -1)
	(bind ?problem (get-problem ?lhs ?rhs))
	(modify ?wm (studentEnteredProblem ?problem)))


;; Buggy rule for when a student abandons a problem and takes a quiz
(defrule BUG-simst-take-quiz-inopportunely 
	(declare (salience 25)) ;; most low priority rule in the entire file
	?wm <- (ModelTraceWorkingMemory (quizTaken ?qTaken))
	(studentValues (selection ?sel&:(eq ?sel "quiz")))
	=>
	(predicted-sai quiz ButtonPressed -1)
	(update-wm-if-ruleSAI-equals-studentSAI ?wm "(APlusLaunched false)" "(hintRequestSolvedQuizProblem nil)" "(lhsProblem nil)"
		"(lhsQProblem nil)" "(rhsProblem nil)" "(rhsQProblem nil)" "(problemStatus nil)" "(problemType nil)" "(quizProblemsPassed nil)"
		"(quizProblemsFailedList nil)" "(quizOutcome nil)" "(quizProblemsTutoredList nil)" "(quizTaken true)" "(requestType nil)" 
		"(studentEnteredProblem nil)" "(UOTabReviewed nil)"))


;;
;; If [quizTaken == "true"] And [quizOutcome == "pass"]
;; Then
;; [Press Quiz Button]
(defrule simst-quiz-pass-take-quiz
	"If student took the quiz and passed it then take the quiz again"
	(declare (salience 150))
	?wm <- (ModelTraceWorkingMemory (quizTaken "true") 
	 							 (quizOutcome "pass")
								 (studentEnteredProblem ?enteredProblem&:(eq ?enteredProblem nil)))
	=>
	(predicted-sai quiz ButtonPressed -1)
	(update-wm-if-ruleSAI-equals-studentSAI ?wm "(quizTaken true)" "(studentEnteredProblem nil)")
	(construct-tutor-hint-message
		"[ Since SimStName passed this quiz section, it might be helpful to understand what else your student knows. So it would be a good idea to quiz SimStName again now. ]"
		"[ Click the Quiz button. ]"))


;;
;; BUG rule: only models actions that the students should not do. Could explicitly 
;; generate a hint message when the bug rule fires to alert the student.
;; If [quizTaken == "true"] And [quizOutcome == "fail"]
;; Then
;; [Press Quiz Button]
(defrule BUG-simst-quiz-fail-take-quiz
	"If student took the quiz and failed it then take the quiz again"
	(declare (salience 50))
	?wm <- (ModelTraceWorkingMemory (quizTaken "true") 
								 (quizOutcome "fail")
								 (studentEnteredProblem ?enteredProblem&:(eq ?enteredProblem nil)))
	=>
	(predicted-sai quiz ButtonPressed -1)
	(update-wm-if-ruleSAI-equals-studentSAI ?wm "(quizTaken true)" "(studentEnteredProblem nil)"))


(defrule simst-quiz-fail-again-enter-lhs-first-failed-quiz-problem-type
	(declare (salience 200))
	?wm <- (or (ModelTraceWorkingMemory (quizTaken "true")
									(quizOutcome "fail")
									(quizProblemsFailedList ?suggestedProblems&:(neq ?suggestedProblems nil))
									(studentEnteredProblem ?enteredProblem&:(eq ?enteredProblem nil))
									(quizProblemsTutoredListAllSections ?tutoredProblemsAllSections))
			   (ModelTraceWorkingMemory  (problemType "failedQuizProblem")
									(problemStatus "abandoned")
									(studentEnteredProblem ?enteredProblem&:(eq ?enteredProblem nil))
									(quizProblemsFailedList ?suggestedProblems&:(neq ?suggestedProblems nil))
									(quizProblemsTutoredList ?tutoredProblems&:(eq ?tutoredProblems nil))
									(quizProblemsTutoredListAllSections ?tutoredProblemsAllSections)))
	(studentValues (selection ?sel) (input ?inp))
	(test (has-first-suggested-problem-been-tutored (get-first-problem ?suggestedProblems) ?tutoredProblemsAllSections)) 
	=>
	(bind ?firstFailedProblem (get-first-problem ?suggestedProblems))
	(bind ?similarPType (get-similar-problem ?firstFailedProblem))
	(bind ?lhsSimilarPType (get-lhs ?similarPType))
	(bind ?rhsSimilarPType (get-rhs ?similarPType))
	(bind ?problem (comp-problem-with-hindsight ?suggestedProblems ?inp ?sel dorminTable2_C1R1))
	(bind ?lhs-problem (get-lhs ?problem))
	(bind ?rhs-problem (get-rhs ?problem))
	(predicted-sai dorminTable1_C1R1 UpdateTable ?lhs-problem)
	(update-wm-if-ruleSAI-equals-student-entered-side ?wm lhsQProblem ?lhs-problem)
	(construct-tutor-hint-message
		"[ SimStName got some problems wrong on the quiz. It's a good strategy to teach those problems to help SimStName correct the mistakes. ]"
		"[ Since " ?problem " was wrong on the quiz, you may want to give a similar problem like " ?similarPType " to SimStName. ]"
		"[ Start by putting " ?lhsSimilarPType " on the first fraction and  " ?rhsSimilarPType " on the second fraction of the tutoring interface. ]"))


(defrule simst-quiz-fail-again-enter-rhs-first-failed-quiz-problem-type
	(declare (salience 175))
	?wm <- (or (ModelTraceWorkingMemory  (quizTaken "true")
									(quizOutcome "fail")
									(quizProblemsFailedList ?suggestedProblems&:(neq ?suggestedProblems nil))
									(studentEnteredProblem ?enteredProblem&:(eq ?enteredProblem nil))
									(quizProblemsTutoredListAllSections ?tutoredProblemsAllSections)
									(lhsQProblem ?lhs&:(neq ?lhs nil)))
			   (ModelTraceWorkingMemory  (problemType "failedQuizProblem")
									(problemStatus "abandoned")
									(studentEnteredProblem ?enteredProblem&:(eq ?enteredProblem nil))
									(quizProblemsFailedList ?suggestedProblems&:(neq ?suggestedProblems nil))
									(quizProblemsTutoredList ?tutoredProblems&:(eq ?tutoredProblems nil))
									(quizProblemsTutoredListAllSections ?tutoredProblemsAllSections)
									(lhsQProblem ?lhs&:(neq ?lhs nil))))
	(studentValues (selection ?sel) (input ?inp))
	(test (has-first-suggested-problem-been-tutored (get-first-problem ?suggestedProblems) ?tutoredProblemsAllSections))
	=>
	(bind ?firstFailedProblem (get-first-problem ?suggestedProblems))
	(bind ?similarPType (get-similar-problem ?firstFailedProblem))
	(bind ?problem (comp-problem-with-hindsight ?suggestedProblems ?inp ?sel dorminTable1_C1R1))
	(bind ?rhs-problem (get-rhs ?problem))
	(predicted-sai dorminTable2_C1R1 UpdateTable ?rhs-problem)
	(update-wm-if-ruleSAI-equals-student-entered-side ?wm rhsQProblem ?rhs-problem))


;; Testing in Progress
(defrule simst-undo-failed-quiz-problem
	(declare (salience 100))
	?wm <- (or (ModelTraceWorkingMemory (studentEnteredProblem ?enteredProblem&:(eq ?enteredProblem nil))
								(problemType ?pType&:(eq ?pType "failedQuizProblem"))
								(quizProblemsTutoredList ?tutoredProblems)
								(quizProblemsFailedList ?suggestedProblems))
			   (ModelTraceWorkingMemory (studentEnteredProblem ?enteredProblem&:(neq ?enteredProblem nil))
								(problemType ?pType&:(eq ?pType "failedQuizProblem"))
								(quizProblemsTutoredList ?tutoredProblems)
								(quizProblemsFailedList ?suggestedProblems)))
	(studentValues (selection ?sel&:(eq ?sel "undo")))
	(or 
		(test (eq (get-abstracted-problem (get-current-student-entered-problem dorminTable1_C1R1 dorminTable2_C1R1))
			(get-abstracted-problem (get-first-problem ?tutoredProblems))))
		(test (is-problem-subset-of-list ?suggestedProblems (get-abstracted-problem (get-current-student-entered-problem 
			dorminTable1_C1R1 dorminTable2_C1R1)))))
	=>
	(predicted-sai undo ButtonPressed -1)
	(bind ?currentStudentProblem (get-current-student-entered-problem dorminTable1_C1R1 dorminTable2_C1R1))
	(bind ?lhsCurrentStudentProblem (get-lhs ?currentStudentProblem))
	(bind ?rhsCurrentStudentProblem (get-rhs ?currentStudentProblem))
	(bind ?quizProblemsFList (add-problem-if-not-in-list ?suggestedProblems ?currentStudentProblem))
	(bind ?quizProblemsTList (remove-problem-from-head-of-list ?tutoredProblems (get-abstracted-problem ?currentStudentProblem)))
	(update-wm-if-ruleSAI-equals-student-entered-side ?wm lhsQProblem ?lhsCurrentStudentProblem rhsQProblem ?rhsCurrentStudentProblem problemStatus nil
		problemType failedQuizProblem studentEnteredProblem ?currentStudentProblem quizProblemsFailedList ?quizProblemsFList quizProblemsTutoredList ?quizProblemsTList))


;; Testing in progress
(defrule simst-undo-solved-quiz-problem
	(declare (salience 95))
	?wm <- (or (ModelTraceWorkingMemory (studentEnteredProblem ?enteredProblem&:(eq ?enteredProblem nil))
								(problemType ?pType&:(eq ?pType "solvedQuizProblem")))
			   (ModelTraceWorkingMemory (studentEnteredProblem ?enteredProblem&:(neq ?enteredProblem nil))
								(problemType ?pType&:(eq ?pType "solvedQuizProblem"))))
	(studentValues (selection ?sel&:(eq ?sel "undo")))
	=>
	(predicted-sai undo ButtonPressed -1)
	(bind ?currentStudentProblem (get-current-student-entered-problem dorminTable1_C1R1 dorminTable2_C1R1))
	(bind ?lhsCurrentStudentProblem (get-lhs ?currentStudentProblem))
	(bind ?rhsCurrentStudentProblem (get-rhs ?currentStudentProblem))
	(update-wm-if-ruleSAI-equals-student-entered-side ?wm lhsQProblem ?lhsCurrentStudentProblem rhsQProblem ?rhsCurrentStudentProblem problemStatus nil
		problemType solvedQuizProblem studentEnteredProblem ?currentStudentProblem))


;; Testing in progress
(defrule simst-undo-problem
	(declare (salience 90))
	?wm <- (or  (ModelTraceWorkingMemory (studentEnteredProblem ?enteredProblem&:(neq ?enteredProblem nil)))
				(ModelTraceWorkingMemory (studentEnteredProblem ?enteredProblem&:(eq ?enteredProblem nil))))
	(studentValues (selection ?sel&:(eq ?sel "undo")))
	=>
	(predicted-sai undo ButtonPressed -1)
	(bind ?currentStudentProblem (get-current-student-entered-problem dorminTable1_C1R1 dorminTable2_C1R1))
	(bind ?lhsCurrentStudentProblem (get-lhs ?currentStudentProblem))
	(bind ?rhsCurrentStudentProblem (get-rhs ?currentStudentProblem))
	(update-wm-if-ruleSAI-equals-student-entered-side ?wm lhsProblem ?lhsCurrentStudentProblem rhsProblem ?rhsCurrentStudentProblem 
		studentEnteredProblem ?currentStudentProblem))


;;
;; If [quizTaken == "true"] And [quizOutcome == "fail"]
;; Then
;; [Enter left hand side of failed quiz problem type]
;;
;; This is a little bit different(hacky) as even if the rule SAI matches student SAI
;; we might not need to update the wm, as rhs might not have been entered yet so only
;; update the wm if the student started problem can be found in the failed quiz problems list
(defrule simst-quiz-fail-enter-lhs-failed-quiz-problem
	(declare (salience 150))
	?wm <- (or (ModelTraceWorkingMemory (quizTaken "true") 
									(quizOutcome "fail")
									(quizProblemsFailedList ?suggestedProblems&:(neq ?suggestedProblems nil))
									(studentEnteredProblem ?enteredProblem&:(eq ?enteredProblem nil)))
				(ModelTraceWorkingMemory (problemType "failedQuizProblem")
									(problemStatus "abandoned")
									(studentEnteredProblem ?enteredProblem&:(eq ?enteredProblem nil))
									(quizProblemsFailedList ?suggestedProblems&:(neq ?suggestedProblems nil))
									(quizProblemsTutoredList ?tutoredProblems&:(eq ?tutoredProblems nil))))
	(studentValues (selection ?sel) (input ?inp))
	=>
	(bind ?problem (comp-problem-with-hindsight ?suggestedProblems ?inp ?sel dorminTable2_C1R1))
	(bind ?lhs-problem (get-lhs ?problem))
	(bind ?rhs-problem (get-rhs ?problem))
	(predicted-sai dorminTable1_C1R1 UpdateTable ?lhs-problem)
	(update-wm-if-ruleSAI-equals-student-entered-side ?wm lhsQProblem ?lhs-problem)
	(construct-tutor-hint-message 
		"[ SimStName got some problems wrong on the quiz. It's a good strategy to teach those problems to help SimStName correct the mistakes. ]"
		"[ Since " ?problem " was wrong on the quiz, you may want to give " ?problem " to SimStName. ]"
		"[ Start by putting " ?lhs-problem " on the first fraction and " ?rhs-problem " on the second fraction of the tutoring interface. ]"))


;;
;; If [quizTaken == "true"] And [quizOutcome == "fail"]
;; Then
;; [Enter right hand side of the failed quiz problem type]
(defrule simst-quiz-fail-enter-rhs-failed-quiz-problem
	(declare (salience 125))
	?wm <- (or (ModelTraceWorkingMemory (quizTaken "true")
									(quizOutcome "fail")
									(quizProblemsFailedList ?suggestedProblems&:(neq ?suggestedProblems nil))
									(studentEnteredProblem ?enteredProblem&:(eq ?enteredProblem nil)))
				(ModelTraceWorkingMemory (problemType "failedQuizProblem")
									(problemStatus "abandoned")
									(studentEnteredProblem ?enteredProblem&:(eq ?enteredProblem nil))
									(quizProblemsFailedList ?suggestedProblems&:(neq ?suggestedProblems nil))
									(quizProblemsTutoredList ?tutoredProblems&:(eq ?tutoredProblems nil))))
	(studentValues (selection ?sel) (input ?inp))
	=>
	(bind ?problem (comp-problem-with-hindsight ?suggestedProblems ?inp ?sel dorminTable1_C1R1))
	(bind ?rhs-problem (get-rhs ?problem))
	(predicted-sai dorminTable2_C1R1 UpdateTable ?rhs-problem)
	(update-wm-if-ruleSAI-equals-student-entered-side ?wm rhsQProblem ?rhs-problem))


(defrule simst-start-failed-quiz-problem
	(declare (salience 200))
	?wm <- (ModelTraceWorkingMemory (quizProblemsFailedList ?suggestedProblems&:(neq ?suggestedProblems nil))
								(studentEnteredProblem ?enteredProblem&:(eq ?enteredProblem nil))
								(lhsQProblem ?lhs&:(neq ?lhs nil))
								(rhsQProblem ?rhs&:(neq ?rhs nil)))
	(studentValues (selection ?sel&:(eq ?sel "yes")))
	(test (problem-type ?suggestedProblems (get-problem ?lhs ?rhs)))
	=>
	(predicted-sai yes ButtonPressed -1)
	(bind ?problem (get-problem ?lhs ?rhs))
	(update-wm-if-student-problem-matches-list ?suggestedProblems dorminTable1_C1R1 dorminTable2_C1R1 ?wm
		studentEnteredProblem ?problem problemType failedQuizProblem problemStatus nil requestType nil quizTaken nil))


;; No hint message for these rules
(defrule simst-hint-request-demonstrate-step
	(declare (salience 100))
	?wm <- (or (ModelTraceWorkingMemory (studentEnteredProblem ?enteredProblem&:(neq ?enteredProblem nil))
									(requestType "hint-request")
									(problemType "failedQuizProblem"))
			   (ModelTraceWorkingMemory (studentEnteredProblem ?enteredProblem&:(neq ?enteredProblem nil))
									(requestType "hint-request")
									(problemType ?pType&:(neq ?pType "failedQuizProblem"))
									(problemType ?pType&:(neq ?pType "solvedQuizProblem"))))
	(studentValues (selection ?sel) (input ?inp)) ;; (action "UpdateTable")
	=>
	(bind ?ruleSAIHintMsg (get-correct-sai))
	(predicted-sai ?sel UpdateTable ?inp)
	(construct-tutor-hint-message	
		"[ SimStName is asking for help. You should tell SimStName the next step. ]")
	(construct-cl-hint-message
		"[ " ?ruleSAIHintMsg " ]")
	(update-wm-if-ruleSAI-equals-studentSAI ?wm "(requestType nil)"))


;; No hint message for these rules
(defrule simst-hint-request-demonstrate-step-solvedQP
	(declare (salience 100))
	?wm <- (ModelTraceWorkingMemory (studentEnteredProblem ?enteredProblem&:(neq ?enteredProblem nil))
									(requestType "hint-request")
									(problemType "solvedQuizProblem"))
	(studentValues (selection ?sel) (input ?inp)) ;; (action "UpdateTable")
	=>
	(bind ?ruleSAIHintMsg (get-correct-sai))
	(predicted-sai ?sel UpdateTable ?inp)
	(construct-tutor-hint-message	
		"[ SimStName is asking for help. You should tell SimStName the next step. ]")
	(construct-cl-hint-message
		"[ " ?ruleSAIHintMsg " ]")
	(update-wm-if-ruleSAI-equals-studentSAI ?wm "(requestType nil)" "(hintRequestSolvedQuizProblem true)"))


;; No hint message for these rules
(defrule simst-feedback-request-provide-positive-feedback
	(declare (salience 125))
	?wm <- (ModelTraceWorkingMemory (studentEnteredProblem ?enteredProblem&:(neq ?enteredProblem nil))
									(requestType "feedback-request"))
	=>
	(bind ?result (check-correctness-simststep-jo))
	(predicted-sai yes ButtonPressed -1)
	(construct-cl-hint-message
		"[ " ?result " ]")
	(update-wm-if-ruleSAI-equals-studentSAI ?wm "(requestType nil)"))


;; No hint message for these rules
(defrule simst-feedback-request-provide-negative-feedback
	(declare (salience 125))
	?wm <- (ModelTraceWorkingMemory (studentEnteredProblem ?enteredProblem&:(neq ?enteredProblem nil))
									(requestType "feedback-request"))
	=>
	(bind ?result (check-correctness-simststep-jo))
	(predicted-sai no ButtonPressed -1)
	(construct-cl-hint-message
		"[ " ?result " ]")
	(update-wm-if-ruleSAI-equals-studentSAI ?wm "(requestType nil)"))


;; No hint message for these rules
(defrule simst-hint-or-feedback-request-demonstrate-done-step
	(declare (salience 150))
	?wm <- (or (ModelTraceWorkingMemory (studentEnteredProblem ?enteredProblem&:(neq ?enteredProblem nil))
										(problemType "failedQuizProblem")
										(quizProblemsFailedList ?suggestedProblems)
										(requestType "hint-request"))
			   (ModelTraceWorkingMemory (studentEnteredProblem ?enteredProblem&:(neq ?enteredProblem nil))
										(problemType "failedQuizProblem")
										(quizProblemsFailedList ?suggestedProblems)
										(requestType "feedback-request"))
			   (ModelTraceWorkingMemory (studentEnteredProblem ?enteredProblem&:(neq ?enteredProblem nil))
										(problemType "solvedQuizProblem")
										(quizProblemsTutoredList ?suggestedProblems)
;;										(quizProblemsFailedList ?suggestedProblems)
										(requestType "hint-request"))
			   (ModelTraceWorkingMemory (studentEnteredProblem ?enteredProblem&:(neq ?enteredProblem nil))
   									    (problemType "solvedQuizProblem")
										(quizProblemsTutoredList ?suggestedProblems)
;;										(quizProblemsFailedList ?suggestedProblems)
										(requestType "feedback-request")))
	(studentValues (selection "done") (action "ButtonPressed") (input "-1"))
	(test (problem-type ?suggestedProblems ?enteredProblem))
	=>
	(predicted-sai done ButtonPressed -1)
	(update-wm-if-ruleSAI-equals-studentSAI ?wm "(requestType nil)" "(problemStatus solved)" "(studentEnteredProblem nil)"
		"(lhsProblem nil)" "(rhsProblem nil)" "(lhsQProblem nil)" "(rhsQProblem nil)")
	(update-failedQuizP-list-tutoredQuizP-list ?wm quizProblemsFailedList quizProblemsTutoredList ?enteredProblem))


(defrule simst-hint-or-feedback-request-demonstrate-done-step2
	(declare (salience 125))
	?wm <- (or (ModelTraceWorkingMemory (studentEnteredProblem ?enteredProblem&:(neq ?enteredProblem nil))
										(requestType "hint-request"))
			   (ModelTraceWorkingMemory (studentEnteredProblem ?enteredProblem&:(neq ?enteredProblem nil))
										(requestType "feedback-request")))
	(studentValues (selection "done") (action "ButtonPressed") (input "-1"))
	=>
	(predicted-sai done ButtonPressed -1)
	(update-wm-if-ruleSAI-equals-studentSAI ?wm "(requestType nil)" "(studentEnteredProblem nil)" "(lhsProblem nil)" 
		"(rhsProblem nil)" "(lhsQProblem nil)" "(rhsQProblem nil)"))


;; No hint message for these rules
(defrule simst-quit-problem
	(declare (salience 90))
	?wm <- (or  (ModelTraceWorkingMemory (studentEnteredProblem ?enteredProblem&:(neq ?enteredProblem nil))
										 (problemType "failedQuizProblem")
										 (quizProblemsFailedList ?list))
;;										 (requestType "feedback-request"))
				(ModelTraceWorkingMemory (studentEnteredProblem ?enteredProblem&:(neq ?enteredProblem nil))
										 (problemType "solvedQuizProblem")
										 (quizProblemsTutoredList ?list))
;;										 (requestType "feedback-request"))
			    (ModelTraceWorkingMemory (studentEnteredProblem ?enteredProblem&:(neq ?enteredProblem nil))
										 (problemType "failedQuizProblem")
										 (quizProblemsFailedList ?list))
;;										 (requestType "hint-request"))
			    (ModelTraceWorkingMemory (studentEnteredProblem ?enteredProblem&:(neq ?enteredProblem nil))
										 (problemType "solvedQuizProblem")
										 (quizProblemsTutoredList ?list)))
;;										 (requestType "hint-request")))
	(test (problem-type ?list ?enteredProblem))
	=>
	(predicted-sai "next problem" ButtonPressed -1)
	(update-wm-if-ruleSAI-equals-studentSAI ?wm "(problemStatus abandoned)" "(studentEnteredProblem nil)" "(requestType nil)"
		"(lhsQProblem nil)" "(rhsQProblem nil)" "(lhsProblem nil)" "(rhsProblem nil)"))


(defrule simst-quit-problem2
	(declare (salience 75))
	?wm <- (ModelTraceWorkingMemory (studentEnteredProblem ?enteredProblem&:(neq ?enteredProblem nil)))
	=>
	(predicted-sai "next problem" ButtonPressed -1)
	(update-wm-if-ruleSAI-equals-studentSAI ?wm "(studentEnteredProblem nil)" "(requestType nil)"
		"(lhsProblem nil)" "(rhsProblem nil)"))


(defrule simst-fail-quizP-solved-take-quiz
	(declare (salience 300))
	?wm <- (or (ModelTraceWorkingMemory (problemType "failedQuizProblem")
									(problemStatus "solved")
									(studentEnteredProblem ?enteredProblem&:(eq ?enteredProblem nil))
									(UOTabReviewed ?tabClicked&:(neq ?tabClicked "true")))
			   (ModelTraceWorkingMemory (problemType "solvedQuizProblem")
									(problemStatus "solved")
									(studentEnteredProblem ?enteredProblem&:(eq ?enteredProblem nil))
									(hintRequestSolvedQuizProblem ?var&:(eq ?var nil))))
	=>
	(predicted-sai quiz ButtonPressed -1)
	(update-wm-if-ruleSAI-equals-studentSAI ?wm "(quizTaken true)" "(problemStatus nil)")
	(construct-tutor-hint-message 
		"[ SimStName has had some practice on the failed quiz problem. It would be good to see if SimStName can solve it now. ]"
		"[ Click the Quiz button. ]"))


(defrule simst-fail-quizP-solved-review-UO
	(declare (salience 100))
	?wm <- (or (ModelTraceWorkingMemory (problemType "failedQuizProblem")
									(problemStatus "solved")
									(studentEnteredProblem ?enteredProblem&:(eq ?enteredProblem nil))
									(UOTabReviewed ?tabClicked&:(neq ?tabClicked "true")))
			   (ModelTraceWorkingMemory (problemType "solvedQuizProblem")
									(problemStatus "solved")
									(studentEnteredProblem ?enteredProblem&:(eq ?enteredProblem nil))
									(hintRequestSolvedQuizProblem "true")
									(UOTabReviewed ?tabClicked&:(neq ?tabClicked "true")))
			   (ModelTraceWorkingMemory (problemType "solvedQuizProblem")
									(problemStatus "abandoned")
									(quizProblemsTutoredList ?tutoredProblems&:(neq ?tutoredProblems nil))
									(studentEnteredProblem ?enteredProblem&:(eq ?enteredProblem nil))))
	=>
	(predicted-sai UnitOverview TabClicked -1)
	(update-wm-if-ruleSAI-equals-studentSAI ?wm "(UOTabReviewed true)"))


;; 
;; Rule to trace every tab action on the interface.
(defrule simst-tab-clicked
	(declare (salience 50))
	(studentValues (selection ?sel) (action "TabClicked") (input ?inp))
	=>
	(predicted-sai ?sel TabClicked ?inp))	


(defrule simst-fail-quizP-solved-enter-lhs-solved-quizPType
	(declare (salience 125))
	?wm <- (or (ModelTraceWorkingMemory (problemType "failedQuizProblem")
									(problemStatus "solved")
									(UOTabReviewed ?tabClicked&:(neq ?tabClicked "true"))
									(quizProblemsTutoredList ?tutoredProblems&:(neq ?tutoredProblems nil))
									(studentEnteredProblem ?enteredProblem&:(eq ?enteredProblem nil)))
			   (ModelTraceWorkingMemory (problemType "solvedQuizProblem") 
									(problemStatus "solved")
									(hintRequestSolvedQuizProblem "true")
									(quizProblemsTutoredList ?tutoredProblems&:(neq ?tutoredProblems nil))
									(UOTabReviewed ?tabClicked&:(neq ?tabClicked "true"))
									(studentEnteredProblem ?enteredProblem&:(eq ?enteredProblem nil)))
			   (ModelTraceWorkingMemory (problemType "solvedQuizProblem")
									(problemStatus "abandoned")
									(quizProblemsTutoredList ?tutoredProblems&:(neq ?tutoredProblems nil))
									(studentEnteredProblem ?enteredProblem&:(eq ?enteredProblem nil)))
			   (ModelTraceWorkingMemory (problemStatus "solved")
									(UOTabReviewed "true")
									(quizProblemsTutoredList ?tutoredProblems&:(neq ?tutoredProblems nil))
									(studentEnteredProblem ?enteredProblem&:(eq ?enteredProblem nil))))
	(studentValues (selection ?sel) (input ?inp))
	=>
	(bind ?firstTutoredProblem (get-first-problem ?tutoredProblems))
	(bind ?similarPType (get-similar-problem ?firstTutoredProblem))
	(bind ?lhsSimilarPType (get-lhs ?similarPType))
	(bind ?rhsSimilarPType (get-rhs ?similarPType))
	(bind ?problem (comp-problem-with-hindsight ?tutoredProblems ?inp ?sel dorminTable2_C1R1))
	(bind ?lhs-problem (get-lhs ?problem))
	(bind ?rhs-problem (get-rhs ?problem))
	(predicted-sai dorminTable1_C1R1 UpdateTable ?lhs-problem)
	(update-wm-if-ruleSAI-equals-student-entered-side ?wm lhsQProblem ?lhs-problem)
;;	(update-wm-if-student-problem-matches-list ?tutoredProblems ?sel dorminTable2_C1R1 ?wm 
;;		studentEnteredProblem ?similarP problemStatus nil problemType solvedQuizProblem hintRequestSolvedQuizProblem nil UOTabReviewed nil)
	(construct-tutor-hint-message 
		"[ It can help SimStName to get more practice on the same type of problem. ]"
		"[ You may want to give " ?similarPType " , since it is similar to a problem that you already tutored SimStName. ]"
		"[ Start by putting " ?lhsSimilarPType " on the first fraction and  " ?rhsSimilarPType " on the second fraction of the tutoring interface. ]"))


(defrule simst-fail-quizP-solved-enter-rhs-solved-quizPType
	(declare (salience 100))
	?wm <- (or (ModelTraceWorkingMemory (problemType "failedQuizProblem") 
									(problemStatus "solved")
									(UOTabReviewed ?tabClicked&:(neq ?tabClicked "true"))
									(quizProblemsTutoredList ?tutoredProblems&:(neq ?tutoredProblems nil))
									(studentEnteredProblem ?enteredProblem&:(eq ?enteredProblem nil)))
			   (ModelTraceWorkingMemory (problemType "solvedQuizProblem")	
									(problemStatus "solved")
									(hintRequestSolvedQuizProblem "true")
									(quizProblemsTutoredList ?tutoredProblems&:(neq ?tutoredProblems nil))
									(UOTabReviewed ?tabClicked&:(neq ?tabClicked "true"))
									(studentEnteredProblem ?enteredProblem&:(eq ?enteredProblem nil)))
			   (ModelTraceWorkingMemory (problemType "solvedQuizProblem")
									(problemStatus "abandoned")
									(quizProblemsTutoredList ?tutoredProblems&:(neq ?tutoredProblems nil))
									(studentEnteredProblem ?enteredProblem&:(eq ?enteredProblem nil)))
			   (ModelTraceWorkingMemory (problemStatus "solved")
									(UOTabReviewed "true")
									(quizProblemsTutoredList ?tutoredProblems&:(neq ?tutoredProblems nil))
									(studentEnteredProblem ?enteredProblem&:(eq ?enteredProblem nil))))
	(studentValues (selection ?sel) (input ?inp))
	=>
	(bind ?firstTutoredProblem (get-first-problem ?tutoredProblems))
	(bind ?similarPType (get-similar-problem ?firstTutoredProblem))
	(bind ?problem (comp-problem-with-hindsight ?tutoredProblems ?inp ?sel dorminTable1_C1R1))
	(bind ?rhs-problem (get-rhs ?problem))
	(predicted-sai dorminTable2_C1R1 UpdateTable ?rhs-problem)
	(update-wm-if-ruleSAI-equals-student-entered-side ?wm rhsQProblem ?rhs-problem))
;;	(update-wm-if-student-problem-matches-list ?tutoredProblems dorminTable1_C1R1 ?sel ?wm 
;;		studentEnteredProblem ?similarP problemStatus nil problemType solvedQuizProblem hintRequestSolvedQuizProblem nil UOTabReviewed nil))


(defrule simst-start-solved-quiz-problem
	(declare (salience 200))
	?wm <- (ModelTraceWorkingMemory (quizProblemsTutoredList ?tutoredProblems&:(neq ?tutoredProblems nil))
								(studentEnteredProblem ?enteredProblem&:(eq ?enteredProblem nil))
								(lhsQProblem ?lhs&:(neq ?lhs nil))
								(rhsQProblem ?rhs&:(neq ?rhs nil)))
	(studentValues (selection ?sel&:(eq ?sel "yes")))
	(test (problem-type ?tutoredProblems (get-problem ?lhs ?rhs)))
	=>
	(predicted-sai yes ButtonPressed -1)
	(bind ?problem (get-problem ?lhs ?rhs))
	(update-wm-if-student-problem-matches-list ?tutoredProblems dorminTable1_C1R1 dorminTable2_C1R1 ?wm
		studentEnteredProblem ?problem problemType solvedQuizProblem problemStatus nil requestType nil quizTaken nil hintRequestSolvedQuizProblem nil UOTabReviewed nil))


;; Merged in the above rule simst-fail-quizP-solved-enter-lhs-solved-quizPType
;;(defrule simst-UOReviewed-enter-lhs-solved-quizPType
;;	(declare (salience 125))
;;	?wm <- (ModelTraceWorkingMemory (problemStatus "solved")
;;								(UOTabReviewed "true")
;;								(quizProblemsTutoredList ?tutoredProblems&:(neq ?tutoredProblems nil))
;;								(studentEnteredProblem ?enteredProblem&:(eq ?enteredProblem nil)))
;;	(studentValues (selection ?sel) (input ?inp))
;;	=>
;;	(bind ?problem (comp-problem-with-hindsight ?tutoredProblems ?inp ?sel dorminTable2_C1R1))
;;	(bind ?lhs-problem (get-lhs ?problem))
;;	(predicted-sai dorminTable1_C1R1 UpdateTable ?lhs-problem)
;;	(update-wm-if-student-problem-matches-list ?tutoredProblems ?sel dorminTable2_C1R1 ?wm
;;		studentEnteredProblem ?problem problemStatus nil problemType solvedQuizProblem UOTabReviewed nil)
;;	(construct-tutor-hint-message 
;;		"[ ]"))

;; Merged in the above rule simst-fail-quizP-solved-enter-lhs-solved-quizPType
;;(defrule simst-UOReviewed-enter-rhs-solved-quizPType
;;	(declare (salience 100))
;;	?wm <- (ModelTraceWorkingMemory (problemStatus "solved")
;;								(UOTabReviewed "true")
;;								(quizProblemsTutoredList ?tutoredProblems&:(neq ?tutoredProblems nil))
;;								(studentEnteredProblem ?enteredProblem&:(eq ?enteredProblem nil)))
;;	(studentValues (selection ?sel) (input ?inp))
;;	=>
;;	(bind ?problem (comp-problem-with-hindsight ?tutoredProblems ?inp ?sel dorminTable1_C1R1))
;;	(bind ?rhs-problem (get-rhs ?problem))
;;	(predicted-sai dorminTable2_C1R1 UpdateTable ?rhs-problem)
;;	(update-wm-if-student-problem-matches-list ?tutoredProblems dorminTable1_C1R1 ?sel ?wm
;;		studentEnteredProblem ?problem problemStatus nil problemType solvedQuizProblem UOTabReviewed nil))


(defrule simst-fail-quizP-solved-enter-lhs-different-failed-quizP
	(declare (salience 225))
	?wm <- (or (ModelTraceWorkingMemory (problemType "failedQuizProblem")
									(problemStatus "solved")
									(UOTabReviewed ?tabClicked&:(neq ?tabClicked "true"))
									(quizProblemsFailedList ?suggestedProblems&:(neq ?suggestedProblems nil))
									(studentEnteredProblem ?enteredProblem&:(eq ?enteredProblem nil)))
				(ModelTraceWorkingMemory (problemType "solvedQuizProblem")
									(problemStatus "solved")
									(UOTabReviewed ?tabClicked&:(neq ?tabClicked "true"))
									(quizProblemsFailedList ?suggestedProblems&:(neq ?suggestedProblems nil))
									(studentEnteredProblem ?enteredProblem&:(eq ?enteredProblem nil))
									(hintRequestSolvedQuizProblem ?var&:(eq ?var nil)))
				(ModelTraceWorkingMemory (problemType "failedQuizProblem")
									(problemStatus "abandoned")
									(quizProblemsFailedList ?suggestedProblems&:(neq ?suggestedProblems nil))
									(studentEnteredProblem ?enteredProblem&:(eq ?enteredProblem nil))
									(quizProblemsTutoredList ?tutoredProblems&:(neq ?tutoredProblems nil))
									(quizTaken ?var&:(eq ?var nil))))
	(studentValues (selection ?sel) (input ?inp))
	=>
	(bind ?problem (comp-problem-with-hindsight ?suggestedProblems ?inp ?sel dorminTable2_C1R1))
	(bind ?lhs-problem (get-lhs ?problem))
	(bind ?rhs-problem (get-rhs ?problem))
	(predicted-sai dorminTable1_C1R1 UpdateTable ?lhs-problem)
	(update-wm-if-ruleSAI-equals-student-entered-side ?wm lhsQProblem ?lhs-problem)
	(construct-tutor-hint-message 
		"[ SimStName got some problems wrong on the quiz. Its a good strategy to teach those problems to help SimStName correct the mistakes. ]"
		"[ Since " ?problem " was wrong on the quiz, you may want to give " ?problem " to SimStName. ]"
		"[ Start by putting " ?lhs-problem " on the first fraction and  " ?rhs-problem " on the second fraction of the tutoring interface. ]"))	
;;	(update-wm-if-student-problem-matches-list ?suggestedProblems ?sel dorminTable2_C1R1 ?wm 
;;		studentEnteredProblem ?problem problemStatus nil problemType failedQuizProblem))


(defrule simst-fail-quizP-solved-enter-rhs-different-failed-quizP
	(declare (salience 200))
	?wm  <- (or (ModelTraceWorkingMemory (problemType "failedQuizProblem")
									 (problemStatus "solved")
									 (UOTabReviewed ?tabClicked&:(neq ?tabClicked "true"))
									 (quizProblemsFailedList ?suggestedProblems&:(neq ?suggestedProblems nil))
									 (studentEnteredProblem ?enteredProblem&:(eq ?enteredProblem nil)))
				(ModelTraceWorkingMemory (problemType "solvedQuizProblem")
									 (problemStatus "solved")
									 (UOTabReviewed ?tabClicked&:(neq ?tabClicked "true"))
									 (quizProblemsFailedList ?suggestedProblems&:(neq ?suggestedProblems nil))
									 (studentEnteredProblem ?enteredProblem&:(eq ?enteredProblem nil))
									 (hintRequestSolvedQuizProblem ?var&:(eq ?var nil)))
				(ModelTraceWorkingMemory (problemType "failedQuizProblem") 
									(problemStatus "abandoned")
									(quizProblemsFailedList ?suggestedProblems&:(neq ?suggestedProblems nil))
									(studentEnteredProblem ?enteredProblem&:(eq ?enteredProblem nil))
									(quizProblemsTutoredList ?tutoredProblems&:(neq ?tutoredProblems nil))
									(quizTaken ?var&:(eq ?var nil))))
	(studentValues (selection ?sel) (input ?inp))
	=>
	(bind ?problem (comp-problem-with-hindsight ?suggestedProblems ?inp ?sel dorminTable1_C1R1))
	(bind ?rhs-problem (get-rhs ?problem))
	(predicted-sai dorminTable2_C1R1 UpdateTable ?rhs-problem)
	(update-wm-if-ruleSAI-equals-student-entered-side ?wm rhsQProblem ?rhs-problem))
;;	(update-wm-if-student-problem-matches-list ?suggestedProblems dorminTable1_C1R1 ?sel ?wm 
;;		studentEnteredProblem ?problem problemStatus nil problemType failedQuizProblem))


;;(defrule simst-same-problem-type-solved
;;	(declare (salience 100))
;;	?wm <- (ModelTraceWorkingMemory (condition true)
;;									(hint-request yes))
;;	=>
;;	(predicted-sai DONT-CARE DONT-CARE DONT-CARE))


;;(defrule simst-same-problem-type-solved
;;	(declare (salience 100))
;;	?wm <- (ModelTraceWorkingMemory (condition true)
;;									(hint-request no))
;;	=>
;;	(predicted-sai DONT-CARE DONT-CARE DONT-CARE))


(defrule simst-hint-update-request
	(declare (salience 200))
	?wm <- (ModelTraceWorkingMemory (studentEnteredProblem ?enteredProblem&:(neq ?enteredProblem nil)))
	(studentValues (selection ?sel&:(eq ?sel "sshint")))
	=>
	(predicted-sai ?sel DONT-CARE DONT-CARE)
	(modify ?wm (requestType hint-request)))
;;	(update-wm-if-ruleSAI-equals-studentSAI ?wm "(requestType hint-request)"))


(defrule simst-feedback-update-request
	(declare (salience 200))
	?wm <- (ModelTraceWorkingMemory (studentEnteredProblem ?enteredProblem&:(neq ?enteredProblem nil)))
	(studentValues (selection ?sel&:(eq ?sel "ssfeedback")))
	=>
	(predicted-sai ?sel DONT-CARE DONT-CARE)
	(modify ?wm (requestType feedback-request)))
;;	(update-wm-if-ruleSAI-equals-studentSAI ?wm "(requestType feedback-request)"))


(defrule simst-quiz-status-and-problem-update-request
	(declare (salience 200))
	?wm <- (ModelTraceWorkingMemory (quizTaken "true"))
	(studentValues (selection ?sel&:(eq ?sel "ssquizCompleted")) (input ?inp))
	=>
	(predicted-sai ?sel DONT-CARE DONT-CARE)
	(bind ?status (get-quiz-status ?inp))
	(bind ?problemsList (get-failed-quiz-items ?inp))
	(modify ?wm (quizOutcome ?status) (quizProblemsFailedList ?problemsList) (quizProblemsTutoredList nil)))


;;
;; If [APlusLaunched]
;; Then
;; [Switch to SimSt Tab]
;;(defrule simst-switch-tab
;;	(declare (salience 100)) ;; salience determines the priority of the rules : higher the salience, higher the priority
;;	?var <- (ModelTraceWorkingMemory (modelTracedEvents ?eventsList))
;;	(test (eq (get-first-event ?var) "APlusLaunched"))
;;	=>
;;	(predict-tutor-action SimStName TabClicked -1)
;;	(update-mt-working-memory ?var SimStName)
;;	(construct-tutor-hint-message
;;		"[ You should read through the Unit Overview. ]"
;;		"[ Then switch to the SimStName tab and give SimStName the quiz ]"))



;;
;; If [SimSt Tab]
;; Then
;; [Quiz]
;;(defrule simst-take-quiz
;;	(declare (salience 100))
;;	?var <- (ModelTraceWorkingMemory (modelTracedEvents ?eventsList))
;;	(test (eq (get-first-event ?var) (get-member SimSt SimStName)))
;;	=>
;;	(predict-tutor-action quiz ButtonPressed -1)
;;	(update-mt-working-memory ?var quiz)
;;	(construct-tutor-hint-message
;;		"[ Before you start teaching its a good strategy to quiz SimStName. ]"
;;		"[ This would give you an idea of what SimStName already knows. ]"
;;		"[ Click the Quiz SimStName button. ]"))



;;
;; If [Quiz] And not[Quiz Section Passed]
;; Then
;; enter {failed problem on Quiz}
;;(defrule simst-quiz-fail-tutor-quiz-problem
;;	(declare (salience 100))
;;	?var <- (ModelTraceWorkingMemory {quizOutcome == "fail"} (modelTracedEvents ?eventsList) (currentProblem ?problemEntered)(quizProblemsFailed ?problemList))
;;	(test (eq (get-first-event ?var) "quiz"))
;;	=>
;;	(bind ?problem (check-problem-started ?problemEntered ?problemList))
;;	(bind ?firstProblem (get-first-quiz-failed-problem ?problemList)) 
;;	;;(predict-tutor-action ?firstProblem StartProblem -1)
;;	(update-mt-working-memory ?var ?problem quizProblem) 	
;;	(construct-tutor-hint-message 
;;		"[ SimStName got some problems wrong on the quiz. ]"
;;		"[ Its a good strategy to teach those problems. This would help SimStName correct the mistakes. ]"
;;		"[ You should give " ?firstProblem " . ]"))



;;
;; If [Quiz] And not[Quiz Section Passed]
;; Then
;; enter {second failed problem on Quiz}
;;(defrule simst-quiz-fail-second
;;	(declare (salience 75))
;;	?var <- (ModelTraceWorkingMemory {quizOutcome == "fail"} (modelTracedEvents ?eventsList) (quizProblemsFailed ?problemList))
;;	(test (eq (get-first-event ?var) "quiz"))
;;	=>
;;	(bind ?secondProblem (get-second-quiz-failed-problem ?problemList))
;;	(predict-tutor-action StartStateElements StartProblem ?secondProblem)
;;	(update-mt-working-memory ?var ?secondProblem))



;;
;; If [Quiz] And [Quiz Section Passed]
;; Then
;; [Quiz]
;;(defrule simst-quiz-pass
;;	(declare (salience 100))
;;	?var <- (ModelTraceWorkingMemory {quizOutcome == "pass"} (modelTracedEvents ?eventsList))
;;	(test (eq (get-first-event ?var) "quiz"))
;;	=>
;;	(predict-tutor-action quiz ButtonPressed -1)
;;	(update-mt-working-memory ?var quiz)
;;	(construct-tutor-hint-message
;;		"[  Why don't you quiz SimStName again so that SimStName works on next section of the quiz. ]" ))



;;
;; (BUG) If [Quiz] And not[Quiz Section Passed]
;; Then
;; [Quiz]
;;(defrule BUG-simst-quiz-fail
;;	(declare (salience 50))
;;	?var <- (ModelTraceWorkingMemory {quizOutcome == "fail"} (modelTracedEvents ?eventsList))
;;	(test (eq (get-first-event ?var) "quiz"))
;;	=>
;;	(predict-tutor-action quiz ButtonPressed -1))



;;
;; If [Failed Quiz Problem Solved]
;; Then
;; enter {failed quiz problem type}
;;(defrule simst-quiz-problem-solved-enter-problem-type
;;	(declare (salience 150))
;;	?var <- (ModelTraceWorkingMemory (quizProblemsFailed ?problemList) (modelTracedEvents ?eventsList))
;;	(test (eq (get-first-event ?var) "quizProblem"))
;;	=>
;;	(bind ?failedQuizProblem (get-second-event ?var))
;;	(bind ?failedProblemType (get-abstracted-problem ?failedQuizProblem))
;;	(predict-tutor-action ?failedProblemType StartProblem -1)
;;	(update-mt-working-memory ?var ?failedProblemType quizProblemType)
;;	(construct-tutor-hint-message
;;		"[	Why don't you teach a similar problem like" ?failedQuizProblem " to see if SimStName can solve it. ]" ))



;;
;; If [Failed Quiz Problem Solved]
;; Then
;; [Review Unit Overview]
;;(defrule simst-quiz-problem-solved-review-unit-overview
;;	(declare (salience 100))
;;	?var <- (ModelTraceWorkingMemory (quizProblemsFailed ?problemList) (modelTracedEvents ?eventsList))
;;	(test (eq (get-first-event ?var) "quizProblem"))
;;	=>
;;	(predict-tutor-action UnitOverview TabClicked -1)
;;	(update-mt-working-memory ?var UnitOverview))



;;
;; If [Unit Overview]
;; Then
;; enter {failed quiz problem type}
;;(defrule unit-overview-do-failed-quiz-problem-type
;;	(declare (salience 100))
;;	?var <- (ModelTraceWorkingMemory (quizProblemsFailed ?problemList) (modelTracedEvents ?eventsList))
;;	(test (eq (get-first-event ?var) "UnitOverview"))
;;	=>
;;	)



;;
;; If [Failed Quiz Problem Solved]
;; Then
;; [Quiz]
;;(defrule simst-quiz-problem-solved-take-quiz
;;	(declare (salience 100))
;;	?var <- (ModelTraceWorkingMemory (quizProblemsFailed ?problemList) (modelTracedEvents ?eventsList))
;;	(test (eq (get-first-event ?var) "quizProblem"))
;;	=>
;;	(predict-tutor-action quiz ButtonPressed -1)
;;	(update-mt-working-memory ?var quiz))



;;
;; If [Failed Quiz Problem Solved] And [Quiz Items Left]
;; Then
;; enter {failed quiz problem}
;;(defrule simst-quiz-problem-solved-tutor-failed-problem
;;	(declare (salience 100))
;;	?var <- (ModelTraceWorkingMemory (quizProblemsFailed ?problemList) (modelTracedEvents ?eventsList) (currentProblem ?problemEntered)
;;		(failedQuizProblemsSolved ?solvedList))
;;	(test (eq (get-first-event ?var) "quizProblem"))
;;	(test (quiz-items-left ?problemList ?solvedList))
;;	=>
;;	(bind ?problem (check-problem-started ?problemEntered ?problemList))
;;	(update-mt-working-memory ?var ?problem quizProblem))



;;
;; If [Failed Quiz Problem Solved] And [Quiz Items Left]
;; Then
;; enter {first failed quiz problem}
;;(defrule simst-quiz-problem-solved-tutor-first-failed-problem
;;	(declare (salience 100))
;;	?var <- (ModelTraceWorkingMemory {problemSolved == "true"} (quizProblemsFailed ?problemList) (failedQuizProblemsSolved ?solvedList)
;;		(completedProblem ?compProblem))
;;	(test (solved-problem-type ?problemList ?compProblem))
;;	(test (quiz-items-left ?problemList ?solvedList))
;;	=>
;;	(bind ?firstProblem (get-first-quiz-failed-problem ?problemList)) 
;;	(predict-tutor-action StartStateElements StartProblem ?firstProblem))



;;
;; If [Failed Quiz Problem Solved] And not[Quiz Items Left]
;; Then
;; [Quiz]
;;(defrule simst-quiz-problem-solved-no-quiz-items-left-take-quiz
;;	(declare (salience 100))
;;	?var <- (ModelTraceWorkingMemory (quizProblemsFailed ?problemList) (modelTracedEvents ?eventsList) (failedQuizProblemsSolved ?solvedList))
;;	(test (eq (get-first-event ?var) "quizProblem"))
;;	(not (test (quiz-items-left ?problemList ?solvedList)))
;;	=>
;;	(predict-tutor-action quiz ButtonPressed -1)
;;	(update-mt-working-memory ?var quiz))



;;
;; If [Failed Quiz Problem Type Solved] And not[Help given]
;; Then
;; [Quiz]
;;(defrule simst-failed-quiz-problem-type-solved-nohelp-do-quiz
;;	(declare (salience 100))
;;	?var <- (ModelTraceWorkingMemory {hintRequestOnQuizProblemType == "false"} (modelTracedEvents ?eventsList))
;;	(test (eq (get-first-event ?var) "quizProblemType"))
;;	=>
;;	(predict-tutor-action quiz ButtonPressed -1)
;;	(update-mt-working-memory ?var quiz))



;;
;; If [Failed Quiz Problem Type Solved] And not[Help given] And [Quiz Items Left]
;; Then
;; enter {failed quiz problem}
;;(defrule simst-failed-quiz-problem-type-solved-nohelp-quizitemsleft-do-failed-quiz-problem
;;	(declare (salience 100))
;;	?var <- (ModelTraceWorkingMemory {hintRequestOnQuizProblemType == "false"} (quizProblemsFailed ?problemList) (failedQuizProblemsSolved ?solvedList) 
;;		(currentProblem ?problemEntered) (modelTracedEvents ?eventsList))
;;	(test (eq (get-first-event ?var) "quizProblemType"))
;;	(test (quiz-items-left ?problemList ?solvedList))
;;	=>
;;	(bind ?problem (check-problem-started ?problemEntered ?problemList))
;;	(update-mt-working-memory ?var ?problem quizProblem))



;;
;; If [Failed Quiz Problem Type Solved] And not[Help given] And not[Quiz Items Left]
;; Then
;; [Quiz]
;;(defrule simst-failed-quiz-problem-type-solved-nohelp-noquizitemsleft-do-quiz
;;	(declare (salience 100))
;;	?var <- (ModelTraceWorkingMemory {hintRequestOnQuizProblemType == "false"} (quizProblemsFailed ?problemList) (failedQuizProblemsSolved ?solvedList) 
;;		(modelTracedEvents ?eventsList))
;;	(test (eq (get-first-event ?var) "quizProblemType"))
;;	(not (test (quiz-items-left ?problemList ?solvedList)))
;;	=>
;;	(predict-tutor-action quiz ButtonPressed -1)
;;	(update-mt-working-memory ?var quiz))



;;
;; If [Failed Quiz Problem Solved] And [Unit Overview Reviewed]
;; Then
;; enter {failed quiz problem type}
;;(defrule unit-overview-reviewed-tutor-failed-prob-type
;;	(declare (salience 200))
;;	(ModelTraceWorkingMemory {problemSolved == "true"} {unitOverviewTab == "TabClicked"} (completedProblem ?compProblem)
;;		(quizProblemsFailed ?problemList))
;;	(test (solved-problem-type ?problemList ?compProblem))
;;	=>
;;	(bind ?failedProblemType (get-abstracted-problem ?compProblem))
;;	(predict-tutor-action StartStateElements StartProblem ?failedProblemType)
;;	(bind ?ssName (get-member SimSt SimStName))
;;	(construct-tutor-hint-message
;;		"[	]" ))



;;
;; If [Failed Quiz Problem Type Solved] And not[Help given for the solved problem]
;; Then
;; [Quiz]
;;(defrule failed-quiz-problem-solved-without-help
;;	(declare (salience 100))
;;	(ModelTraceWorkingMemory {problemSolved == "true"} {hintRequestOnProblem == "false"} (completedProblem ?compProblem)
;;		(quizProblemsFailed ?problemList))
;;	=>
;;	(predict-tutor-action quiz ButtonPressed -1))



;;
;; If [Problem Solved] And not[Help given for the previous problem]
;; Then
;; [Quiz]
;;(defrule problem-solved-without-help
;;	(declare (salience 100))
;;	(ModelTraceWorkingMemory {problemSolved == "true"} {hintRequestOnProblem == "false"})
;;	=>
;;	(predict-tutor-action quiz ButtonPressed -1)
;;	(bind ?ssName (get-member SimSt SimStName))	
;;	(construct-tutor-hint-message
;;		"[ " ?ssName " did not get stuck. ]"
;;		"[ You should give a quiz now to see how" ?ssName " does on the quiz.]"
;;		"[ Click on Quiz " ?ssName " button. ]"))


	
;;
;; If [Tutor Next Problem] And [Quiz] is not before [Tutor Next Problem]
;; Then
;; [Review Unit Overview] 
;;(defrule review-unit-overview
;;	(declare (salience 75))
;;	?var <- (ModelTraceWorkingMemory {tutorNextProblem == "ButtonPressed"})
;;	(not (test (quiz-before-tutor-next-problem ?var)))
;;	=>
;;	(predict-tutor-action UnitOverview TabClicked -1)
;;	(construct-tutor-hint-message
;;		"[ You should look at the Unit Overview for problems. ]"
;;		"[ You should pick problems similar to the ones Stacy got wrong on the quiz.]"
;;		"[ Select the Unit Overview Tab above. ]"))
	
	

;;
;; If [Unit Overview Reviewed]
;; Then
;; {select first problem in the Unit Overview in sync with the [Quiz Level]}
;;(defrule tutor-problem
;;	(declare (salience 85))
;;	(ModelTraceWorkingMemory {unitOverviewTab == "TabClicked"})
;;	=>
;;	(bind ?ssName (get-member SimSt SimStName))
;;	(construct-tutor-hint-message
;;		"[ You should give the following problem to" ?ssName ". ]" ))



;; USE-PROBLEM-BANK
;;
;; If a student should enter a new problem and did not just complete a quiz
;; Then
;; (Student tutor) should use the problem bank.
;;(defrule use-problem-bank
;;	"If a student should enter a new problem and did not just complete a quiz then use the problem bank"
;;	(declare (salience 100))
;;	(ModelTraceWorkingMemory {enterProblem == "true"} {lastAction != "Quiz"} {lastAction != "ProblemBank"} )
;;	=>
;;	(predict-tutor-action ProblemBank TabClicked -1)
;;	(construct-tutor-hint-message
;;		"[	You should look at the problem bank. ]"))



;; TUTOR-PROBLEM
;;
;; If problem bank was just reviewed
;; Then
;; give a problem that has never been solved.
;;(defrule tutor-problem
;;	(declare (salience 100))
;;	(ModelTraceWorkingMemory {enterProblem == "true"} {lastAction == "ProblemBank"} (problemEntered ?problemEntered) (suggestedProblem ?suggestedProblem))
;;	=>
;;	(bind ?ssName (get-member SimSt SimStName))
;;	(check-problem-started ?problemEntered ?suggestedProblem)
;;	(construct-tutor-hint-message
;;		"[ You should give the following problem" ?suggestedProblem " to" ?ssName ". ]"))



;; BUG-PROBLEM-SOLVED-ON-QUIZ
;;
;; If a student should enter a new problem
;; Then
;; (Student tutor) provides a exact problem which has been solved correctly on the quiz.
;;(defrule BUG-problem-solved-on-quiz
;;	"If a student should enter a new problem then provide an exact problem which has been solved correctly on the quiz"
;;	(declare (salience 50))
;;	(ModelTraceWorkingMemory {enterProblem == "true"} (problemEntered ?problemEntered) (quizProblemsPassed ?problemList))
;;	=>
;;	(check-problem-started ?problemEntered ?problemList)
;;	(construct-tutor-hint-message
;;		"[ ]"))



;; SIMST-QUIZ-SOLVED-CORRECTLY
;;
;; If SimStudent solves all the quiz items correctly
;; Then
;; (Student tutor) should quiz SimStudent again
;;(defrule simst-quiz-solved-correctly
;;	"If SimStudent solves all the quiz items correctly then quiz SimStudent again"
;;	(declare (salience 100))
;;	(ModelTraceWorkingMemory {quizOutcome == "pass"})
;;	=>
;;	(bind ?ssName (get-member SimSt SimStName))
;;	(predict-tutor-action quiz ButtonPressed -1)
;;	(construct-tutor-hint-message
;;		"[  Why don't you quiz" ?ssName " again so that" ?ssName " works on next section of the quiz. ]" ))
	


;; SIMST-QUIZ-FAIL
;;
;; If SimStudent fails on a quiz
;; Then
;; (Student tutor) should give type of problem which SimStudent got wrong on the quiz.
;;(defrule simst-quiz-fail
;;	"If SimStudent fails on a quiz, then tutor SimStudent type of problem which SimStudent got wrong on quiz"
;;	(declare (salience 100))
;;	(ModelTraceWorkingMemory {quizOutcome == "fail"} (problemEntered ?problemEntered) (quizProblemsFailed ?problemList) (suggestedProblems ?suggestedList))
;;	=>
;;	(bind ?ssName (get-member SimSt SimStName))
;;	(check-problem-started ?problemEntered ?problemList)
;;	(construct-tutor-hint-message 
;;		"[ " ?ssName " got some problems wrong on the quiz. ]"
;;		"[ Its a good strategy to teach those problems. This would help" ?ssName " correct the mistakes. ]"
;;		"[ You should give " ?suggestedList " . ]"))

	

;; BUG-SIMST-QUIZ-FAIL
;;
;; If SimStudent fails on a quiz
;; Then
;; (Student tutor) quizzes SimStudent again
;;(defrule BUG-simst-quiz-fail
;;	(declare (salience 50))
;;	(ModelTraceWorkingMemory {quizOutcome == "fail"})
;;	=>
;;	(bind ?ssName (get-member SimSt SimStName))
;;	(predict-tutor-action quiz ButtonPressed -1)
;;	(construct-tutor-hint-message 
;;		"[  ]" ))



;; SIMST-LAUNCH-QUIZ
;;
;; IFSimStudent is launched and Student tutor has not yet started teaching SimStudent
;; Then
;; (Student tutor) should quiz SimStudent
;;(defrule simst-launch-quiz
;;	(declare (salience 100))
;;	(ModelTraceWorkingMemory {tutoringActivityStarted == "false"})
;;	=>
;;	(bind ?ssName (get-member SimSt SimStName))
;;	(predict-tutor-action quiz ButtonPressed -1)
;;	(construct-tutor-hint-message 
;;		"[ Before you start teaching its a good strategy to quiz" ?ssName " . ]" 
;;		"[ This would give you an idea of what" ?ssName " already knows. ]"
;;		"[ Click the Quiz " ?ssName " button. ]"))



;; QUIZ-SIMSTUDENT
;;
;; If SimStudent solves a problem without any hints from the Student tutor
;; Then
;; (Student tutor) should quiz SimStudent
;;(defrule quiz-simst
;;	(declare (salience 100))
;;	(ModelTraceWorkingMemory {problemSolved == "true"} {hintRequestOnProblem == "false"})
;;	=>
;;	(bind ?ssName (get-member SimSt SimStName))	
;;	(predict-tutor-action quiz ButtonPressed -1)
;;	(construct-tutor-hint-message
;;		"[ " ?ssName " did not get stuck. ]"
;;		"[ You should give a quiz now to see how" ?ssName " does on the quiz.]"
;;		"[ Click on Quiz " ?ssName " button. ]"))



;; SIMST-CORRECT-STEP-PERFORMED
;;
;; If SimStudent does a step correctly
;; Then
;; (Student tutor) should give a positive feedback.
;;
;;(defrule simst-correct-step
;;	"If SimStudent does a step correctly then give a positive feedback"
;;	(declare (salience 100))
;;	(ModelTraceWorkingMemory {stepCorrectness == "correct"} {actor ==  "simstudent"} (step ?step))
;;	=>
;;	(bind ?ssName (get-member SimSt SimStName))
;;	(predict-tutor-action yes ButtonPressed -1)
;;	(construct-tutor-hint-message 
;;		"[ Do you know what to do when" ?ssName "does a step and asks for confirmation ? ]"
;;		"[ " ?ssName "performed the step. You should provide a feedback. ]"
;;		"[ You should click on Yes/No button. ]"))
;;	(construct-cl-hint-message
;;		"[ " ?ssName "has performed the step" ?step "correctly. ]" ))
	

;; SIMST-INCORRECT-STEP-PERFORMED
;;
;; If SimStudent does a step incorrectly
;; Then
;; (Student tutor) should give a negative feedback.
;;
;;(defrule simst-incorrect-step
;;	"If SimStudent does a step incorrectly then give a negative feedback"
;;	(declare (salience 100))
;;	(ModelTraceWorkingMemory {stepCorrectness == "incorrect"} {actor == "simstudent"} (step ?step))
;;	=>
;;	(bind ?ssName (get-member SimSt SimStName))
;;	(predict-tutor-action no ButtonPressed -1)
;;	(construct-tutor-hint-message 
;;		"[ Do you know what to do when" ?ssName "does a step and asks for confirmation ? ]"
;;		"[ " ?ssName "performed the step. You should provide a feedback. ]"
;;		"[ You should click on Yes/No button. ]"))
;;	(construct-cl-hint-message
;;		"[ " ?ssName "has performed the step" ?step "incorrectly. ]" ))
	
	
;; SIMST-HELP-REQUEST
;;
;; If SimStudent makes a help request
;; Then
;; (Student tutor) should give a correct help.
;;(defrule simst-help-request
;;	"If SimStudent makes a help request then give a correct help"
;;	(declare (salience 100)) ;; Should be preferred over BUG-rule
;;	(ModelTraceWorkingMemory {helpRequested == "true"} {examplesTabClicked == "true"} {actor == "simstudent"} (problemNodeName ?name))
;;	=>
;;	(bind ?ssName (get-member SimSt SimStName))	
;;	(bind ?ruleSAI (get-correct-sai ?name))
;;	(predict-tutor-action ?ruleSAI  UpdateTable  ?ruleSAI)
;;	(construct-tutor-hint-message 
;;		"[ " ?ssName " is requesting for help. Demonstrate the next step correctly so " ?ssName "can learn. ]" ))
;;	(construct-cl-hint-message 
;;		"[ " ?ruleSAI " ]" ))
	

;; BUG-SIMST-HELP-REQUEST
;;
;; If SimStudent makes a help request
;; Then
;; (Student tutor) gives an incorrect help.
;;(defrule BUG-simst-help-request
;;	"If SimStudent makes a help request then give an incorrect help"
;;	(declare (salience 50))
;;	(ModelTraceWorkingMemory {helpRequested == "true"} {actor == "simstudent"} (problemNodeName ?name))
;;	=>
;;	(bind ?ruleSAI (get-correct-sai ?name))
;;	(predict-tutor-action ?ruleSAI  UpdateTable  DONT-CARE))
	
	
;; BUG-SIMST-QUIZ-SOLVED-CORRECTLY
;;
;; If SimStudent solves all the quiz items correctly
;; Then
;; (Student tutor) tutors SimStudent type of problems gotten correct on the quiz
;;(defrule BUG-simst-quiz-solved-correctly
;;	"If SimStudent solves all the quiz items correctly then tutor SimStudent type of problems which it got correct on the quiz"
;;	(declare (salience 50))
;;	(ModelTraceWorkingMemory {quizOutcome == "pass"} (ssName ?ssName) (problemEntered ?problemEntered) (quizProblemsPassed ?problemList))
;;	=>
;;	(check-problem-started ?problemEntered ?problemList)
;;	(construct-tutor-hint-message
;;		"[	]" ))

	

;; STUDENT-VIEW-EXAMPLES
;; 
;; If SimStudent makes a help request and Student tutor has not seen any examples yet
;; Then
;; (Student tutor) should look at the examples
;;(defrule student-view-examples
;;	(declare (salience 100))
;;	(ModelTraceWorkingMemory {helpRequested == "true"} {examplesTabClicked == "false"} (ssName ?ssName))
;;	=>
;;	(predict-tutor-action example TabClicked -1)
;;	(construct-tutor-hint-message
;;		"[ You should go through all the examples using the tab above.  Make sure you understand all the examples.]"))





;; TUTOR-SIMSTUDENT-PROBLEM
;; 
;; If SimStudent solves a problem using hints from the Student tutor
;; Then
;; (Student tutor) should give a similar type of problem
;;(defrule tutor-simst-problem
;;	(declare (salience 100))
;;	(ModelTraceWorkingMemory {problemSolved == "true"} {hintRequestOnProblem == "true"} (suggestedProblem ?problem))
;;	=>
;;	(bind ?ssName (get-member SimSt SimStName))
;;	(predict-tutor-action yes ButtonPressed -1)
;;	(construct-tutor-hint-message
;;		"[ Why don't you give" ?ssName " the problem" ?problem " to see if" ?ssName " can solve it.]"))



;; HELP-REQUEST-AFTER-UNDO-STEP
;;
;; If Student tutor asks for next step to help SimStudent after undoing a step
;; Then
;; (Student tutor) should be explained that SimStudent still has the previous knowledge
;; and (Student tutor) should demonstrate to SimStudent for it to replace the previous knowledge
;;(defrule help-request-after-undo-step
;;	(declare (salience 200))
;;	(ModelTraceWorkingMemory {stepUndone == "true"})
;;	=>
;;	(bind ?ssName (get-member SimSt SimStName))	
;;	(predict-tutor-action Selection UpdateTable Input)
;;	(construct-tutor-hint-message
;;		"[ After you undo a step" ?ssName " still remembers what you taught it previously. ]"
;;		"[ You should demonstrate to" ?ssName " so she can learn and forget what you taught it previously.]"))



;;
;; If [APlusLaunched] And not[SimSt Tab]
;; Then
;; [Switch To SimSt Tab]
;;(defrule simst-launch-switch-tab
;;	(declare (salience 100))
;;	?var <- (ModelTraceWorkingMemory (modelTracedEvents ?eventsList))
;;	(test (eq (get-first-event ?var) "UnitOverview"))
;;	=>
;;	(bind ?ssName (get-member SimSt SimStName))
;;	(predict-tutor-action ?ssName TabClicked -1)
;;	(construct-tutor-hint-message
;;		"[ You should read through the Unit Overview. ]"
;;		"[ Then switch to the" ?ssName " tab and give" ?ssName " the quiz ]"))



;;
;; If [APlusLaunched] And [SimSt Tab]
;; Then
;; [Quiz]
;;(defrule simst-launch-quiz
;;	(declare (salience 100))
;;	?var <- (ModelTraceWorkingMemory (modelTracedEvents ?eventsList))
;;	(test (eq (get-first-event ?var) (get-member SimSt SimStName)))
;;	=>
;;	(predict-tutor-action quiz ButtonPressed -1)
;;	(bind ?ssName (get-member SimSt SimStName))
;;	(construct-tutor-hint-message
;;		"[ Before you start teaching its a good strategy to quiz" ?ssName " . ]"
;;		"[ This would give you an idea of what" ?ssName " already knows. ]"
;;		"[ Click the Quiz" ?ssName "button. ]"))



;;(defrule simst-launch-take-quiz
;;	"If APlusLaunched is true then take the quiz"
;;	(declare (salience 100))
;;	?var100 <- (status (name aplusLaunched) (value true))
;;	=>
;;	(predicted-sai quiz ButtonPressed -1)
;;	(modify ?var100 (name aplusLaunched) (value false))
;;	(construct-tutor-hint-message
;;		"[ Before you start teaching its a good strategy to quiz SimStName. ]"
;;		"[ This would give you an idea of what SimStName already knows. ]"
;;		"[ Click the Quiz SimStName button. ]")
;;	(facts))



;;(defrule simst-launch-quit-problem-started-take-quiz
;;	(declare (salience 150)) ;; salience determines the priority of the rules : higher the salience, higher the priority
;;	?wm <- (ModelTraceWorkingMemory (APlusLaunched "true") 
;;									(studentEnteredProblem ?enteredProblem&:(neq ?enteredProblem nil)))
;;	=>
;;	(predicted-sai quiz ButtonPressed -1) ;; predicts-the-ruleSAI
;;	(update-wm-if-ruleSAI-equals-studentSAI ?wm "(quizTaken true)" "(APlusLaunched false)" "(requestType nil)" "(studentEnteredProblem nil)")
;;	(construct-tutor-hint-message
;;		"[ It might help you to know what SimStName already knows. ]"
;;		"[ You should finish the problem and then quiz SimStName. ]"))
